Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Grammar

Rule 0     S' -> program
Rule 1     empty -> <empty>
Rule 2     program -> program function
Rule 3     program -> empty
Rule 4     type -> Int
Rule 5     function -> function_def
Rule 6     function -> function_decl
Rule 7     function_def -> type Identifier LParen parameter_list RParen LBrace block RBrace
Rule 8     function_decl -> type Identifier LParen parameter_list RParen Semi
Rule 9     parameter_list -> parameter_list Comma type_identifier_union
Rule 10    parameter_list -> type_identifier_union
Rule 11    type_identifier_union -> type
Rule 12    type_identifier_union -> type Identifier
Rule 13    parameter_list -> empty
Rule 14    block -> block block_item
Rule 15    block -> empty
Rule 16    block_item -> statement
Rule 17    block_item -> declaration Semi
Rule 18    statement -> statement_matched
Rule 19    statement -> statement_unmatched
Rule 20    statement_matched -> If LParen expression RParen statement_matched Else statement_matched
Rule 21    statement_unmatched -> If LParen expression RParen statement_matched Else statement_unmatched
Rule 22    statement_unmatched -> If LParen expression RParen statement
Rule 23    statement_matched -> While LParen expression RParen statement_matched
Rule 24    statement_unmatched -> While LParen expression RParen statement_unmatched
Rule 25    statement_matched -> Do statement_matched While LParen expression RParen Semi
Rule 26    statement_unmatched -> Do statement_unmatched While LParen expression RParen Semi
Rule 27    statement_matched -> For LParen opt_expression Semi opt_expression Semi opt_expression RParen statement_matched
Rule 28    statement_matched -> For LParen declaration Semi opt_expression Semi opt_expression RParen statement_matched
Rule 29    statement_unmatched -> For LParen opt_expression Semi opt_expression Semi opt_expression RParen statement_unmatched
Rule 30    statement_unmatched -> For LParen declaration Semi opt_expression Semi opt_expression Semi opt_expression RParen statement_unmatched
Rule 31    statement_matched -> Return expression Semi
Rule 32    statement_matched -> opt_expression Semi
Rule 33    statement_matched -> LBrace block RBrace
Rule 34    statement_matched -> Break Semi
Rule 35    statement_matched -> Continue Semi
Rule 36    opt_expression -> expression
Rule 37    opt_expression -> empty
Rule 38    declaration -> type Identifier
Rule 39    declaration -> type Identifier Assign expression
Rule 40    expression -> assignment
Rule 41    assignment -> conditional
Rule 42    conditional -> logical_or
Rule 43    logical_or -> logical_and
Rule 44    logical_and -> bit_or
Rule 45    bit_or -> xor
Rule 46    xor -> bit_and
Rule 47    bit_and -> equality
Rule 48    equality -> relational
Rule 49    relational -> additive
Rule 50    additive -> multiplicative
Rule 51    multiplicative -> unary
Rule 52    unary -> postfix
Rule 53    postfix -> primary
Rule 54    unary -> Minus unary
Rule 55    unary -> BitNot unary
Rule 56    unary -> Not unary
Rule 57    postfix -> Identifier LParen expression_list RParen
Rule 58    expression_list -> expression_list Comma expression
Rule 59    expression_list -> expression
Rule 60    expression_list -> empty
Rule 61    assignment -> Identifier Assign expression
Rule 62    logical_or -> logical_or Or logical_and
Rule 63    logical_and -> logical_and And bit_or
Rule 64    bit_or -> bit_or BitOr xor
Rule 65    xor -> xor Xor bit_and
Rule 66    bit_and -> bit_and BitAnd equality
Rule 67    equality -> equality NotEqual relational
Rule 68    equality -> equality Equal relational
Rule 69    relational -> relational Less additive
Rule 70    relational -> relational Greater additive
Rule 71    relational -> relational LessEqual additive
Rule 72    relational -> relational GreaterEqual additive
Rule 73    additive -> additive Plus multiplicative
Rule 74    additive -> additive Minus multiplicative
Rule 75    multiplicative -> multiplicative Mul unary
Rule 76    multiplicative -> multiplicative Div unary
Rule 77    multiplicative -> multiplicative Mod unary
Rule 78    conditional -> logical_or Question expression Colon conditional
Rule 79    primary -> Integer
Rule 80    primary -> Identifier
Rule 81    primary -> LParen expression RParen

Terminals, with rules where they appear

And                  : 63
Assign               : 39 61
BitAnd               : 66
BitNot               : 55
BitOr                : 64
Break                : 34
Colon                : 78
Comma                : 9 58
Continue             : 35
Div                  : 76
Do                   : 25 26
Else                 : 20 21
Equal                : 68
For                  : 27 28 29 30
Greater              : 70
GreaterEqual         : 72
Identifier           : 7 8 12 38 39 57 61 80
If                   : 20 21 22
Int                  : 4
Integer              : 79
LBrace               : 7 33
LParen               : 7 8 20 21 22 23 24 25 26 27 28 29 30 57 81
Less                 : 69
LessEqual            : 71
Minus                : 54 74
Mod                  : 77
Mul                  : 75
Not                  : 56
NotEqual             : 67
Or                   : 62
Plus                 : 73
Question             : 78
RBrace               : 7 33
RParen               : 7 8 20 21 22 23 24 25 26 27 28 29 30 57 81
Return               : 31
Semi                 : 8 17 25 26 27 27 28 28 29 29 30 30 30 31 32 34 35
While                : 23 24 25 26
Xor                  : 65
error                : 

Nonterminals, with rules where they appear

additive             : 49 69 70 71 72 73 74
assignment           : 40
bit_and              : 46 65 66
bit_or               : 44 63 64
block                : 7 14 33
block_item           : 14
conditional          : 41 78
declaration          : 17 28 30
empty                : 3 13 15 37 60
equality             : 47 66 67 68
expression           : 20 21 22 23 24 25 26 31 36 39 58 59 61 78 81
expression_list      : 57 58
function             : 2
function_decl        : 6
function_def         : 5
logical_and          : 43 62 63
logical_or           : 42 62 78
multiplicative       : 50 73 74 75 76 77
opt_expression       : 27 27 27 28 28 29 29 29 30 30 30 32
parameter_list       : 7 8 9
postfix              : 52
primary              : 53
program              : 2 0
relational           : 48 67 68 69 70 71 72
statement            : 16 22
statement_matched    : 18 20 20 21 23 25 27 28
statement_unmatched  : 19 21 24 26 29 30
type                 : 7 8 11 12 38 39
type_identifier_union : 9 10
unary                : 51 54 55 56 75 76 77
xor                  : 45 64 65

Parsing method: LALR

state 0

    (0) S' -> . program
    (2) program -> . program function
    (3) program -> . empty
    (1) empty -> .

    Int             reduce using rule 1 (empty -> .)
    $end            reduce using rule 1 (empty -> .)

    program                        shift and go to state 1
    empty                          shift and go to state 2

state 1

    (0) S' -> program .
    (2) program -> program . function
    (5) function -> . function_def
    (6) function -> . function_decl
    (7) function_def -> . type Identifier LParen parameter_list RParen LBrace block RBrace
    (8) function_decl -> . type Identifier LParen parameter_list RParen Semi
    (4) type -> . Int

    Int             shift and go to state 7

    function                       shift and go to state 3
    function_def                   shift and go to state 4
    function_decl                  shift and go to state 5
    type                           shift and go to state 6

state 2

    (3) program -> empty .

    Int             reduce using rule 3 (program -> empty .)
    $end            reduce using rule 3 (program -> empty .)


state 3

    (2) program -> program function .

    Int             reduce using rule 2 (program -> program function .)
    $end            reduce using rule 2 (program -> program function .)


state 4

    (5) function -> function_def .

    Int             reduce using rule 5 (function -> function_def .)
    $end            reduce using rule 5 (function -> function_def .)


state 5

    (6) function -> function_decl .

    Int             reduce using rule 6 (function -> function_decl .)
    $end            reduce using rule 6 (function -> function_decl .)


state 6

    (7) function_def -> type . Identifier LParen parameter_list RParen LBrace block RBrace
    (8) function_decl -> type . Identifier LParen parameter_list RParen Semi

    Identifier      shift and go to state 8


state 7

    (4) type -> Int .

    Identifier      reduce using rule 4 (type -> Int .)
    RParen          reduce using rule 4 (type -> Int .)
    Comma           reduce using rule 4 (type -> Int .)


state 8

    (7) function_def -> type Identifier . LParen parameter_list RParen LBrace block RBrace
    (8) function_decl -> type Identifier . LParen parameter_list RParen Semi

    LParen          shift and go to state 9


state 9

    (7) function_def -> type Identifier LParen . parameter_list RParen LBrace block RBrace
    (8) function_decl -> type Identifier LParen . parameter_list RParen Semi
    (9) parameter_list -> . parameter_list Comma type_identifier_union
    (10) parameter_list -> . type_identifier_union
    (13) parameter_list -> . empty
    (11) type_identifier_union -> . type
    (12) type_identifier_union -> . type Identifier
    (1) empty -> .
    (4) type -> . Int

    RParen          reduce using rule 1 (empty -> .)
    Comma           reduce using rule 1 (empty -> .)
    Int             shift and go to state 7

    type                           shift and go to state 10
    parameter_list                 shift and go to state 11
    type_identifier_union          shift and go to state 12
    empty                          shift and go to state 13

state 10

    (11) type_identifier_union -> type .
    (12) type_identifier_union -> type . Identifier

    RParen          reduce using rule 11 (type_identifier_union -> type .)
    Comma           reduce using rule 11 (type_identifier_union -> type .)
    Identifier      shift and go to state 14


state 11

    (7) function_def -> type Identifier LParen parameter_list . RParen LBrace block RBrace
    (8) function_decl -> type Identifier LParen parameter_list . RParen Semi
    (9) parameter_list -> parameter_list . Comma type_identifier_union

    RParen          shift and go to state 15
    Comma           shift and go to state 16


state 12

    (10) parameter_list -> type_identifier_union .

    RParen          reduce using rule 10 (parameter_list -> type_identifier_union .)
    Comma           reduce using rule 10 (parameter_list -> type_identifier_union .)


state 13

    (13) parameter_list -> empty .

    RParen          reduce using rule 13 (parameter_list -> empty .)
    Comma           reduce using rule 13 (parameter_list -> empty .)


state 14

    (12) type_identifier_union -> type Identifier .

    RParen          reduce using rule 12 (type_identifier_union -> type Identifier .)
    Comma           reduce using rule 12 (type_identifier_union -> type Identifier .)


state 15

    (7) function_def -> type Identifier LParen parameter_list RParen . LBrace block RBrace
    (8) function_decl -> type Identifier LParen parameter_list RParen . Semi

    LBrace          shift and go to state 17
    Semi            shift and go to state 18


state 16

    (9) parameter_list -> parameter_list Comma . type_identifier_union
    (11) type_identifier_union -> . type
    (12) type_identifier_union -> . type Identifier
    (4) type -> . Int

    Int             shift and go to state 7

    type_identifier_union          shift and go to state 19
    type                           shift and go to state 10

state 17

    (7) function_def -> type Identifier LParen parameter_list RParen LBrace . block RBrace
    (14) block -> . block block_item
    (15) block -> . empty
    (1) empty -> .

    RBrace          reduce using rule 1 (empty -> .)
    If              reduce using rule 1 (empty -> .)
    While           reduce using rule 1 (empty -> .)
    Do              reduce using rule 1 (empty -> .)
    For             reduce using rule 1 (empty -> .)
    Return          reduce using rule 1 (empty -> .)
    LBrace          reduce using rule 1 (empty -> .)
    Break           reduce using rule 1 (empty -> .)
    Continue        reduce using rule 1 (empty -> .)
    Int             reduce using rule 1 (empty -> .)
    Identifier      reduce using rule 1 (empty -> .)
    Minus           reduce using rule 1 (empty -> .)
    BitNot          reduce using rule 1 (empty -> .)
    Not             reduce using rule 1 (empty -> .)
    Integer         reduce using rule 1 (empty -> .)
    LParen          reduce using rule 1 (empty -> .)
    Semi            reduce using rule 1 (empty -> .)

    block                          shift and go to state 20
    empty                          shift and go to state 21

state 18

    (8) function_decl -> type Identifier LParen parameter_list RParen Semi .

    Int             reduce using rule 8 (function_decl -> type Identifier LParen parameter_list RParen Semi .)
    $end            reduce using rule 8 (function_decl -> type Identifier LParen parameter_list RParen Semi .)


state 19

    (9) parameter_list -> parameter_list Comma type_identifier_union .

    RParen          reduce using rule 9 (parameter_list -> parameter_list Comma type_identifier_union .)
    Comma           reduce using rule 9 (parameter_list -> parameter_list Comma type_identifier_union .)


state 20

    (7) function_def -> type Identifier LParen parameter_list RParen LBrace block . RBrace
    (14) block -> block . block_item
    (16) block_item -> . statement
    (17) block_item -> . declaration Semi
    (18) statement -> . statement_matched
    (19) statement -> . statement_unmatched
    (38) declaration -> . type Identifier
    (39) declaration -> . type Identifier Assign expression
    (20) statement_matched -> . If LParen expression RParen statement_matched Else statement_matched
    (23) statement_matched -> . While LParen expression RParen statement_matched
    (25) statement_matched -> . Do statement_matched While LParen expression RParen Semi
    (27) statement_matched -> . For LParen opt_expression Semi opt_expression Semi opt_expression RParen statement_matched
    (28) statement_matched -> . For LParen declaration Semi opt_expression Semi opt_expression RParen statement_matched
    (31) statement_matched -> . Return expression Semi
    (32) statement_matched -> . opt_expression Semi
    (33) statement_matched -> . LBrace block RBrace
    (34) statement_matched -> . Break Semi
    (35) statement_matched -> . Continue Semi
    (21) statement_unmatched -> . If LParen expression RParen statement_matched Else statement_unmatched
    (22) statement_unmatched -> . If LParen expression RParen statement
    (24) statement_unmatched -> . While LParen expression RParen statement_unmatched
    (26) statement_unmatched -> . Do statement_unmatched While LParen expression RParen Semi
    (29) statement_unmatched -> . For LParen opt_expression Semi opt_expression Semi opt_expression RParen statement_unmatched
    (30) statement_unmatched -> . For LParen declaration Semi opt_expression Semi opt_expression Semi opt_expression RParen statement_unmatched
    (4) type -> . Int
    (36) opt_expression -> . expression
    (37) opt_expression -> . empty
    (40) expression -> . assignment
    (1) empty -> .
    (41) assignment -> . conditional
    (61) assignment -> . Identifier Assign expression
    (42) conditional -> . logical_or
    (78) conditional -> . logical_or Question expression Colon conditional
    (43) logical_or -> . logical_and
    (62) logical_or -> . logical_or Or logical_and
    (44) logical_and -> . bit_or
    (63) logical_and -> . logical_and And bit_or
    (45) bit_or -> . xor
    (64) bit_or -> . bit_or BitOr xor
    (46) xor -> . bit_and
    (65) xor -> . xor Xor bit_and
    (47) bit_and -> . equality
    (66) bit_and -> . bit_and BitAnd equality
    (48) equality -> . relational
    (67) equality -> . equality NotEqual relational
    (68) equality -> . equality Equal relational
    (49) relational -> . additive
    (69) relational -> . relational Less additive
    (70) relational -> . relational Greater additive
    (71) relational -> . relational LessEqual additive
    (72) relational -> . relational GreaterEqual additive
    (50) additive -> . multiplicative
    (73) additive -> . additive Plus multiplicative
    (74) additive -> . additive Minus multiplicative
    (51) multiplicative -> . unary
    (75) multiplicative -> . multiplicative Mul unary
    (76) multiplicative -> . multiplicative Div unary
    (77) multiplicative -> . multiplicative Mod unary
    (52) unary -> . postfix
    (54) unary -> . Minus unary
    (55) unary -> . BitNot unary
    (56) unary -> . Not unary
    (53) postfix -> . primary
    (57) postfix -> . Identifier LParen expression_list RParen
    (79) primary -> . Integer
    (80) primary -> . Identifier
    (81) primary -> . LParen expression RParen

    RBrace          shift and go to state 26
    If              shift and go to state 33
    While           shift and go to state 34
    Do              shift and go to state 35
    For             shift and go to state 36
    Return          shift and go to state 38
    LBrace          shift and go to state 25
    Break           shift and go to state 39
    Continue        shift and go to state 40
    Int             shift and go to state 7
    Semi            reduce using rule 1 (empty -> .)
    Identifier      shift and go to state 23
    Minus           shift and go to state 53
    BitNot          shift and go to state 56
    Not             shift and go to state 57
    Integer         shift and go to state 59
    LParen          shift and go to state 24

    type                           shift and go to state 22
    block_item                     shift and go to state 27
    statement                      shift and go to state 28
    declaration                    shift and go to state 29
    statement_matched              shift and go to state 30
    statement_unmatched            shift and go to state 31
    expression                     shift and go to state 32
    opt_expression                 shift and go to state 37
    empty                          shift and go to state 41
    assignment                     shift and go to state 42
    conditional                    shift and go to state 43
    logical_or                     shift and go to state 44
    logical_and                    shift and go to state 45
    bit_or                         shift and go to state 46
    xor                            shift and go to state 47
    bit_and                        shift and go to state 48
    equality                       shift and go to state 49
    relational                     shift and go to state 50
    additive                       shift and go to state 51
    multiplicative                 shift and go to state 52
    unary                          shift and go to state 54
    postfix                        shift and go to state 55
    primary                        shift and go to state 58

state 21

    (15) block -> empty .

    RBrace          reduce using rule 15 (block -> empty .)
    If              reduce using rule 15 (block -> empty .)
    While           reduce using rule 15 (block -> empty .)
    Do              reduce using rule 15 (block -> empty .)
    For             reduce using rule 15 (block -> empty .)
    Return          reduce using rule 15 (block -> empty .)
    LBrace          reduce using rule 15 (block -> empty .)
    Break           reduce using rule 15 (block -> empty .)
    Continue        reduce using rule 15 (block -> empty .)
    Int             reduce using rule 15 (block -> empty .)
    Identifier      reduce using rule 15 (block -> empty .)
    Minus           reduce using rule 15 (block -> empty .)
    BitNot          reduce using rule 15 (block -> empty .)
    Not             reduce using rule 15 (block -> empty .)
    Integer         reduce using rule 15 (block -> empty .)
    LParen          reduce using rule 15 (block -> empty .)
    Semi            reduce using rule 15 (block -> empty .)


state 22

    (38) declaration -> type . Identifier
    (39) declaration -> type . Identifier Assign expression

    Identifier      shift and go to state 60


state 23

    (61) assignment -> Identifier . Assign expression
    (57) postfix -> Identifier . LParen expression_list RParen
    (80) primary -> Identifier .

    Assign          shift and go to state 61
    LParen          shift and go to state 62
    Mul             reduce using rule 80 (primary -> Identifier .)
    Div             reduce using rule 80 (primary -> Identifier .)
    Mod             reduce using rule 80 (primary -> Identifier .)
    Plus            reduce using rule 80 (primary -> Identifier .)
    Minus           reduce using rule 80 (primary -> Identifier .)
    Less            reduce using rule 80 (primary -> Identifier .)
    Greater         reduce using rule 80 (primary -> Identifier .)
    LessEqual       reduce using rule 80 (primary -> Identifier .)
    GreaterEqual    reduce using rule 80 (primary -> Identifier .)
    NotEqual        reduce using rule 80 (primary -> Identifier .)
    Equal           reduce using rule 80 (primary -> Identifier .)
    BitAnd          reduce using rule 80 (primary -> Identifier .)
    Xor             reduce using rule 80 (primary -> Identifier .)
    BitOr           reduce using rule 80 (primary -> Identifier .)
    And             reduce using rule 80 (primary -> Identifier .)
    Question        reduce using rule 80 (primary -> Identifier .)
    Or              reduce using rule 80 (primary -> Identifier .)
    Semi            reduce using rule 80 (primary -> Identifier .)
    RParen          reduce using rule 80 (primary -> Identifier .)
    Comma           reduce using rule 80 (primary -> Identifier .)
    Colon           reduce using rule 80 (primary -> Identifier .)


state 24

    (81) primary -> LParen . expression RParen
    (40) expression -> . assignment
    (41) assignment -> . conditional
    (61) assignment -> . Identifier Assign expression
    (42) conditional -> . logical_or
    (78) conditional -> . logical_or Question expression Colon conditional
    (43) logical_or -> . logical_and
    (62) logical_or -> . logical_or Or logical_and
    (44) logical_and -> . bit_or
    (63) logical_and -> . logical_and And bit_or
    (45) bit_or -> . xor
    (64) bit_or -> . bit_or BitOr xor
    (46) xor -> . bit_and
    (65) xor -> . xor Xor bit_and
    (47) bit_and -> . equality
    (66) bit_and -> . bit_and BitAnd equality
    (48) equality -> . relational
    (67) equality -> . equality NotEqual relational
    (68) equality -> . equality Equal relational
    (49) relational -> . additive
    (69) relational -> . relational Less additive
    (70) relational -> . relational Greater additive
    (71) relational -> . relational LessEqual additive
    (72) relational -> . relational GreaterEqual additive
    (50) additive -> . multiplicative
    (73) additive -> . additive Plus multiplicative
    (74) additive -> . additive Minus multiplicative
    (51) multiplicative -> . unary
    (75) multiplicative -> . multiplicative Mul unary
    (76) multiplicative -> . multiplicative Div unary
    (77) multiplicative -> . multiplicative Mod unary
    (52) unary -> . postfix
    (54) unary -> . Minus unary
    (55) unary -> . BitNot unary
    (56) unary -> . Not unary
    (53) postfix -> . primary
    (57) postfix -> . Identifier LParen expression_list RParen
    (79) primary -> . Integer
    (80) primary -> . Identifier
    (81) primary -> . LParen expression RParen

    Identifier      shift and go to state 23
    Minus           shift and go to state 53
    BitNot          shift and go to state 56
    Not             shift and go to state 57
    Integer         shift and go to state 59
    LParen          shift and go to state 24

    expression                     shift and go to state 63
    assignment                     shift and go to state 42
    conditional                    shift and go to state 43
    logical_or                     shift and go to state 44
    logical_and                    shift and go to state 45
    bit_or                         shift and go to state 46
    xor                            shift and go to state 47
    bit_and                        shift and go to state 48
    equality                       shift and go to state 49
    relational                     shift and go to state 50
    additive                       shift and go to state 51
    multiplicative                 shift and go to state 52
    unary                          shift and go to state 54
    postfix                        shift and go to state 55
    primary                        shift and go to state 58

state 25

    (33) statement_matched -> LBrace . block RBrace
    (14) block -> . block block_item
    (15) block -> . empty
    (1) empty -> .

    RBrace          reduce using rule 1 (empty -> .)
    If              reduce using rule 1 (empty -> .)
    While           reduce using rule 1 (empty -> .)
    Do              reduce using rule 1 (empty -> .)
    For             reduce using rule 1 (empty -> .)
    Return          reduce using rule 1 (empty -> .)
    LBrace          reduce using rule 1 (empty -> .)
    Break           reduce using rule 1 (empty -> .)
    Continue        reduce using rule 1 (empty -> .)
    Int             reduce using rule 1 (empty -> .)
    Identifier      reduce using rule 1 (empty -> .)
    Minus           reduce using rule 1 (empty -> .)
    BitNot          reduce using rule 1 (empty -> .)
    Not             reduce using rule 1 (empty -> .)
    Integer         reduce using rule 1 (empty -> .)
    LParen          reduce using rule 1 (empty -> .)
    Semi            reduce using rule 1 (empty -> .)

    block                          shift and go to state 64
    empty                          shift and go to state 21

state 26

    (7) function_def -> type Identifier LParen parameter_list RParen LBrace block RBrace .

    Int             reduce using rule 7 (function_def -> type Identifier LParen parameter_list RParen LBrace block RBrace .)
    $end            reduce using rule 7 (function_def -> type Identifier LParen parameter_list RParen LBrace block RBrace .)


state 27

    (14) block -> block block_item .

    RBrace          reduce using rule 14 (block -> block block_item .)
    If              reduce using rule 14 (block -> block block_item .)
    While           reduce using rule 14 (block -> block block_item .)
    Do              reduce using rule 14 (block -> block block_item .)
    For             reduce using rule 14 (block -> block block_item .)
    Return          reduce using rule 14 (block -> block block_item .)
    LBrace          reduce using rule 14 (block -> block block_item .)
    Break           reduce using rule 14 (block -> block block_item .)
    Continue        reduce using rule 14 (block -> block block_item .)
    Int             reduce using rule 14 (block -> block block_item .)
    Identifier      reduce using rule 14 (block -> block block_item .)
    Minus           reduce using rule 14 (block -> block block_item .)
    BitNot          reduce using rule 14 (block -> block block_item .)
    Not             reduce using rule 14 (block -> block block_item .)
    Integer         reduce using rule 14 (block -> block block_item .)
    LParen          reduce using rule 14 (block -> block block_item .)
    Semi            reduce using rule 14 (block -> block block_item .)


state 28

    (16) block_item -> statement .

    RBrace          reduce using rule 16 (block_item -> statement .)
    If              reduce using rule 16 (block_item -> statement .)
    While           reduce using rule 16 (block_item -> statement .)
    Do              reduce using rule 16 (block_item -> statement .)
    For             reduce using rule 16 (block_item -> statement .)
    Return          reduce using rule 16 (block_item -> statement .)
    LBrace          reduce using rule 16 (block_item -> statement .)
    Break           reduce using rule 16 (block_item -> statement .)
    Continue        reduce using rule 16 (block_item -> statement .)
    Int             reduce using rule 16 (block_item -> statement .)
    Identifier      reduce using rule 16 (block_item -> statement .)
    Minus           reduce using rule 16 (block_item -> statement .)
    BitNot          reduce using rule 16 (block_item -> statement .)
    Not             reduce using rule 16 (block_item -> statement .)
    Integer         reduce using rule 16 (block_item -> statement .)
    LParen          reduce using rule 16 (block_item -> statement .)
    Semi            reduce using rule 16 (block_item -> statement .)


state 29

    (17) block_item -> declaration . Semi

    Semi            shift and go to state 65


state 30

    (18) statement -> statement_matched .

    RBrace          reduce using rule 18 (statement -> statement_matched .)
    If              reduce using rule 18 (statement -> statement_matched .)
    While           reduce using rule 18 (statement -> statement_matched .)
    Do              reduce using rule 18 (statement -> statement_matched .)
    For             reduce using rule 18 (statement -> statement_matched .)
    Return          reduce using rule 18 (statement -> statement_matched .)
    LBrace          reduce using rule 18 (statement -> statement_matched .)
    Break           reduce using rule 18 (statement -> statement_matched .)
    Continue        reduce using rule 18 (statement -> statement_matched .)
    Int             reduce using rule 18 (statement -> statement_matched .)
    Identifier      reduce using rule 18 (statement -> statement_matched .)
    Minus           reduce using rule 18 (statement -> statement_matched .)
    BitNot          reduce using rule 18 (statement -> statement_matched .)
    Not             reduce using rule 18 (statement -> statement_matched .)
    Integer         reduce using rule 18 (statement -> statement_matched .)
    LParen          reduce using rule 18 (statement -> statement_matched .)
    Semi            reduce using rule 18 (statement -> statement_matched .)


state 31

    (19) statement -> statement_unmatched .

    RBrace          reduce using rule 19 (statement -> statement_unmatched .)
    If              reduce using rule 19 (statement -> statement_unmatched .)
    While           reduce using rule 19 (statement -> statement_unmatched .)
    Do              reduce using rule 19 (statement -> statement_unmatched .)
    For             reduce using rule 19 (statement -> statement_unmatched .)
    Return          reduce using rule 19 (statement -> statement_unmatched .)
    LBrace          reduce using rule 19 (statement -> statement_unmatched .)
    Break           reduce using rule 19 (statement -> statement_unmatched .)
    Continue        reduce using rule 19 (statement -> statement_unmatched .)
    Int             reduce using rule 19 (statement -> statement_unmatched .)
    Identifier      reduce using rule 19 (statement -> statement_unmatched .)
    Minus           reduce using rule 19 (statement -> statement_unmatched .)
    BitNot          reduce using rule 19 (statement -> statement_unmatched .)
    Not             reduce using rule 19 (statement -> statement_unmatched .)
    Integer         reduce using rule 19 (statement -> statement_unmatched .)
    LParen          reduce using rule 19 (statement -> statement_unmatched .)
    Semi            reduce using rule 19 (statement -> statement_unmatched .)


state 32

    (36) opt_expression -> expression .

    Semi            reduce using rule 36 (opt_expression -> expression .)
    RParen          reduce using rule 36 (opt_expression -> expression .)


state 33

    (20) statement_matched -> If . LParen expression RParen statement_matched Else statement_matched
    (21) statement_unmatched -> If . LParen expression RParen statement_matched Else statement_unmatched
    (22) statement_unmatched -> If . LParen expression RParen statement

    LParen          shift and go to state 66


state 34

    (23) statement_matched -> While . LParen expression RParen statement_matched
    (24) statement_unmatched -> While . LParen expression RParen statement_unmatched

    LParen          shift and go to state 67


state 35

    (25) statement_matched -> Do . statement_matched While LParen expression RParen Semi
    (26) statement_unmatched -> Do . statement_unmatched While LParen expression RParen Semi
    (20) statement_matched -> . If LParen expression RParen statement_matched Else statement_matched
    (23) statement_matched -> . While LParen expression RParen statement_matched
    (25) statement_matched -> . Do statement_matched While LParen expression RParen Semi
    (27) statement_matched -> . For LParen opt_expression Semi opt_expression Semi opt_expression RParen statement_matched
    (28) statement_matched -> . For LParen declaration Semi opt_expression Semi opt_expression RParen statement_matched
    (31) statement_matched -> . Return expression Semi
    (32) statement_matched -> . opt_expression Semi
    (33) statement_matched -> . LBrace block RBrace
    (34) statement_matched -> . Break Semi
    (35) statement_matched -> . Continue Semi
    (21) statement_unmatched -> . If LParen expression RParen statement_matched Else statement_unmatched
    (22) statement_unmatched -> . If LParen expression RParen statement
    (24) statement_unmatched -> . While LParen expression RParen statement_unmatched
    (26) statement_unmatched -> . Do statement_unmatched While LParen expression RParen Semi
    (29) statement_unmatched -> . For LParen opt_expression Semi opt_expression Semi opt_expression RParen statement_unmatched
    (30) statement_unmatched -> . For LParen declaration Semi opt_expression Semi opt_expression Semi opt_expression RParen statement_unmatched
    (36) opt_expression -> . expression
    (37) opt_expression -> . empty
    (40) expression -> . assignment
    (1) empty -> .
    (41) assignment -> . conditional
    (61) assignment -> . Identifier Assign expression
    (42) conditional -> . logical_or
    (78) conditional -> . logical_or Question expression Colon conditional
    (43) logical_or -> . logical_and
    (62) logical_or -> . logical_or Or logical_and
    (44) logical_and -> . bit_or
    (63) logical_and -> . logical_and And bit_or
    (45) bit_or -> . xor
    (64) bit_or -> . bit_or BitOr xor
    (46) xor -> . bit_and
    (65) xor -> . xor Xor bit_and
    (47) bit_and -> . equality
    (66) bit_and -> . bit_and BitAnd equality
    (48) equality -> . relational
    (67) equality -> . equality NotEqual relational
    (68) equality -> . equality Equal relational
    (49) relational -> . additive
    (69) relational -> . relational Less additive
    (70) relational -> . relational Greater additive
    (71) relational -> . relational LessEqual additive
    (72) relational -> . relational GreaterEqual additive
    (50) additive -> . multiplicative
    (73) additive -> . additive Plus multiplicative
    (74) additive -> . additive Minus multiplicative
    (51) multiplicative -> . unary
    (75) multiplicative -> . multiplicative Mul unary
    (76) multiplicative -> . multiplicative Div unary
    (77) multiplicative -> . multiplicative Mod unary
    (52) unary -> . postfix
    (54) unary -> . Minus unary
    (55) unary -> . BitNot unary
    (56) unary -> . Not unary
    (53) postfix -> . primary
    (57) postfix -> . Identifier LParen expression_list RParen
    (79) primary -> . Integer
    (80) primary -> . Identifier
    (81) primary -> . LParen expression RParen

    If              shift and go to state 33
    While           shift and go to state 34
    Do              shift and go to state 35
    For             shift and go to state 36
    Return          shift and go to state 38
    LBrace          shift and go to state 25
    Break           shift and go to state 39
    Continue        shift and go to state 40
    Semi            reduce using rule 1 (empty -> .)
    Identifier      shift and go to state 23
    Minus           shift and go to state 53
    BitNot          shift and go to state 56
    Not             shift and go to state 57
    Integer         shift and go to state 59
    LParen          shift and go to state 24

    statement_matched              shift and go to state 68
    expression                     shift and go to state 32
    statement_unmatched            shift and go to state 69
    opt_expression                 shift and go to state 37
    empty                          shift and go to state 41
    assignment                     shift and go to state 42
    conditional                    shift and go to state 43
    logical_or                     shift and go to state 44
    logical_and                    shift and go to state 45
    bit_or                         shift and go to state 46
    xor                            shift and go to state 47
    bit_and                        shift and go to state 48
    equality                       shift and go to state 49
    relational                     shift and go to state 50
    additive                       shift and go to state 51
    multiplicative                 shift and go to state 52
    unary                          shift and go to state 54
    postfix                        shift and go to state 55
    primary                        shift and go to state 58

state 36

    (27) statement_matched -> For . LParen opt_expression Semi opt_expression Semi opt_expression RParen statement_matched
    (28) statement_matched -> For . LParen declaration Semi opt_expression Semi opt_expression RParen statement_matched
    (29) statement_unmatched -> For . LParen opt_expression Semi opt_expression Semi opt_expression RParen statement_unmatched
    (30) statement_unmatched -> For . LParen declaration Semi opt_expression Semi opt_expression Semi opt_expression RParen statement_unmatched

    LParen          shift and go to state 70


state 37

    (32) statement_matched -> opt_expression . Semi

    Semi            shift and go to state 71


state 38

    (31) statement_matched -> Return . expression Semi
    (40) expression -> . assignment
    (41) assignment -> . conditional
    (61) assignment -> . Identifier Assign expression
    (42) conditional -> . logical_or
    (78) conditional -> . logical_or Question expression Colon conditional
    (43) logical_or -> . logical_and
    (62) logical_or -> . logical_or Or logical_and
    (44) logical_and -> . bit_or
    (63) logical_and -> . logical_and And bit_or
    (45) bit_or -> . xor
    (64) bit_or -> . bit_or BitOr xor
    (46) xor -> . bit_and
    (65) xor -> . xor Xor bit_and
    (47) bit_and -> . equality
    (66) bit_and -> . bit_and BitAnd equality
    (48) equality -> . relational
    (67) equality -> . equality NotEqual relational
    (68) equality -> . equality Equal relational
    (49) relational -> . additive
    (69) relational -> . relational Less additive
    (70) relational -> . relational Greater additive
    (71) relational -> . relational LessEqual additive
    (72) relational -> . relational GreaterEqual additive
    (50) additive -> . multiplicative
    (73) additive -> . additive Plus multiplicative
    (74) additive -> . additive Minus multiplicative
    (51) multiplicative -> . unary
    (75) multiplicative -> . multiplicative Mul unary
    (76) multiplicative -> . multiplicative Div unary
    (77) multiplicative -> . multiplicative Mod unary
    (52) unary -> . postfix
    (54) unary -> . Minus unary
    (55) unary -> . BitNot unary
    (56) unary -> . Not unary
    (53) postfix -> . primary
    (57) postfix -> . Identifier LParen expression_list RParen
    (79) primary -> . Integer
    (80) primary -> . Identifier
    (81) primary -> . LParen expression RParen

    Identifier      shift and go to state 23
    Minus           shift and go to state 53
    BitNot          shift and go to state 56
    Not             shift and go to state 57
    Integer         shift and go to state 59
    LParen          shift and go to state 24

    expression                     shift and go to state 72
    assignment                     shift and go to state 42
    conditional                    shift and go to state 43
    logical_or                     shift and go to state 44
    logical_and                    shift and go to state 45
    bit_or                         shift and go to state 46
    xor                            shift and go to state 47
    bit_and                        shift and go to state 48
    equality                       shift and go to state 49
    relational                     shift and go to state 50
    additive                       shift and go to state 51
    multiplicative                 shift and go to state 52
    unary                          shift and go to state 54
    postfix                        shift and go to state 55
    primary                        shift and go to state 58

state 39

    (34) statement_matched -> Break . Semi

    Semi            shift and go to state 73


state 40

    (35) statement_matched -> Continue . Semi

    Semi            shift and go to state 74


state 41

    (37) opt_expression -> empty .

    Semi            reduce using rule 37 (opt_expression -> empty .)
    RParen          reduce using rule 37 (opt_expression -> empty .)


state 42

    (40) expression -> assignment .

    Semi            reduce using rule 40 (expression -> assignment .)
    RParen          reduce using rule 40 (expression -> assignment .)
    Comma           reduce using rule 40 (expression -> assignment .)
    Colon           reduce using rule 40 (expression -> assignment .)


state 43

    (41) assignment -> conditional .

    Semi            reduce using rule 41 (assignment -> conditional .)
    RParen          reduce using rule 41 (assignment -> conditional .)
    Comma           reduce using rule 41 (assignment -> conditional .)
    Colon           reduce using rule 41 (assignment -> conditional .)


state 44

    (42) conditional -> logical_or .
    (78) conditional -> logical_or . Question expression Colon conditional
    (62) logical_or -> logical_or . Or logical_and

    Semi            reduce using rule 42 (conditional -> logical_or .)
    RParen          reduce using rule 42 (conditional -> logical_or .)
    Comma           reduce using rule 42 (conditional -> logical_or .)
    Colon           reduce using rule 42 (conditional -> logical_or .)
    Question        shift and go to state 75
    Or              shift and go to state 76


state 45

    (43) logical_or -> logical_and .
    (63) logical_and -> logical_and . And bit_or

    Question        reduce using rule 43 (logical_or -> logical_and .)
    Or              reduce using rule 43 (logical_or -> logical_and .)
    Semi            reduce using rule 43 (logical_or -> logical_and .)
    RParen          reduce using rule 43 (logical_or -> logical_and .)
    Comma           reduce using rule 43 (logical_or -> logical_and .)
    Colon           reduce using rule 43 (logical_or -> logical_and .)
    And             shift and go to state 77


state 46

    (44) logical_and -> bit_or .
    (64) bit_or -> bit_or . BitOr xor

    And             reduce using rule 44 (logical_and -> bit_or .)
    Question        reduce using rule 44 (logical_and -> bit_or .)
    Or              reduce using rule 44 (logical_and -> bit_or .)
    Semi            reduce using rule 44 (logical_and -> bit_or .)
    RParen          reduce using rule 44 (logical_and -> bit_or .)
    Comma           reduce using rule 44 (logical_and -> bit_or .)
    Colon           reduce using rule 44 (logical_and -> bit_or .)
    BitOr           shift and go to state 78


state 47

    (45) bit_or -> xor .
    (65) xor -> xor . Xor bit_and

    BitOr           reduce using rule 45 (bit_or -> xor .)
    And             reduce using rule 45 (bit_or -> xor .)
    Question        reduce using rule 45 (bit_or -> xor .)
    Or              reduce using rule 45 (bit_or -> xor .)
    Semi            reduce using rule 45 (bit_or -> xor .)
    RParen          reduce using rule 45 (bit_or -> xor .)
    Comma           reduce using rule 45 (bit_or -> xor .)
    Colon           reduce using rule 45 (bit_or -> xor .)
    Xor             shift and go to state 79


state 48

    (46) xor -> bit_and .
    (66) bit_and -> bit_and . BitAnd equality

    Xor             reduce using rule 46 (xor -> bit_and .)
    BitOr           reduce using rule 46 (xor -> bit_and .)
    And             reduce using rule 46 (xor -> bit_and .)
    Question        reduce using rule 46 (xor -> bit_and .)
    Or              reduce using rule 46 (xor -> bit_and .)
    Semi            reduce using rule 46 (xor -> bit_and .)
    RParen          reduce using rule 46 (xor -> bit_and .)
    Comma           reduce using rule 46 (xor -> bit_and .)
    Colon           reduce using rule 46 (xor -> bit_and .)
    BitAnd          shift and go to state 80


state 49

    (47) bit_and -> equality .
    (67) equality -> equality . NotEqual relational
    (68) equality -> equality . Equal relational

    BitAnd          reduce using rule 47 (bit_and -> equality .)
    Xor             reduce using rule 47 (bit_and -> equality .)
    BitOr           reduce using rule 47 (bit_and -> equality .)
    And             reduce using rule 47 (bit_and -> equality .)
    Question        reduce using rule 47 (bit_and -> equality .)
    Or              reduce using rule 47 (bit_and -> equality .)
    Semi            reduce using rule 47 (bit_and -> equality .)
    RParen          reduce using rule 47 (bit_and -> equality .)
    Comma           reduce using rule 47 (bit_and -> equality .)
    Colon           reduce using rule 47 (bit_and -> equality .)
    NotEqual        shift and go to state 81
    Equal           shift and go to state 82


state 50

    (48) equality -> relational .
    (69) relational -> relational . Less additive
    (70) relational -> relational . Greater additive
    (71) relational -> relational . LessEqual additive
    (72) relational -> relational . GreaterEqual additive

    NotEqual        reduce using rule 48 (equality -> relational .)
    Equal           reduce using rule 48 (equality -> relational .)
    BitAnd          reduce using rule 48 (equality -> relational .)
    Xor             reduce using rule 48 (equality -> relational .)
    BitOr           reduce using rule 48 (equality -> relational .)
    And             reduce using rule 48 (equality -> relational .)
    Question        reduce using rule 48 (equality -> relational .)
    Or              reduce using rule 48 (equality -> relational .)
    Semi            reduce using rule 48 (equality -> relational .)
    RParen          reduce using rule 48 (equality -> relational .)
    Comma           reduce using rule 48 (equality -> relational .)
    Colon           reduce using rule 48 (equality -> relational .)
    Less            shift and go to state 83
    Greater         shift and go to state 84
    LessEqual       shift and go to state 85
    GreaterEqual    shift and go to state 86


state 51

    (49) relational -> additive .
    (73) additive -> additive . Plus multiplicative
    (74) additive -> additive . Minus multiplicative

    Less            reduce using rule 49 (relational -> additive .)
    Greater         reduce using rule 49 (relational -> additive .)
    LessEqual       reduce using rule 49 (relational -> additive .)
    GreaterEqual    reduce using rule 49 (relational -> additive .)
    NotEqual        reduce using rule 49 (relational -> additive .)
    Equal           reduce using rule 49 (relational -> additive .)
    BitAnd          reduce using rule 49 (relational -> additive .)
    Xor             reduce using rule 49 (relational -> additive .)
    BitOr           reduce using rule 49 (relational -> additive .)
    And             reduce using rule 49 (relational -> additive .)
    Question        reduce using rule 49 (relational -> additive .)
    Or              reduce using rule 49 (relational -> additive .)
    Semi            reduce using rule 49 (relational -> additive .)
    RParen          reduce using rule 49 (relational -> additive .)
    Comma           reduce using rule 49 (relational -> additive .)
    Colon           reduce using rule 49 (relational -> additive .)
    Plus            shift and go to state 87
    Minus           shift and go to state 88


state 52

    (50) additive -> multiplicative .
    (75) multiplicative -> multiplicative . Mul unary
    (76) multiplicative -> multiplicative . Div unary
    (77) multiplicative -> multiplicative . Mod unary

    Plus            reduce using rule 50 (additive -> multiplicative .)
    Minus           reduce using rule 50 (additive -> multiplicative .)
    Less            reduce using rule 50 (additive -> multiplicative .)
    Greater         reduce using rule 50 (additive -> multiplicative .)
    LessEqual       reduce using rule 50 (additive -> multiplicative .)
    GreaterEqual    reduce using rule 50 (additive -> multiplicative .)
    NotEqual        reduce using rule 50 (additive -> multiplicative .)
    Equal           reduce using rule 50 (additive -> multiplicative .)
    BitAnd          reduce using rule 50 (additive -> multiplicative .)
    Xor             reduce using rule 50 (additive -> multiplicative .)
    BitOr           reduce using rule 50 (additive -> multiplicative .)
    And             reduce using rule 50 (additive -> multiplicative .)
    Question        reduce using rule 50 (additive -> multiplicative .)
    Or              reduce using rule 50 (additive -> multiplicative .)
    Semi            reduce using rule 50 (additive -> multiplicative .)
    RParen          reduce using rule 50 (additive -> multiplicative .)
    Comma           reduce using rule 50 (additive -> multiplicative .)
    Colon           reduce using rule 50 (additive -> multiplicative .)
    Mul             shift and go to state 89
    Div             shift and go to state 90
    Mod             shift and go to state 91


state 53

    (54) unary -> Minus . unary
    (52) unary -> . postfix
    (54) unary -> . Minus unary
    (55) unary -> . BitNot unary
    (56) unary -> . Not unary
    (53) postfix -> . primary
    (57) postfix -> . Identifier LParen expression_list RParen
    (79) primary -> . Integer
    (80) primary -> . Identifier
    (81) primary -> . LParen expression RParen

    Minus           shift and go to state 53
    BitNot          shift and go to state 56
    Not             shift and go to state 57
    Identifier      shift and go to state 93
    Integer         shift and go to state 59
    LParen          shift and go to state 24

    unary                          shift and go to state 92
    postfix                        shift and go to state 55
    primary                        shift and go to state 58

state 54

    (51) multiplicative -> unary .

    Mul             reduce using rule 51 (multiplicative -> unary .)
    Div             reduce using rule 51 (multiplicative -> unary .)
    Mod             reduce using rule 51 (multiplicative -> unary .)
    Plus            reduce using rule 51 (multiplicative -> unary .)
    Minus           reduce using rule 51 (multiplicative -> unary .)
    Less            reduce using rule 51 (multiplicative -> unary .)
    Greater         reduce using rule 51 (multiplicative -> unary .)
    LessEqual       reduce using rule 51 (multiplicative -> unary .)
    GreaterEqual    reduce using rule 51 (multiplicative -> unary .)
    NotEqual        reduce using rule 51 (multiplicative -> unary .)
    Equal           reduce using rule 51 (multiplicative -> unary .)
    BitAnd          reduce using rule 51 (multiplicative -> unary .)
    Xor             reduce using rule 51 (multiplicative -> unary .)
    BitOr           reduce using rule 51 (multiplicative -> unary .)
    And             reduce using rule 51 (multiplicative -> unary .)
    Question        reduce using rule 51 (multiplicative -> unary .)
    Or              reduce using rule 51 (multiplicative -> unary .)
    Semi            reduce using rule 51 (multiplicative -> unary .)
    RParen          reduce using rule 51 (multiplicative -> unary .)
    Comma           reduce using rule 51 (multiplicative -> unary .)
    Colon           reduce using rule 51 (multiplicative -> unary .)


state 55

    (52) unary -> postfix .

    Mul             reduce using rule 52 (unary -> postfix .)
    Div             reduce using rule 52 (unary -> postfix .)
    Mod             reduce using rule 52 (unary -> postfix .)
    Plus            reduce using rule 52 (unary -> postfix .)
    Minus           reduce using rule 52 (unary -> postfix .)
    Less            reduce using rule 52 (unary -> postfix .)
    Greater         reduce using rule 52 (unary -> postfix .)
    LessEqual       reduce using rule 52 (unary -> postfix .)
    GreaterEqual    reduce using rule 52 (unary -> postfix .)
    NotEqual        reduce using rule 52 (unary -> postfix .)
    Equal           reduce using rule 52 (unary -> postfix .)
    BitAnd          reduce using rule 52 (unary -> postfix .)
    Xor             reduce using rule 52 (unary -> postfix .)
    BitOr           reduce using rule 52 (unary -> postfix .)
    And             reduce using rule 52 (unary -> postfix .)
    Question        reduce using rule 52 (unary -> postfix .)
    Or              reduce using rule 52 (unary -> postfix .)
    Semi            reduce using rule 52 (unary -> postfix .)
    RParen          reduce using rule 52 (unary -> postfix .)
    Comma           reduce using rule 52 (unary -> postfix .)
    Colon           reduce using rule 52 (unary -> postfix .)


state 56

    (55) unary -> BitNot . unary
    (52) unary -> . postfix
    (54) unary -> . Minus unary
    (55) unary -> . BitNot unary
    (56) unary -> . Not unary
    (53) postfix -> . primary
    (57) postfix -> . Identifier LParen expression_list RParen
    (79) primary -> . Integer
    (80) primary -> . Identifier
    (81) primary -> . LParen expression RParen

    Minus           shift and go to state 53
    BitNot          shift and go to state 56
    Not             shift and go to state 57
    Identifier      shift and go to state 93
    Integer         shift and go to state 59
    LParen          shift and go to state 24

    unary                          shift and go to state 94
    postfix                        shift and go to state 55
    primary                        shift and go to state 58

state 57

    (56) unary -> Not . unary
    (52) unary -> . postfix
    (54) unary -> . Minus unary
    (55) unary -> . BitNot unary
    (56) unary -> . Not unary
    (53) postfix -> . primary
    (57) postfix -> . Identifier LParen expression_list RParen
    (79) primary -> . Integer
    (80) primary -> . Identifier
    (81) primary -> . LParen expression RParen

    Minus           shift and go to state 53
    BitNot          shift and go to state 56
    Not             shift and go to state 57
    Identifier      shift and go to state 93
    Integer         shift and go to state 59
    LParen          shift and go to state 24

    unary                          shift and go to state 95
    postfix                        shift and go to state 55
    primary                        shift and go to state 58

state 58

    (53) postfix -> primary .

    Mul             reduce using rule 53 (postfix -> primary .)
    Div             reduce using rule 53 (postfix -> primary .)
    Mod             reduce using rule 53 (postfix -> primary .)
    Plus            reduce using rule 53 (postfix -> primary .)
    Minus           reduce using rule 53 (postfix -> primary .)
    Less            reduce using rule 53 (postfix -> primary .)
    Greater         reduce using rule 53 (postfix -> primary .)
    LessEqual       reduce using rule 53 (postfix -> primary .)
    GreaterEqual    reduce using rule 53 (postfix -> primary .)
    NotEqual        reduce using rule 53 (postfix -> primary .)
    Equal           reduce using rule 53 (postfix -> primary .)
    BitAnd          reduce using rule 53 (postfix -> primary .)
    Xor             reduce using rule 53 (postfix -> primary .)
    BitOr           reduce using rule 53 (postfix -> primary .)
    And             reduce using rule 53 (postfix -> primary .)
    Question        reduce using rule 53 (postfix -> primary .)
    Or              reduce using rule 53 (postfix -> primary .)
    Semi            reduce using rule 53 (postfix -> primary .)
    RParen          reduce using rule 53 (postfix -> primary .)
    Comma           reduce using rule 53 (postfix -> primary .)
    Colon           reduce using rule 53 (postfix -> primary .)


state 59

    (79) primary -> Integer .

    Mul             reduce using rule 79 (primary -> Integer .)
    Div             reduce using rule 79 (primary -> Integer .)
    Mod             reduce using rule 79 (primary -> Integer .)
    Plus            reduce using rule 79 (primary -> Integer .)
    Minus           reduce using rule 79 (primary -> Integer .)
    Less            reduce using rule 79 (primary -> Integer .)
    Greater         reduce using rule 79 (primary -> Integer .)
    LessEqual       reduce using rule 79 (primary -> Integer .)
    GreaterEqual    reduce using rule 79 (primary -> Integer .)
    NotEqual        reduce using rule 79 (primary -> Integer .)
    Equal           reduce using rule 79 (primary -> Integer .)
    BitAnd          reduce using rule 79 (primary -> Integer .)
    Xor             reduce using rule 79 (primary -> Integer .)
    BitOr           reduce using rule 79 (primary -> Integer .)
    And             reduce using rule 79 (primary -> Integer .)
    Question        reduce using rule 79 (primary -> Integer .)
    Or              reduce using rule 79 (primary -> Integer .)
    Semi            reduce using rule 79 (primary -> Integer .)
    RParen          reduce using rule 79 (primary -> Integer .)
    Comma           reduce using rule 79 (primary -> Integer .)
    Colon           reduce using rule 79 (primary -> Integer .)


state 60

    (38) declaration -> type Identifier .
    (39) declaration -> type Identifier . Assign expression

    Semi            reduce using rule 38 (declaration -> type Identifier .)
    Assign          shift and go to state 96


state 61

    (61) assignment -> Identifier Assign . expression
    (40) expression -> . assignment
    (41) assignment -> . conditional
    (61) assignment -> . Identifier Assign expression
    (42) conditional -> . logical_or
    (78) conditional -> . logical_or Question expression Colon conditional
    (43) logical_or -> . logical_and
    (62) logical_or -> . logical_or Or logical_and
    (44) logical_and -> . bit_or
    (63) logical_and -> . logical_and And bit_or
    (45) bit_or -> . xor
    (64) bit_or -> . bit_or BitOr xor
    (46) xor -> . bit_and
    (65) xor -> . xor Xor bit_and
    (47) bit_and -> . equality
    (66) bit_and -> . bit_and BitAnd equality
    (48) equality -> . relational
    (67) equality -> . equality NotEqual relational
    (68) equality -> . equality Equal relational
    (49) relational -> . additive
    (69) relational -> . relational Less additive
    (70) relational -> . relational Greater additive
    (71) relational -> . relational LessEqual additive
    (72) relational -> . relational GreaterEqual additive
    (50) additive -> . multiplicative
    (73) additive -> . additive Plus multiplicative
    (74) additive -> . additive Minus multiplicative
    (51) multiplicative -> . unary
    (75) multiplicative -> . multiplicative Mul unary
    (76) multiplicative -> . multiplicative Div unary
    (77) multiplicative -> . multiplicative Mod unary
    (52) unary -> . postfix
    (54) unary -> . Minus unary
    (55) unary -> . BitNot unary
    (56) unary -> . Not unary
    (53) postfix -> . primary
    (57) postfix -> . Identifier LParen expression_list RParen
    (79) primary -> . Integer
    (80) primary -> . Identifier
    (81) primary -> . LParen expression RParen

    Identifier      shift and go to state 23
    Minus           shift and go to state 53
    BitNot          shift and go to state 56
    Not             shift and go to state 57
    Integer         shift and go to state 59
    LParen          shift and go to state 24

    expression                     shift and go to state 97
    assignment                     shift and go to state 42
    conditional                    shift and go to state 43
    logical_or                     shift and go to state 44
    logical_and                    shift and go to state 45
    bit_or                         shift and go to state 46
    xor                            shift and go to state 47
    bit_and                        shift and go to state 48
    equality                       shift and go to state 49
    relational                     shift and go to state 50
    additive                       shift and go to state 51
    multiplicative                 shift and go to state 52
    unary                          shift and go to state 54
    postfix                        shift and go to state 55
    primary                        shift and go to state 58

state 62

    (57) postfix -> Identifier LParen . expression_list RParen
    (58) expression_list -> . expression_list Comma expression
    (59) expression_list -> . expression
    (60) expression_list -> . empty
    (40) expression -> . assignment
    (1) empty -> .
    (41) assignment -> . conditional
    (61) assignment -> . Identifier Assign expression
    (42) conditional -> . logical_or
    (78) conditional -> . logical_or Question expression Colon conditional
    (43) logical_or -> . logical_and
    (62) logical_or -> . logical_or Or logical_and
    (44) logical_and -> . bit_or
    (63) logical_and -> . logical_and And bit_or
    (45) bit_or -> . xor
    (64) bit_or -> . bit_or BitOr xor
    (46) xor -> . bit_and
    (65) xor -> . xor Xor bit_and
    (47) bit_and -> . equality
    (66) bit_and -> . bit_and BitAnd equality
    (48) equality -> . relational
    (67) equality -> . equality NotEqual relational
    (68) equality -> . equality Equal relational
    (49) relational -> . additive
    (69) relational -> . relational Less additive
    (70) relational -> . relational Greater additive
    (71) relational -> . relational LessEqual additive
    (72) relational -> . relational GreaterEqual additive
    (50) additive -> . multiplicative
    (73) additive -> . additive Plus multiplicative
    (74) additive -> . additive Minus multiplicative
    (51) multiplicative -> . unary
    (75) multiplicative -> . multiplicative Mul unary
    (76) multiplicative -> . multiplicative Div unary
    (77) multiplicative -> . multiplicative Mod unary
    (52) unary -> . postfix
    (54) unary -> . Minus unary
    (55) unary -> . BitNot unary
    (56) unary -> . Not unary
    (53) postfix -> . primary
    (57) postfix -> . Identifier LParen expression_list RParen
    (79) primary -> . Integer
    (80) primary -> . Identifier
    (81) primary -> . LParen expression RParen

    RParen          reduce using rule 1 (empty -> .)
    Comma           reduce using rule 1 (empty -> .)
    Identifier      shift and go to state 23
    Minus           shift and go to state 53
    BitNot          shift and go to state 56
    Not             shift and go to state 57
    Integer         shift and go to state 59
    LParen          shift and go to state 24

    expression_list                shift and go to state 98
    expression                     shift and go to state 99
    empty                          shift and go to state 100
    assignment                     shift and go to state 42
    conditional                    shift and go to state 43
    logical_or                     shift and go to state 44
    logical_and                    shift and go to state 45
    bit_or                         shift and go to state 46
    xor                            shift and go to state 47
    bit_and                        shift and go to state 48
    equality                       shift and go to state 49
    relational                     shift and go to state 50
    additive                       shift and go to state 51
    multiplicative                 shift and go to state 52
    unary                          shift and go to state 54
    postfix                        shift and go to state 55
    primary                        shift and go to state 58

state 63

    (81) primary -> LParen expression . RParen

    RParen          shift and go to state 101


state 64

    (33) statement_matched -> LBrace block . RBrace
    (14) block -> block . block_item
    (16) block_item -> . statement
    (17) block_item -> . declaration Semi
    (18) statement -> . statement_matched
    (19) statement -> . statement_unmatched
    (38) declaration -> . type Identifier
    (39) declaration -> . type Identifier Assign expression
    (20) statement_matched -> . If LParen expression RParen statement_matched Else statement_matched
    (23) statement_matched -> . While LParen expression RParen statement_matched
    (25) statement_matched -> . Do statement_matched While LParen expression RParen Semi
    (27) statement_matched -> . For LParen opt_expression Semi opt_expression Semi opt_expression RParen statement_matched
    (28) statement_matched -> . For LParen declaration Semi opt_expression Semi opt_expression RParen statement_matched
    (31) statement_matched -> . Return expression Semi
    (32) statement_matched -> . opt_expression Semi
    (33) statement_matched -> . LBrace block RBrace
    (34) statement_matched -> . Break Semi
    (35) statement_matched -> . Continue Semi
    (21) statement_unmatched -> . If LParen expression RParen statement_matched Else statement_unmatched
    (22) statement_unmatched -> . If LParen expression RParen statement
    (24) statement_unmatched -> . While LParen expression RParen statement_unmatched
    (26) statement_unmatched -> . Do statement_unmatched While LParen expression RParen Semi
    (29) statement_unmatched -> . For LParen opt_expression Semi opt_expression Semi opt_expression RParen statement_unmatched
    (30) statement_unmatched -> . For LParen declaration Semi opt_expression Semi opt_expression Semi opt_expression RParen statement_unmatched
    (4) type -> . Int
    (36) opt_expression -> . expression
    (37) opt_expression -> . empty
    (40) expression -> . assignment
    (1) empty -> .
    (41) assignment -> . conditional
    (61) assignment -> . Identifier Assign expression
    (42) conditional -> . logical_or
    (78) conditional -> . logical_or Question expression Colon conditional
    (43) logical_or -> . logical_and
    (62) logical_or -> . logical_or Or logical_and
    (44) logical_and -> . bit_or
    (63) logical_and -> . logical_and And bit_or
    (45) bit_or -> . xor
    (64) bit_or -> . bit_or BitOr xor
    (46) xor -> . bit_and
    (65) xor -> . xor Xor bit_and
    (47) bit_and -> . equality
    (66) bit_and -> . bit_and BitAnd equality
    (48) equality -> . relational
    (67) equality -> . equality NotEqual relational
    (68) equality -> . equality Equal relational
    (49) relational -> . additive
    (69) relational -> . relational Less additive
    (70) relational -> . relational Greater additive
    (71) relational -> . relational LessEqual additive
    (72) relational -> . relational GreaterEqual additive
    (50) additive -> . multiplicative
    (73) additive -> . additive Plus multiplicative
    (74) additive -> . additive Minus multiplicative
    (51) multiplicative -> . unary
    (75) multiplicative -> . multiplicative Mul unary
    (76) multiplicative -> . multiplicative Div unary
    (77) multiplicative -> . multiplicative Mod unary
    (52) unary -> . postfix
    (54) unary -> . Minus unary
    (55) unary -> . BitNot unary
    (56) unary -> . Not unary
    (53) postfix -> . primary
    (57) postfix -> . Identifier LParen expression_list RParen
    (79) primary -> . Integer
    (80) primary -> . Identifier
    (81) primary -> . LParen expression RParen

    RBrace          shift and go to state 102
    If              shift and go to state 33
    While           shift and go to state 34
    Do              shift and go to state 35
    For             shift and go to state 36
    Return          shift and go to state 38
    LBrace          shift and go to state 25
    Break           shift and go to state 39
    Continue        shift and go to state 40
    Int             shift and go to state 7
    Semi            reduce using rule 1 (empty -> .)
    Identifier      shift and go to state 23
    Minus           shift and go to state 53
    BitNot          shift and go to state 56
    Not             shift and go to state 57
    Integer         shift and go to state 59
    LParen          shift and go to state 24

    block_item                     shift and go to state 27
    statement                      shift and go to state 28
    declaration                    shift and go to state 29
    statement_matched              shift and go to state 30
    statement_unmatched            shift and go to state 31
    type                           shift and go to state 22
    expression                     shift and go to state 32
    opt_expression                 shift and go to state 37
    empty                          shift and go to state 41
    assignment                     shift and go to state 42
    conditional                    shift and go to state 43
    logical_or                     shift and go to state 44
    logical_and                    shift and go to state 45
    bit_or                         shift and go to state 46
    xor                            shift and go to state 47
    bit_and                        shift and go to state 48
    equality                       shift and go to state 49
    relational                     shift and go to state 50
    additive                       shift and go to state 51
    multiplicative                 shift and go to state 52
    unary                          shift and go to state 54
    postfix                        shift and go to state 55
    primary                        shift and go to state 58

state 65

    (17) block_item -> declaration Semi .

    RBrace          reduce using rule 17 (block_item -> declaration Semi .)
    If              reduce using rule 17 (block_item -> declaration Semi .)
    While           reduce using rule 17 (block_item -> declaration Semi .)
    Do              reduce using rule 17 (block_item -> declaration Semi .)
    For             reduce using rule 17 (block_item -> declaration Semi .)
    Return          reduce using rule 17 (block_item -> declaration Semi .)
    LBrace          reduce using rule 17 (block_item -> declaration Semi .)
    Break           reduce using rule 17 (block_item -> declaration Semi .)
    Continue        reduce using rule 17 (block_item -> declaration Semi .)
    Int             reduce using rule 17 (block_item -> declaration Semi .)
    Identifier      reduce using rule 17 (block_item -> declaration Semi .)
    Minus           reduce using rule 17 (block_item -> declaration Semi .)
    BitNot          reduce using rule 17 (block_item -> declaration Semi .)
    Not             reduce using rule 17 (block_item -> declaration Semi .)
    Integer         reduce using rule 17 (block_item -> declaration Semi .)
    LParen          reduce using rule 17 (block_item -> declaration Semi .)
    Semi            reduce using rule 17 (block_item -> declaration Semi .)


state 66

    (20) statement_matched -> If LParen . expression RParen statement_matched Else statement_matched
    (21) statement_unmatched -> If LParen . expression RParen statement_matched Else statement_unmatched
    (22) statement_unmatched -> If LParen . expression RParen statement
    (40) expression -> . assignment
    (41) assignment -> . conditional
    (61) assignment -> . Identifier Assign expression
    (42) conditional -> . logical_or
    (78) conditional -> . logical_or Question expression Colon conditional
    (43) logical_or -> . logical_and
    (62) logical_or -> . logical_or Or logical_and
    (44) logical_and -> . bit_or
    (63) logical_and -> . logical_and And bit_or
    (45) bit_or -> . xor
    (64) bit_or -> . bit_or BitOr xor
    (46) xor -> . bit_and
    (65) xor -> . xor Xor bit_and
    (47) bit_and -> . equality
    (66) bit_and -> . bit_and BitAnd equality
    (48) equality -> . relational
    (67) equality -> . equality NotEqual relational
    (68) equality -> . equality Equal relational
    (49) relational -> . additive
    (69) relational -> . relational Less additive
    (70) relational -> . relational Greater additive
    (71) relational -> . relational LessEqual additive
    (72) relational -> . relational GreaterEqual additive
    (50) additive -> . multiplicative
    (73) additive -> . additive Plus multiplicative
    (74) additive -> . additive Minus multiplicative
    (51) multiplicative -> . unary
    (75) multiplicative -> . multiplicative Mul unary
    (76) multiplicative -> . multiplicative Div unary
    (77) multiplicative -> . multiplicative Mod unary
    (52) unary -> . postfix
    (54) unary -> . Minus unary
    (55) unary -> . BitNot unary
    (56) unary -> . Not unary
    (53) postfix -> . primary
    (57) postfix -> . Identifier LParen expression_list RParen
    (79) primary -> . Integer
    (80) primary -> . Identifier
    (81) primary -> . LParen expression RParen

    Identifier      shift and go to state 23
    Minus           shift and go to state 53
    BitNot          shift and go to state 56
    Not             shift and go to state 57
    Integer         shift and go to state 59
    LParen          shift and go to state 24

    expression                     shift and go to state 103
    assignment                     shift and go to state 42
    conditional                    shift and go to state 43
    logical_or                     shift and go to state 44
    logical_and                    shift and go to state 45
    bit_or                         shift and go to state 46
    xor                            shift and go to state 47
    bit_and                        shift and go to state 48
    equality                       shift and go to state 49
    relational                     shift and go to state 50
    additive                       shift and go to state 51
    multiplicative                 shift and go to state 52
    unary                          shift and go to state 54
    postfix                        shift and go to state 55
    primary                        shift and go to state 58

state 67

    (23) statement_matched -> While LParen . expression RParen statement_matched
    (24) statement_unmatched -> While LParen . expression RParen statement_unmatched
    (40) expression -> . assignment
    (41) assignment -> . conditional
    (61) assignment -> . Identifier Assign expression
    (42) conditional -> . logical_or
    (78) conditional -> . logical_or Question expression Colon conditional
    (43) logical_or -> . logical_and
    (62) logical_or -> . logical_or Or logical_and
    (44) logical_and -> . bit_or
    (63) logical_and -> . logical_and And bit_or
    (45) bit_or -> . xor
    (64) bit_or -> . bit_or BitOr xor
    (46) xor -> . bit_and
    (65) xor -> . xor Xor bit_and
    (47) bit_and -> . equality
    (66) bit_and -> . bit_and BitAnd equality
    (48) equality -> . relational
    (67) equality -> . equality NotEqual relational
    (68) equality -> . equality Equal relational
    (49) relational -> . additive
    (69) relational -> . relational Less additive
    (70) relational -> . relational Greater additive
    (71) relational -> . relational LessEqual additive
    (72) relational -> . relational GreaterEqual additive
    (50) additive -> . multiplicative
    (73) additive -> . additive Plus multiplicative
    (74) additive -> . additive Minus multiplicative
    (51) multiplicative -> . unary
    (75) multiplicative -> . multiplicative Mul unary
    (76) multiplicative -> . multiplicative Div unary
    (77) multiplicative -> . multiplicative Mod unary
    (52) unary -> . postfix
    (54) unary -> . Minus unary
    (55) unary -> . BitNot unary
    (56) unary -> . Not unary
    (53) postfix -> . primary
    (57) postfix -> . Identifier LParen expression_list RParen
    (79) primary -> . Integer
    (80) primary -> . Identifier
    (81) primary -> . LParen expression RParen

    Identifier      shift and go to state 23
    Minus           shift and go to state 53
    BitNot          shift and go to state 56
    Not             shift and go to state 57
    Integer         shift and go to state 59
    LParen          shift and go to state 24

    expression                     shift and go to state 104
    assignment                     shift and go to state 42
    conditional                    shift and go to state 43
    logical_or                     shift and go to state 44
    logical_and                    shift and go to state 45
    bit_or                         shift and go to state 46
    xor                            shift and go to state 47
    bit_and                        shift and go to state 48
    equality                       shift and go to state 49
    relational                     shift and go to state 50
    additive                       shift and go to state 51
    multiplicative                 shift and go to state 52
    unary                          shift and go to state 54
    postfix                        shift and go to state 55
    primary                        shift and go to state 58

state 68

    (25) statement_matched -> Do statement_matched . While LParen expression RParen Semi

    While           shift and go to state 105


state 69

    (26) statement_unmatched -> Do statement_unmatched . While LParen expression RParen Semi

    While           shift and go to state 106


state 70

    (27) statement_matched -> For LParen . opt_expression Semi opt_expression Semi opt_expression RParen statement_matched
    (28) statement_matched -> For LParen . declaration Semi opt_expression Semi opt_expression RParen statement_matched
    (29) statement_unmatched -> For LParen . opt_expression Semi opt_expression Semi opt_expression RParen statement_unmatched
    (30) statement_unmatched -> For LParen . declaration Semi opt_expression Semi opt_expression Semi opt_expression RParen statement_unmatched
    (36) opt_expression -> . expression
    (37) opt_expression -> . empty
    (38) declaration -> . type Identifier
    (39) declaration -> . type Identifier Assign expression
    (40) expression -> . assignment
    (1) empty -> .
    (4) type -> . Int
    (41) assignment -> . conditional
    (61) assignment -> . Identifier Assign expression
    (42) conditional -> . logical_or
    (78) conditional -> . logical_or Question expression Colon conditional
    (43) logical_or -> . logical_and
    (62) logical_or -> . logical_or Or logical_and
    (44) logical_and -> . bit_or
    (63) logical_and -> . logical_and And bit_or
    (45) bit_or -> . xor
    (64) bit_or -> . bit_or BitOr xor
    (46) xor -> . bit_and
    (65) xor -> . xor Xor bit_and
    (47) bit_and -> . equality
    (66) bit_and -> . bit_and BitAnd equality
    (48) equality -> . relational
    (67) equality -> . equality NotEqual relational
    (68) equality -> . equality Equal relational
    (49) relational -> . additive
    (69) relational -> . relational Less additive
    (70) relational -> . relational Greater additive
    (71) relational -> . relational LessEqual additive
    (72) relational -> . relational GreaterEqual additive
    (50) additive -> . multiplicative
    (73) additive -> . additive Plus multiplicative
    (74) additive -> . additive Minus multiplicative
    (51) multiplicative -> . unary
    (75) multiplicative -> . multiplicative Mul unary
    (76) multiplicative -> . multiplicative Div unary
    (77) multiplicative -> . multiplicative Mod unary
    (52) unary -> . postfix
    (54) unary -> . Minus unary
    (55) unary -> . BitNot unary
    (56) unary -> . Not unary
    (53) postfix -> . primary
    (57) postfix -> . Identifier LParen expression_list RParen
    (79) primary -> . Integer
    (80) primary -> . Identifier
    (81) primary -> . LParen expression RParen

    Semi            reduce using rule 1 (empty -> .)
    Int             shift and go to state 7
    Identifier      shift and go to state 23
    Minus           shift and go to state 53
    BitNot          shift and go to state 56
    Not             shift and go to state 57
    Integer         shift and go to state 59
    LParen          shift and go to state 24

    opt_expression                 shift and go to state 107
    declaration                    shift and go to state 108
    expression                     shift and go to state 32
    empty                          shift and go to state 41
    type                           shift and go to state 22
    assignment                     shift and go to state 42
    conditional                    shift and go to state 43
    logical_or                     shift and go to state 44
    logical_and                    shift and go to state 45
    bit_or                         shift and go to state 46
    xor                            shift and go to state 47
    bit_and                        shift and go to state 48
    equality                       shift and go to state 49
    relational                     shift and go to state 50
    additive                       shift and go to state 51
    multiplicative                 shift and go to state 52
    unary                          shift and go to state 54
    postfix                        shift and go to state 55
    primary                        shift and go to state 58

state 71

    (32) statement_matched -> opt_expression Semi .

    RBrace          reduce using rule 32 (statement_matched -> opt_expression Semi .)
    If              reduce using rule 32 (statement_matched -> opt_expression Semi .)
    While           reduce using rule 32 (statement_matched -> opt_expression Semi .)
    Do              reduce using rule 32 (statement_matched -> opt_expression Semi .)
    For             reduce using rule 32 (statement_matched -> opt_expression Semi .)
    Return          reduce using rule 32 (statement_matched -> opt_expression Semi .)
    LBrace          reduce using rule 32 (statement_matched -> opt_expression Semi .)
    Break           reduce using rule 32 (statement_matched -> opt_expression Semi .)
    Continue        reduce using rule 32 (statement_matched -> opt_expression Semi .)
    Int             reduce using rule 32 (statement_matched -> opt_expression Semi .)
    Identifier      reduce using rule 32 (statement_matched -> opt_expression Semi .)
    Minus           reduce using rule 32 (statement_matched -> opt_expression Semi .)
    BitNot          reduce using rule 32 (statement_matched -> opt_expression Semi .)
    Not             reduce using rule 32 (statement_matched -> opt_expression Semi .)
    Integer         reduce using rule 32 (statement_matched -> opt_expression Semi .)
    LParen          reduce using rule 32 (statement_matched -> opt_expression Semi .)
    Semi            reduce using rule 32 (statement_matched -> opt_expression Semi .)
    Else            reduce using rule 32 (statement_matched -> opt_expression Semi .)


state 72

    (31) statement_matched -> Return expression . Semi

    Semi            shift and go to state 109


state 73

    (34) statement_matched -> Break Semi .

    RBrace          reduce using rule 34 (statement_matched -> Break Semi .)
    If              reduce using rule 34 (statement_matched -> Break Semi .)
    While           reduce using rule 34 (statement_matched -> Break Semi .)
    Do              reduce using rule 34 (statement_matched -> Break Semi .)
    For             reduce using rule 34 (statement_matched -> Break Semi .)
    Return          reduce using rule 34 (statement_matched -> Break Semi .)
    LBrace          reduce using rule 34 (statement_matched -> Break Semi .)
    Break           reduce using rule 34 (statement_matched -> Break Semi .)
    Continue        reduce using rule 34 (statement_matched -> Break Semi .)
    Int             reduce using rule 34 (statement_matched -> Break Semi .)
    Identifier      reduce using rule 34 (statement_matched -> Break Semi .)
    Minus           reduce using rule 34 (statement_matched -> Break Semi .)
    BitNot          reduce using rule 34 (statement_matched -> Break Semi .)
    Not             reduce using rule 34 (statement_matched -> Break Semi .)
    Integer         reduce using rule 34 (statement_matched -> Break Semi .)
    LParen          reduce using rule 34 (statement_matched -> Break Semi .)
    Semi            reduce using rule 34 (statement_matched -> Break Semi .)
    Else            reduce using rule 34 (statement_matched -> Break Semi .)


state 74

    (35) statement_matched -> Continue Semi .

    RBrace          reduce using rule 35 (statement_matched -> Continue Semi .)
    If              reduce using rule 35 (statement_matched -> Continue Semi .)
    While           reduce using rule 35 (statement_matched -> Continue Semi .)
    Do              reduce using rule 35 (statement_matched -> Continue Semi .)
    For             reduce using rule 35 (statement_matched -> Continue Semi .)
    Return          reduce using rule 35 (statement_matched -> Continue Semi .)
    LBrace          reduce using rule 35 (statement_matched -> Continue Semi .)
    Break           reduce using rule 35 (statement_matched -> Continue Semi .)
    Continue        reduce using rule 35 (statement_matched -> Continue Semi .)
    Int             reduce using rule 35 (statement_matched -> Continue Semi .)
    Identifier      reduce using rule 35 (statement_matched -> Continue Semi .)
    Minus           reduce using rule 35 (statement_matched -> Continue Semi .)
    BitNot          reduce using rule 35 (statement_matched -> Continue Semi .)
    Not             reduce using rule 35 (statement_matched -> Continue Semi .)
    Integer         reduce using rule 35 (statement_matched -> Continue Semi .)
    LParen          reduce using rule 35 (statement_matched -> Continue Semi .)
    Semi            reduce using rule 35 (statement_matched -> Continue Semi .)
    Else            reduce using rule 35 (statement_matched -> Continue Semi .)


state 75

    (78) conditional -> logical_or Question . expression Colon conditional
    (40) expression -> . assignment
    (41) assignment -> . conditional
    (61) assignment -> . Identifier Assign expression
    (42) conditional -> . logical_or
    (78) conditional -> . logical_or Question expression Colon conditional
    (43) logical_or -> . logical_and
    (62) logical_or -> . logical_or Or logical_and
    (44) logical_and -> . bit_or
    (63) logical_and -> . logical_and And bit_or
    (45) bit_or -> . xor
    (64) bit_or -> . bit_or BitOr xor
    (46) xor -> . bit_and
    (65) xor -> . xor Xor bit_and
    (47) bit_and -> . equality
    (66) bit_and -> . bit_and BitAnd equality
    (48) equality -> . relational
    (67) equality -> . equality NotEqual relational
    (68) equality -> . equality Equal relational
    (49) relational -> . additive
    (69) relational -> . relational Less additive
    (70) relational -> . relational Greater additive
    (71) relational -> . relational LessEqual additive
    (72) relational -> . relational GreaterEqual additive
    (50) additive -> . multiplicative
    (73) additive -> . additive Plus multiplicative
    (74) additive -> . additive Minus multiplicative
    (51) multiplicative -> . unary
    (75) multiplicative -> . multiplicative Mul unary
    (76) multiplicative -> . multiplicative Div unary
    (77) multiplicative -> . multiplicative Mod unary
    (52) unary -> . postfix
    (54) unary -> . Minus unary
    (55) unary -> . BitNot unary
    (56) unary -> . Not unary
    (53) postfix -> . primary
    (57) postfix -> . Identifier LParen expression_list RParen
    (79) primary -> . Integer
    (80) primary -> . Identifier
    (81) primary -> . LParen expression RParen

    Identifier      shift and go to state 23
    Minus           shift and go to state 53
    BitNot          shift and go to state 56
    Not             shift and go to state 57
    Integer         shift and go to state 59
    LParen          shift and go to state 24

    logical_or                     shift and go to state 44
    expression                     shift and go to state 110
    conditional                    shift and go to state 43
    assignment                     shift and go to state 42
    logical_and                    shift and go to state 45
    bit_or                         shift and go to state 46
    xor                            shift and go to state 47
    bit_and                        shift and go to state 48
    equality                       shift and go to state 49
    relational                     shift and go to state 50
    additive                       shift and go to state 51
    multiplicative                 shift and go to state 52
    unary                          shift and go to state 54
    postfix                        shift and go to state 55
    primary                        shift and go to state 58

state 76

    (62) logical_or -> logical_or Or . logical_and
    (44) logical_and -> . bit_or
    (63) logical_and -> . logical_and And bit_or
    (45) bit_or -> . xor
    (64) bit_or -> . bit_or BitOr xor
    (46) xor -> . bit_and
    (65) xor -> . xor Xor bit_and
    (47) bit_and -> . equality
    (66) bit_and -> . bit_and BitAnd equality
    (48) equality -> . relational
    (67) equality -> . equality NotEqual relational
    (68) equality -> . equality Equal relational
    (49) relational -> . additive
    (69) relational -> . relational Less additive
    (70) relational -> . relational Greater additive
    (71) relational -> . relational LessEqual additive
    (72) relational -> . relational GreaterEqual additive
    (50) additive -> . multiplicative
    (73) additive -> . additive Plus multiplicative
    (74) additive -> . additive Minus multiplicative
    (51) multiplicative -> . unary
    (75) multiplicative -> . multiplicative Mul unary
    (76) multiplicative -> . multiplicative Div unary
    (77) multiplicative -> . multiplicative Mod unary
    (52) unary -> . postfix
    (54) unary -> . Minus unary
    (55) unary -> . BitNot unary
    (56) unary -> . Not unary
    (53) postfix -> . primary
    (57) postfix -> . Identifier LParen expression_list RParen
    (79) primary -> . Integer
    (80) primary -> . Identifier
    (81) primary -> . LParen expression RParen

    Minus           shift and go to state 53
    BitNot          shift and go to state 56
    Not             shift and go to state 57
    Identifier      shift and go to state 93
    Integer         shift and go to state 59
    LParen          shift and go to state 24

    logical_and                    shift and go to state 111
    bit_or                         shift and go to state 46
    xor                            shift and go to state 47
    bit_and                        shift and go to state 48
    equality                       shift and go to state 49
    relational                     shift and go to state 50
    additive                       shift and go to state 51
    multiplicative                 shift and go to state 52
    unary                          shift and go to state 54
    postfix                        shift and go to state 55
    primary                        shift and go to state 58

state 77

    (63) logical_and -> logical_and And . bit_or
    (45) bit_or -> . xor
    (64) bit_or -> . bit_or BitOr xor
    (46) xor -> . bit_and
    (65) xor -> . xor Xor bit_and
    (47) bit_and -> . equality
    (66) bit_and -> . bit_and BitAnd equality
    (48) equality -> . relational
    (67) equality -> . equality NotEqual relational
    (68) equality -> . equality Equal relational
    (49) relational -> . additive
    (69) relational -> . relational Less additive
    (70) relational -> . relational Greater additive
    (71) relational -> . relational LessEqual additive
    (72) relational -> . relational GreaterEqual additive
    (50) additive -> . multiplicative
    (73) additive -> . additive Plus multiplicative
    (74) additive -> . additive Minus multiplicative
    (51) multiplicative -> . unary
    (75) multiplicative -> . multiplicative Mul unary
    (76) multiplicative -> . multiplicative Div unary
    (77) multiplicative -> . multiplicative Mod unary
    (52) unary -> . postfix
    (54) unary -> . Minus unary
    (55) unary -> . BitNot unary
    (56) unary -> . Not unary
    (53) postfix -> . primary
    (57) postfix -> . Identifier LParen expression_list RParen
    (79) primary -> . Integer
    (80) primary -> . Identifier
    (81) primary -> . LParen expression RParen

    Minus           shift and go to state 53
    BitNot          shift and go to state 56
    Not             shift and go to state 57
    Identifier      shift and go to state 93
    Integer         shift and go to state 59
    LParen          shift and go to state 24

    bit_or                         shift and go to state 112
    xor                            shift and go to state 47
    bit_and                        shift and go to state 48
    equality                       shift and go to state 49
    relational                     shift and go to state 50
    additive                       shift and go to state 51
    multiplicative                 shift and go to state 52
    unary                          shift and go to state 54
    postfix                        shift and go to state 55
    primary                        shift and go to state 58

state 78

    (64) bit_or -> bit_or BitOr . xor
    (46) xor -> . bit_and
    (65) xor -> . xor Xor bit_and
    (47) bit_and -> . equality
    (66) bit_and -> . bit_and BitAnd equality
    (48) equality -> . relational
    (67) equality -> . equality NotEqual relational
    (68) equality -> . equality Equal relational
    (49) relational -> . additive
    (69) relational -> . relational Less additive
    (70) relational -> . relational Greater additive
    (71) relational -> . relational LessEqual additive
    (72) relational -> . relational GreaterEqual additive
    (50) additive -> . multiplicative
    (73) additive -> . additive Plus multiplicative
    (74) additive -> . additive Minus multiplicative
    (51) multiplicative -> . unary
    (75) multiplicative -> . multiplicative Mul unary
    (76) multiplicative -> . multiplicative Div unary
    (77) multiplicative -> . multiplicative Mod unary
    (52) unary -> . postfix
    (54) unary -> . Minus unary
    (55) unary -> . BitNot unary
    (56) unary -> . Not unary
    (53) postfix -> . primary
    (57) postfix -> . Identifier LParen expression_list RParen
    (79) primary -> . Integer
    (80) primary -> . Identifier
    (81) primary -> . LParen expression RParen

    Minus           shift and go to state 53
    BitNot          shift and go to state 56
    Not             shift and go to state 57
    Identifier      shift and go to state 93
    Integer         shift and go to state 59
    LParen          shift and go to state 24

    xor                            shift and go to state 113
    bit_and                        shift and go to state 48
    equality                       shift and go to state 49
    relational                     shift and go to state 50
    additive                       shift and go to state 51
    multiplicative                 shift and go to state 52
    unary                          shift and go to state 54
    postfix                        shift and go to state 55
    primary                        shift and go to state 58

state 79

    (65) xor -> xor Xor . bit_and
    (47) bit_and -> . equality
    (66) bit_and -> . bit_and BitAnd equality
    (48) equality -> . relational
    (67) equality -> . equality NotEqual relational
    (68) equality -> . equality Equal relational
    (49) relational -> . additive
    (69) relational -> . relational Less additive
    (70) relational -> . relational Greater additive
    (71) relational -> . relational LessEqual additive
    (72) relational -> . relational GreaterEqual additive
    (50) additive -> . multiplicative
    (73) additive -> . additive Plus multiplicative
    (74) additive -> . additive Minus multiplicative
    (51) multiplicative -> . unary
    (75) multiplicative -> . multiplicative Mul unary
    (76) multiplicative -> . multiplicative Div unary
    (77) multiplicative -> . multiplicative Mod unary
    (52) unary -> . postfix
    (54) unary -> . Minus unary
    (55) unary -> . BitNot unary
    (56) unary -> . Not unary
    (53) postfix -> . primary
    (57) postfix -> . Identifier LParen expression_list RParen
    (79) primary -> . Integer
    (80) primary -> . Identifier
    (81) primary -> . LParen expression RParen

    Minus           shift and go to state 53
    BitNot          shift and go to state 56
    Not             shift and go to state 57
    Identifier      shift and go to state 93
    Integer         shift and go to state 59
    LParen          shift and go to state 24

    bit_and                        shift and go to state 114
    equality                       shift and go to state 49
    relational                     shift and go to state 50
    additive                       shift and go to state 51
    multiplicative                 shift and go to state 52
    unary                          shift and go to state 54
    postfix                        shift and go to state 55
    primary                        shift and go to state 58

state 80

    (66) bit_and -> bit_and BitAnd . equality
    (48) equality -> . relational
    (67) equality -> . equality NotEqual relational
    (68) equality -> . equality Equal relational
    (49) relational -> . additive
    (69) relational -> . relational Less additive
    (70) relational -> . relational Greater additive
    (71) relational -> . relational LessEqual additive
    (72) relational -> . relational GreaterEqual additive
    (50) additive -> . multiplicative
    (73) additive -> . additive Plus multiplicative
    (74) additive -> . additive Minus multiplicative
    (51) multiplicative -> . unary
    (75) multiplicative -> . multiplicative Mul unary
    (76) multiplicative -> . multiplicative Div unary
    (77) multiplicative -> . multiplicative Mod unary
    (52) unary -> . postfix
    (54) unary -> . Minus unary
    (55) unary -> . BitNot unary
    (56) unary -> . Not unary
    (53) postfix -> . primary
    (57) postfix -> . Identifier LParen expression_list RParen
    (79) primary -> . Integer
    (80) primary -> . Identifier
    (81) primary -> . LParen expression RParen

    Minus           shift and go to state 53
    BitNot          shift and go to state 56
    Not             shift and go to state 57
    Identifier      shift and go to state 93
    Integer         shift and go to state 59
    LParen          shift and go to state 24

    equality                       shift and go to state 115
    relational                     shift and go to state 50
    additive                       shift and go to state 51
    multiplicative                 shift and go to state 52
    unary                          shift and go to state 54
    postfix                        shift and go to state 55
    primary                        shift and go to state 58

state 81

    (67) equality -> equality NotEqual . relational
    (49) relational -> . additive
    (69) relational -> . relational Less additive
    (70) relational -> . relational Greater additive
    (71) relational -> . relational LessEqual additive
    (72) relational -> . relational GreaterEqual additive
    (50) additive -> . multiplicative
    (73) additive -> . additive Plus multiplicative
    (74) additive -> . additive Minus multiplicative
    (51) multiplicative -> . unary
    (75) multiplicative -> . multiplicative Mul unary
    (76) multiplicative -> . multiplicative Div unary
    (77) multiplicative -> . multiplicative Mod unary
    (52) unary -> . postfix
    (54) unary -> . Minus unary
    (55) unary -> . BitNot unary
    (56) unary -> . Not unary
    (53) postfix -> . primary
    (57) postfix -> . Identifier LParen expression_list RParen
    (79) primary -> . Integer
    (80) primary -> . Identifier
    (81) primary -> . LParen expression RParen

    Minus           shift and go to state 53
    BitNot          shift and go to state 56
    Not             shift and go to state 57
    Identifier      shift and go to state 93
    Integer         shift and go to state 59
    LParen          shift and go to state 24

    relational                     shift and go to state 116
    additive                       shift and go to state 51
    multiplicative                 shift and go to state 52
    unary                          shift and go to state 54
    postfix                        shift and go to state 55
    primary                        shift and go to state 58

state 82

    (68) equality -> equality Equal . relational
    (49) relational -> . additive
    (69) relational -> . relational Less additive
    (70) relational -> . relational Greater additive
    (71) relational -> . relational LessEqual additive
    (72) relational -> . relational GreaterEqual additive
    (50) additive -> . multiplicative
    (73) additive -> . additive Plus multiplicative
    (74) additive -> . additive Minus multiplicative
    (51) multiplicative -> . unary
    (75) multiplicative -> . multiplicative Mul unary
    (76) multiplicative -> . multiplicative Div unary
    (77) multiplicative -> . multiplicative Mod unary
    (52) unary -> . postfix
    (54) unary -> . Minus unary
    (55) unary -> . BitNot unary
    (56) unary -> . Not unary
    (53) postfix -> . primary
    (57) postfix -> . Identifier LParen expression_list RParen
    (79) primary -> . Integer
    (80) primary -> . Identifier
    (81) primary -> . LParen expression RParen

    Minus           shift and go to state 53
    BitNot          shift and go to state 56
    Not             shift and go to state 57
    Identifier      shift and go to state 93
    Integer         shift and go to state 59
    LParen          shift and go to state 24

    relational                     shift and go to state 117
    additive                       shift and go to state 51
    multiplicative                 shift and go to state 52
    unary                          shift and go to state 54
    postfix                        shift and go to state 55
    primary                        shift and go to state 58

state 83

    (69) relational -> relational Less . additive
    (50) additive -> . multiplicative
    (73) additive -> . additive Plus multiplicative
    (74) additive -> . additive Minus multiplicative
    (51) multiplicative -> . unary
    (75) multiplicative -> . multiplicative Mul unary
    (76) multiplicative -> . multiplicative Div unary
    (77) multiplicative -> . multiplicative Mod unary
    (52) unary -> . postfix
    (54) unary -> . Minus unary
    (55) unary -> . BitNot unary
    (56) unary -> . Not unary
    (53) postfix -> . primary
    (57) postfix -> . Identifier LParen expression_list RParen
    (79) primary -> . Integer
    (80) primary -> . Identifier
    (81) primary -> . LParen expression RParen

    Minus           shift and go to state 53
    BitNot          shift and go to state 56
    Not             shift and go to state 57
    Identifier      shift and go to state 93
    Integer         shift and go to state 59
    LParen          shift and go to state 24

    additive                       shift and go to state 118
    multiplicative                 shift and go to state 52
    unary                          shift and go to state 54
    postfix                        shift and go to state 55
    primary                        shift and go to state 58

state 84

    (70) relational -> relational Greater . additive
    (50) additive -> . multiplicative
    (73) additive -> . additive Plus multiplicative
    (74) additive -> . additive Minus multiplicative
    (51) multiplicative -> . unary
    (75) multiplicative -> . multiplicative Mul unary
    (76) multiplicative -> . multiplicative Div unary
    (77) multiplicative -> . multiplicative Mod unary
    (52) unary -> . postfix
    (54) unary -> . Minus unary
    (55) unary -> . BitNot unary
    (56) unary -> . Not unary
    (53) postfix -> . primary
    (57) postfix -> . Identifier LParen expression_list RParen
    (79) primary -> . Integer
    (80) primary -> . Identifier
    (81) primary -> . LParen expression RParen

    Minus           shift and go to state 53
    BitNot          shift and go to state 56
    Not             shift and go to state 57
    Identifier      shift and go to state 93
    Integer         shift and go to state 59
    LParen          shift and go to state 24

    additive                       shift and go to state 119
    multiplicative                 shift and go to state 52
    unary                          shift and go to state 54
    postfix                        shift and go to state 55
    primary                        shift and go to state 58

state 85

    (71) relational -> relational LessEqual . additive
    (50) additive -> . multiplicative
    (73) additive -> . additive Plus multiplicative
    (74) additive -> . additive Minus multiplicative
    (51) multiplicative -> . unary
    (75) multiplicative -> . multiplicative Mul unary
    (76) multiplicative -> . multiplicative Div unary
    (77) multiplicative -> . multiplicative Mod unary
    (52) unary -> . postfix
    (54) unary -> . Minus unary
    (55) unary -> . BitNot unary
    (56) unary -> . Not unary
    (53) postfix -> . primary
    (57) postfix -> . Identifier LParen expression_list RParen
    (79) primary -> . Integer
    (80) primary -> . Identifier
    (81) primary -> . LParen expression RParen

    Minus           shift and go to state 53
    BitNot          shift and go to state 56
    Not             shift and go to state 57
    Identifier      shift and go to state 93
    Integer         shift and go to state 59
    LParen          shift and go to state 24

    additive                       shift and go to state 120
    multiplicative                 shift and go to state 52
    unary                          shift and go to state 54
    postfix                        shift and go to state 55
    primary                        shift and go to state 58

state 86

    (72) relational -> relational GreaterEqual . additive
    (50) additive -> . multiplicative
    (73) additive -> . additive Plus multiplicative
    (74) additive -> . additive Minus multiplicative
    (51) multiplicative -> . unary
    (75) multiplicative -> . multiplicative Mul unary
    (76) multiplicative -> . multiplicative Div unary
    (77) multiplicative -> . multiplicative Mod unary
    (52) unary -> . postfix
    (54) unary -> . Minus unary
    (55) unary -> . BitNot unary
    (56) unary -> . Not unary
    (53) postfix -> . primary
    (57) postfix -> . Identifier LParen expression_list RParen
    (79) primary -> . Integer
    (80) primary -> . Identifier
    (81) primary -> . LParen expression RParen

    Minus           shift and go to state 53
    BitNot          shift and go to state 56
    Not             shift and go to state 57
    Identifier      shift and go to state 93
    Integer         shift and go to state 59
    LParen          shift and go to state 24

    additive                       shift and go to state 121
    multiplicative                 shift and go to state 52
    unary                          shift and go to state 54
    postfix                        shift and go to state 55
    primary                        shift and go to state 58

state 87

    (73) additive -> additive Plus . multiplicative
    (51) multiplicative -> . unary
    (75) multiplicative -> . multiplicative Mul unary
    (76) multiplicative -> . multiplicative Div unary
    (77) multiplicative -> . multiplicative Mod unary
    (52) unary -> . postfix
    (54) unary -> . Minus unary
    (55) unary -> . BitNot unary
    (56) unary -> . Not unary
    (53) postfix -> . primary
    (57) postfix -> . Identifier LParen expression_list RParen
    (79) primary -> . Integer
    (80) primary -> . Identifier
    (81) primary -> . LParen expression RParen

    Minus           shift and go to state 53
    BitNot          shift and go to state 56
    Not             shift and go to state 57
    Identifier      shift and go to state 93
    Integer         shift and go to state 59
    LParen          shift and go to state 24

    multiplicative                 shift and go to state 122
    unary                          shift and go to state 54
    postfix                        shift and go to state 55
    primary                        shift and go to state 58

state 88

    (74) additive -> additive Minus . multiplicative
    (51) multiplicative -> . unary
    (75) multiplicative -> . multiplicative Mul unary
    (76) multiplicative -> . multiplicative Div unary
    (77) multiplicative -> . multiplicative Mod unary
    (52) unary -> . postfix
    (54) unary -> . Minus unary
    (55) unary -> . BitNot unary
    (56) unary -> . Not unary
    (53) postfix -> . primary
    (57) postfix -> . Identifier LParen expression_list RParen
    (79) primary -> . Integer
    (80) primary -> . Identifier
    (81) primary -> . LParen expression RParen

    Minus           shift and go to state 53
    BitNot          shift and go to state 56
    Not             shift and go to state 57
    Identifier      shift and go to state 93
    Integer         shift and go to state 59
    LParen          shift and go to state 24

    multiplicative                 shift and go to state 123
    unary                          shift and go to state 54
    postfix                        shift and go to state 55
    primary                        shift and go to state 58

state 89

    (75) multiplicative -> multiplicative Mul . unary
    (52) unary -> . postfix
    (54) unary -> . Minus unary
    (55) unary -> . BitNot unary
    (56) unary -> . Not unary
    (53) postfix -> . primary
    (57) postfix -> . Identifier LParen expression_list RParen
    (79) primary -> . Integer
    (80) primary -> . Identifier
    (81) primary -> . LParen expression RParen

    Minus           shift and go to state 53
    BitNot          shift and go to state 56
    Not             shift and go to state 57
    Identifier      shift and go to state 93
    Integer         shift and go to state 59
    LParen          shift and go to state 24

    unary                          shift and go to state 124
    postfix                        shift and go to state 55
    primary                        shift and go to state 58

state 90

    (76) multiplicative -> multiplicative Div . unary
    (52) unary -> . postfix
    (54) unary -> . Minus unary
    (55) unary -> . BitNot unary
    (56) unary -> . Not unary
    (53) postfix -> . primary
    (57) postfix -> . Identifier LParen expression_list RParen
    (79) primary -> . Integer
    (80) primary -> . Identifier
    (81) primary -> . LParen expression RParen

    Minus           shift and go to state 53
    BitNot          shift and go to state 56
    Not             shift and go to state 57
    Identifier      shift and go to state 93
    Integer         shift and go to state 59
    LParen          shift and go to state 24

    unary                          shift and go to state 125
    postfix                        shift and go to state 55
    primary                        shift and go to state 58

state 91

    (77) multiplicative -> multiplicative Mod . unary
    (52) unary -> . postfix
    (54) unary -> . Minus unary
    (55) unary -> . BitNot unary
    (56) unary -> . Not unary
    (53) postfix -> . primary
    (57) postfix -> . Identifier LParen expression_list RParen
    (79) primary -> . Integer
    (80) primary -> . Identifier
    (81) primary -> . LParen expression RParen

    Minus           shift and go to state 53
    BitNot          shift and go to state 56
    Not             shift and go to state 57
    Identifier      shift and go to state 93
    Integer         shift and go to state 59
    LParen          shift and go to state 24

    unary                          shift and go to state 126
    postfix                        shift and go to state 55
    primary                        shift and go to state 58

state 92

    (54) unary -> Minus unary .

    Mul             reduce using rule 54 (unary -> Minus unary .)
    Div             reduce using rule 54 (unary -> Minus unary .)
    Mod             reduce using rule 54 (unary -> Minus unary .)
    Plus            reduce using rule 54 (unary -> Minus unary .)
    Minus           reduce using rule 54 (unary -> Minus unary .)
    Less            reduce using rule 54 (unary -> Minus unary .)
    Greater         reduce using rule 54 (unary -> Minus unary .)
    LessEqual       reduce using rule 54 (unary -> Minus unary .)
    GreaterEqual    reduce using rule 54 (unary -> Minus unary .)
    NotEqual        reduce using rule 54 (unary -> Minus unary .)
    Equal           reduce using rule 54 (unary -> Minus unary .)
    BitAnd          reduce using rule 54 (unary -> Minus unary .)
    Xor             reduce using rule 54 (unary -> Minus unary .)
    BitOr           reduce using rule 54 (unary -> Minus unary .)
    And             reduce using rule 54 (unary -> Minus unary .)
    Question        reduce using rule 54 (unary -> Minus unary .)
    Or              reduce using rule 54 (unary -> Minus unary .)
    Semi            reduce using rule 54 (unary -> Minus unary .)
    RParen          reduce using rule 54 (unary -> Minus unary .)
    Comma           reduce using rule 54 (unary -> Minus unary .)
    Colon           reduce using rule 54 (unary -> Minus unary .)


state 93

    (57) postfix -> Identifier . LParen expression_list RParen
    (80) primary -> Identifier .

    LParen          shift and go to state 62
    Mul             reduce using rule 80 (primary -> Identifier .)
    Div             reduce using rule 80 (primary -> Identifier .)
    Mod             reduce using rule 80 (primary -> Identifier .)
    Plus            reduce using rule 80 (primary -> Identifier .)
    Minus           reduce using rule 80 (primary -> Identifier .)
    Less            reduce using rule 80 (primary -> Identifier .)
    Greater         reduce using rule 80 (primary -> Identifier .)
    LessEqual       reduce using rule 80 (primary -> Identifier .)
    GreaterEqual    reduce using rule 80 (primary -> Identifier .)
    NotEqual        reduce using rule 80 (primary -> Identifier .)
    Equal           reduce using rule 80 (primary -> Identifier .)
    BitAnd          reduce using rule 80 (primary -> Identifier .)
    Xor             reduce using rule 80 (primary -> Identifier .)
    BitOr           reduce using rule 80 (primary -> Identifier .)
    And             reduce using rule 80 (primary -> Identifier .)
    Question        reduce using rule 80 (primary -> Identifier .)
    Or              reduce using rule 80 (primary -> Identifier .)
    Semi            reduce using rule 80 (primary -> Identifier .)
    RParen          reduce using rule 80 (primary -> Identifier .)
    Comma           reduce using rule 80 (primary -> Identifier .)
    Colon           reduce using rule 80 (primary -> Identifier .)


state 94

    (55) unary -> BitNot unary .

    Mul             reduce using rule 55 (unary -> BitNot unary .)
    Div             reduce using rule 55 (unary -> BitNot unary .)
    Mod             reduce using rule 55 (unary -> BitNot unary .)
    Plus            reduce using rule 55 (unary -> BitNot unary .)
    Minus           reduce using rule 55 (unary -> BitNot unary .)
    Less            reduce using rule 55 (unary -> BitNot unary .)
    Greater         reduce using rule 55 (unary -> BitNot unary .)
    LessEqual       reduce using rule 55 (unary -> BitNot unary .)
    GreaterEqual    reduce using rule 55 (unary -> BitNot unary .)
    NotEqual        reduce using rule 55 (unary -> BitNot unary .)
    Equal           reduce using rule 55 (unary -> BitNot unary .)
    BitAnd          reduce using rule 55 (unary -> BitNot unary .)
    Xor             reduce using rule 55 (unary -> BitNot unary .)
    BitOr           reduce using rule 55 (unary -> BitNot unary .)
    And             reduce using rule 55 (unary -> BitNot unary .)
    Question        reduce using rule 55 (unary -> BitNot unary .)
    Or              reduce using rule 55 (unary -> BitNot unary .)
    Semi            reduce using rule 55 (unary -> BitNot unary .)
    RParen          reduce using rule 55 (unary -> BitNot unary .)
    Comma           reduce using rule 55 (unary -> BitNot unary .)
    Colon           reduce using rule 55 (unary -> BitNot unary .)


state 95

    (56) unary -> Not unary .

    Mul             reduce using rule 56 (unary -> Not unary .)
    Div             reduce using rule 56 (unary -> Not unary .)
    Mod             reduce using rule 56 (unary -> Not unary .)
    Plus            reduce using rule 56 (unary -> Not unary .)
    Minus           reduce using rule 56 (unary -> Not unary .)
    Less            reduce using rule 56 (unary -> Not unary .)
    Greater         reduce using rule 56 (unary -> Not unary .)
    LessEqual       reduce using rule 56 (unary -> Not unary .)
    GreaterEqual    reduce using rule 56 (unary -> Not unary .)
    NotEqual        reduce using rule 56 (unary -> Not unary .)
    Equal           reduce using rule 56 (unary -> Not unary .)
    BitAnd          reduce using rule 56 (unary -> Not unary .)
    Xor             reduce using rule 56 (unary -> Not unary .)
    BitOr           reduce using rule 56 (unary -> Not unary .)
    And             reduce using rule 56 (unary -> Not unary .)
    Question        reduce using rule 56 (unary -> Not unary .)
    Or              reduce using rule 56 (unary -> Not unary .)
    Semi            reduce using rule 56 (unary -> Not unary .)
    RParen          reduce using rule 56 (unary -> Not unary .)
    Comma           reduce using rule 56 (unary -> Not unary .)
    Colon           reduce using rule 56 (unary -> Not unary .)


state 96

    (39) declaration -> type Identifier Assign . expression
    (40) expression -> . assignment
    (41) assignment -> . conditional
    (61) assignment -> . Identifier Assign expression
    (42) conditional -> . logical_or
    (78) conditional -> . logical_or Question expression Colon conditional
    (43) logical_or -> . logical_and
    (62) logical_or -> . logical_or Or logical_and
    (44) logical_and -> . bit_or
    (63) logical_and -> . logical_and And bit_or
    (45) bit_or -> . xor
    (64) bit_or -> . bit_or BitOr xor
    (46) xor -> . bit_and
    (65) xor -> . xor Xor bit_and
    (47) bit_and -> . equality
    (66) bit_and -> . bit_and BitAnd equality
    (48) equality -> . relational
    (67) equality -> . equality NotEqual relational
    (68) equality -> . equality Equal relational
    (49) relational -> . additive
    (69) relational -> . relational Less additive
    (70) relational -> . relational Greater additive
    (71) relational -> . relational LessEqual additive
    (72) relational -> . relational GreaterEqual additive
    (50) additive -> . multiplicative
    (73) additive -> . additive Plus multiplicative
    (74) additive -> . additive Minus multiplicative
    (51) multiplicative -> . unary
    (75) multiplicative -> . multiplicative Mul unary
    (76) multiplicative -> . multiplicative Div unary
    (77) multiplicative -> . multiplicative Mod unary
    (52) unary -> . postfix
    (54) unary -> . Minus unary
    (55) unary -> . BitNot unary
    (56) unary -> . Not unary
    (53) postfix -> . primary
    (57) postfix -> . Identifier LParen expression_list RParen
    (79) primary -> . Integer
    (80) primary -> . Identifier
    (81) primary -> . LParen expression RParen

    Identifier      shift and go to state 23
    Minus           shift and go to state 53
    BitNot          shift and go to state 56
    Not             shift and go to state 57
    Integer         shift and go to state 59
    LParen          shift and go to state 24

    expression                     shift and go to state 127
    assignment                     shift and go to state 42
    conditional                    shift and go to state 43
    logical_or                     shift and go to state 44
    logical_and                    shift and go to state 45
    bit_or                         shift and go to state 46
    xor                            shift and go to state 47
    bit_and                        shift and go to state 48
    equality                       shift and go to state 49
    relational                     shift and go to state 50
    additive                       shift and go to state 51
    multiplicative                 shift and go to state 52
    unary                          shift and go to state 54
    postfix                        shift and go to state 55
    primary                        shift and go to state 58

state 97

    (61) assignment -> Identifier Assign expression .

    Semi            reduce using rule 61 (assignment -> Identifier Assign expression .)
    RParen          reduce using rule 61 (assignment -> Identifier Assign expression .)
    Comma           reduce using rule 61 (assignment -> Identifier Assign expression .)
    Colon           reduce using rule 61 (assignment -> Identifier Assign expression .)


state 98

    (57) postfix -> Identifier LParen expression_list . RParen
    (58) expression_list -> expression_list . Comma expression

    RParen          shift and go to state 128
    Comma           shift and go to state 129


state 99

    (59) expression_list -> expression .

    RParen          reduce using rule 59 (expression_list -> expression .)
    Comma           reduce using rule 59 (expression_list -> expression .)


state 100

    (60) expression_list -> empty .

    RParen          reduce using rule 60 (expression_list -> empty .)
    Comma           reduce using rule 60 (expression_list -> empty .)


state 101

    (81) primary -> LParen expression RParen .

    Mul             reduce using rule 81 (primary -> LParen expression RParen .)
    Div             reduce using rule 81 (primary -> LParen expression RParen .)
    Mod             reduce using rule 81 (primary -> LParen expression RParen .)
    Plus            reduce using rule 81 (primary -> LParen expression RParen .)
    Minus           reduce using rule 81 (primary -> LParen expression RParen .)
    Less            reduce using rule 81 (primary -> LParen expression RParen .)
    Greater         reduce using rule 81 (primary -> LParen expression RParen .)
    LessEqual       reduce using rule 81 (primary -> LParen expression RParen .)
    GreaterEqual    reduce using rule 81 (primary -> LParen expression RParen .)
    NotEqual        reduce using rule 81 (primary -> LParen expression RParen .)
    Equal           reduce using rule 81 (primary -> LParen expression RParen .)
    BitAnd          reduce using rule 81 (primary -> LParen expression RParen .)
    Xor             reduce using rule 81 (primary -> LParen expression RParen .)
    BitOr           reduce using rule 81 (primary -> LParen expression RParen .)
    And             reduce using rule 81 (primary -> LParen expression RParen .)
    Question        reduce using rule 81 (primary -> LParen expression RParen .)
    Or              reduce using rule 81 (primary -> LParen expression RParen .)
    Semi            reduce using rule 81 (primary -> LParen expression RParen .)
    RParen          reduce using rule 81 (primary -> LParen expression RParen .)
    Comma           reduce using rule 81 (primary -> LParen expression RParen .)
    Colon           reduce using rule 81 (primary -> LParen expression RParen .)


state 102

    (33) statement_matched -> LBrace block RBrace .

    RBrace          reduce using rule 33 (statement_matched -> LBrace block RBrace .)
    If              reduce using rule 33 (statement_matched -> LBrace block RBrace .)
    While           reduce using rule 33 (statement_matched -> LBrace block RBrace .)
    Do              reduce using rule 33 (statement_matched -> LBrace block RBrace .)
    For             reduce using rule 33 (statement_matched -> LBrace block RBrace .)
    Return          reduce using rule 33 (statement_matched -> LBrace block RBrace .)
    LBrace          reduce using rule 33 (statement_matched -> LBrace block RBrace .)
    Break           reduce using rule 33 (statement_matched -> LBrace block RBrace .)
    Continue        reduce using rule 33 (statement_matched -> LBrace block RBrace .)
    Int             reduce using rule 33 (statement_matched -> LBrace block RBrace .)
    Identifier      reduce using rule 33 (statement_matched -> LBrace block RBrace .)
    Minus           reduce using rule 33 (statement_matched -> LBrace block RBrace .)
    BitNot          reduce using rule 33 (statement_matched -> LBrace block RBrace .)
    Not             reduce using rule 33 (statement_matched -> LBrace block RBrace .)
    Integer         reduce using rule 33 (statement_matched -> LBrace block RBrace .)
    LParen          reduce using rule 33 (statement_matched -> LBrace block RBrace .)
    Semi            reduce using rule 33 (statement_matched -> LBrace block RBrace .)
    Else            reduce using rule 33 (statement_matched -> LBrace block RBrace .)


state 103

    (20) statement_matched -> If LParen expression . RParen statement_matched Else statement_matched
    (21) statement_unmatched -> If LParen expression . RParen statement_matched Else statement_unmatched
    (22) statement_unmatched -> If LParen expression . RParen statement

    RParen          shift and go to state 130


state 104

    (23) statement_matched -> While LParen expression . RParen statement_matched
    (24) statement_unmatched -> While LParen expression . RParen statement_unmatched

    RParen          shift and go to state 131


state 105

    (25) statement_matched -> Do statement_matched While . LParen expression RParen Semi

    LParen          shift and go to state 132


state 106

    (26) statement_unmatched -> Do statement_unmatched While . LParen expression RParen Semi

    LParen          shift and go to state 133


state 107

    (27) statement_matched -> For LParen opt_expression . Semi opt_expression Semi opt_expression RParen statement_matched
    (29) statement_unmatched -> For LParen opt_expression . Semi opt_expression Semi opt_expression RParen statement_unmatched

    Semi            shift and go to state 134


state 108

    (28) statement_matched -> For LParen declaration . Semi opt_expression Semi opt_expression RParen statement_matched
    (30) statement_unmatched -> For LParen declaration . Semi opt_expression Semi opt_expression Semi opt_expression RParen statement_unmatched

    Semi            shift and go to state 135


state 109

    (31) statement_matched -> Return expression Semi .

    RBrace          reduce using rule 31 (statement_matched -> Return expression Semi .)
    If              reduce using rule 31 (statement_matched -> Return expression Semi .)
    While           reduce using rule 31 (statement_matched -> Return expression Semi .)
    Do              reduce using rule 31 (statement_matched -> Return expression Semi .)
    For             reduce using rule 31 (statement_matched -> Return expression Semi .)
    Return          reduce using rule 31 (statement_matched -> Return expression Semi .)
    LBrace          reduce using rule 31 (statement_matched -> Return expression Semi .)
    Break           reduce using rule 31 (statement_matched -> Return expression Semi .)
    Continue        reduce using rule 31 (statement_matched -> Return expression Semi .)
    Int             reduce using rule 31 (statement_matched -> Return expression Semi .)
    Identifier      reduce using rule 31 (statement_matched -> Return expression Semi .)
    Minus           reduce using rule 31 (statement_matched -> Return expression Semi .)
    BitNot          reduce using rule 31 (statement_matched -> Return expression Semi .)
    Not             reduce using rule 31 (statement_matched -> Return expression Semi .)
    Integer         reduce using rule 31 (statement_matched -> Return expression Semi .)
    LParen          reduce using rule 31 (statement_matched -> Return expression Semi .)
    Semi            reduce using rule 31 (statement_matched -> Return expression Semi .)
    Else            reduce using rule 31 (statement_matched -> Return expression Semi .)


state 110

    (78) conditional -> logical_or Question expression . Colon conditional

    Colon           shift and go to state 136


state 111

    (62) logical_or -> logical_or Or logical_and .
    (63) logical_and -> logical_and . And bit_or

    Question        reduce using rule 62 (logical_or -> logical_or Or logical_and .)
    Or              reduce using rule 62 (logical_or -> logical_or Or logical_and .)
    Semi            reduce using rule 62 (logical_or -> logical_or Or logical_and .)
    RParen          reduce using rule 62 (logical_or -> logical_or Or logical_and .)
    Comma           reduce using rule 62 (logical_or -> logical_or Or logical_and .)
    Colon           reduce using rule 62 (logical_or -> logical_or Or logical_and .)
    And             shift and go to state 77


state 112

    (63) logical_and -> logical_and And bit_or .
    (64) bit_or -> bit_or . BitOr xor

    And             reduce using rule 63 (logical_and -> logical_and And bit_or .)
    Question        reduce using rule 63 (logical_and -> logical_and And bit_or .)
    Or              reduce using rule 63 (logical_and -> logical_and And bit_or .)
    Semi            reduce using rule 63 (logical_and -> logical_and And bit_or .)
    RParen          reduce using rule 63 (logical_and -> logical_and And bit_or .)
    Comma           reduce using rule 63 (logical_and -> logical_and And bit_or .)
    Colon           reduce using rule 63 (logical_and -> logical_and And bit_or .)
    BitOr           shift and go to state 78


state 113

    (64) bit_or -> bit_or BitOr xor .
    (65) xor -> xor . Xor bit_and

    BitOr           reduce using rule 64 (bit_or -> bit_or BitOr xor .)
    And             reduce using rule 64 (bit_or -> bit_or BitOr xor .)
    Question        reduce using rule 64 (bit_or -> bit_or BitOr xor .)
    Or              reduce using rule 64 (bit_or -> bit_or BitOr xor .)
    Semi            reduce using rule 64 (bit_or -> bit_or BitOr xor .)
    RParen          reduce using rule 64 (bit_or -> bit_or BitOr xor .)
    Comma           reduce using rule 64 (bit_or -> bit_or BitOr xor .)
    Colon           reduce using rule 64 (bit_or -> bit_or BitOr xor .)
    Xor             shift and go to state 79


state 114

    (65) xor -> xor Xor bit_and .
    (66) bit_and -> bit_and . BitAnd equality

    Xor             reduce using rule 65 (xor -> xor Xor bit_and .)
    BitOr           reduce using rule 65 (xor -> xor Xor bit_and .)
    And             reduce using rule 65 (xor -> xor Xor bit_and .)
    Question        reduce using rule 65 (xor -> xor Xor bit_and .)
    Or              reduce using rule 65 (xor -> xor Xor bit_and .)
    Semi            reduce using rule 65 (xor -> xor Xor bit_and .)
    RParen          reduce using rule 65 (xor -> xor Xor bit_and .)
    Comma           reduce using rule 65 (xor -> xor Xor bit_and .)
    Colon           reduce using rule 65 (xor -> xor Xor bit_and .)
    BitAnd          shift and go to state 80


state 115

    (66) bit_and -> bit_and BitAnd equality .
    (67) equality -> equality . NotEqual relational
    (68) equality -> equality . Equal relational

    BitAnd          reduce using rule 66 (bit_and -> bit_and BitAnd equality .)
    Xor             reduce using rule 66 (bit_and -> bit_and BitAnd equality .)
    BitOr           reduce using rule 66 (bit_and -> bit_and BitAnd equality .)
    And             reduce using rule 66 (bit_and -> bit_and BitAnd equality .)
    Question        reduce using rule 66 (bit_and -> bit_and BitAnd equality .)
    Or              reduce using rule 66 (bit_and -> bit_and BitAnd equality .)
    Semi            reduce using rule 66 (bit_and -> bit_and BitAnd equality .)
    RParen          reduce using rule 66 (bit_and -> bit_and BitAnd equality .)
    Comma           reduce using rule 66 (bit_and -> bit_and BitAnd equality .)
    Colon           reduce using rule 66 (bit_and -> bit_and BitAnd equality .)
    NotEqual        shift and go to state 81
    Equal           shift and go to state 82


state 116

    (67) equality -> equality NotEqual relational .
    (69) relational -> relational . Less additive
    (70) relational -> relational . Greater additive
    (71) relational -> relational . LessEqual additive
    (72) relational -> relational . GreaterEqual additive

    NotEqual        reduce using rule 67 (equality -> equality NotEqual relational .)
    Equal           reduce using rule 67 (equality -> equality NotEqual relational .)
    BitAnd          reduce using rule 67 (equality -> equality NotEqual relational .)
    Xor             reduce using rule 67 (equality -> equality NotEqual relational .)
    BitOr           reduce using rule 67 (equality -> equality NotEqual relational .)
    And             reduce using rule 67 (equality -> equality NotEqual relational .)
    Question        reduce using rule 67 (equality -> equality NotEqual relational .)
    Or              reduce using rule 67 (equality -> equality NotEqual relational .)
    Semi            reduce using rule 67 (equality -> equality NotEqual relational .)
    RParen          reduce using rule 67 (equality -> equality NotEqual relational .)
    Comma           reduce using rule 67 (equality -> equality NotEqual relational .)
    Colon           reduce using rule 67 (equality -> equality NotEqual relational .)
    Less            shift and go to state 83
    Greater         shift and go to state 84
    LessEqual       shift and go to state 85
    GreaterEqual    shift and go to state 86


state 117

    (68) equality -> equality Equal relational .
    (69) relational -> relational . Less additive
    (70) relational -> relational . Greater additive
    (71) relational -> relational . LessEqual additive
    (72) relational -> relational . GreaterEqual additive

    NotEqual        reduce using rule 68 (equality -> equality Equal relational .)
    Equal           reduce using rule 68 (equality -> equality Equal relational .)
    BitAnd          reduce using rule 68 (equality -> equality Equal relational .)
    Xor             reduce using rule 68 (equality -> equality Equal relational .)
    BitOr           reduce using rule 68 (equality -> equality Equal relational .)
    And             reduce using rule 68 (equality -> equality Equal relational .)
    Question        reduce using rule 68 (equality -> equality Equal relational .)
    Or              reduce using rule 68 (equality -> equality Equal relational .)
    Semi            reduce using rule 68 (equality -> equality Equal relational .)
    RParen          reduce using rule 68 (equality -> equality Equal relational .)
    Comma           reduce using rule 68 (equality -> equality Equal relational .)
    Colon           reduce using rule 68 (equality -> equality Equal relational .)
    Less            shift and go to state 83
    Greater         shift and go to state 84
    LessEqual       shift and go to state 85
    GreaterEqual    shift and go to state 86


state 118

    (69) relational -> relational Less additive .
    (73) additive -> additive . Plus multiplicative
    (74) additive -> additive . Minus multiplicative

    Less            reduce using rule 69 (relational -> relational Less additive .)
    Greater         reduce using rule 69 (relational -> relational Less additive .)
    LessEqual       reduce using rule 69 (relational -> relational Less additive .)
    GreaterEqual    reduce using rule 69 (relational -> relational Less additive .)
    NotEqual        reduce using rule 69 (relational -> relational Less additive .)
    Equal           reduce using rule 69 (relational -> relational Less additive .)
    BitAnd          reduce using rule 69 (relational -> relational Less additive .)
    Xor             reduce using rule 69 (relational -> relational Less additive .)
    BitOr           reduce using rule 69 (relational -> relational Less additive .)
    And             reduce using rule 69 (relational -> relational Less additive .)
    Question        reduce using rule 69 (relational -> relational Less additive .)
    Or              reduce using rule 69 (relational -> relational Less additive .)
    Semi            reduce using rule 69 (relational -> relational Less additive .)
    RParen          reduce using rule 69 (relational -> relational Less additive .)
    Comma           reduce using rule 69 (relational -> relational Less additive .)
    Colon           reduce using rule 69 (relational -> relational Less additive .)
    Plus            shift and go to state 87
    Minus           shift and go to state 88


state 119

    (70) relational -> relational Greater additive .
    (73) additive -> additive . Plus multiplicative
    (74) additive -> additive . Minus multiplicative

    Less            reduce using rule 70 (relational -> relational Greater additive .)
    Greater         reduce using rule 70 (relational -> relational Greater additive .)
    LessEqual       reduce using rule 70 (relational -> relational Greater additive .)
    GreaterEqual    reduce using rule 70 (relational -> relational Greater additive .)
    NotEqual        reduce using rule 70 (relational -> relational Greater additive .)
    Equal           reduce using rule 70 (relational -> relational Greater additive .)
    BitAnd          reduce using rule 70 (relational -> relational Greater additive .)
    Xor             reduce using rule 70 (relational -> relational Greater additive .)
    BitOr           reduce using rule 70 (relational -> relational Greater additive .)
    And             reduce using rule 70 (relational -> relational Greater additive .)
    Question        reduce using rule 70 (relational -> relational Greater additive .)
    Or              reduce using rule 70 (relational -> relational Greater additive .)
    Semi            reduce using rule 70 (relational -> relational Greater additive .)
    RParen          reduce using rule 70 (relational -> relational Greater additive .)
    Comma           reduce using rule 70 (relational -> relational Greater additive .)
    Colon           reduce using rule 70 (relational -> relational Greater additive .)
    Plus            shift and go to state 87
    Minus           shift and go to state 88


state 120

    (71) relational -> relational LessEqual additive .
    (73) additive -> additive . Plus multiplicative
    (74) additive -> additive . Minus multiplicative

    Less            reduce using rule 71 (relational -> relational LessEqual additive .)
    Greater         reduce using rule 71 (relational -> relational LessEqual additive .)
    LessEqual       reduce using rule 71 (relational -> relational LessEqual additive .)
    GreaterEqual    reduce using rule 71 (relational -> relational LessEqual additive .)
    NotEqual        reduce using rule 71 (relational -> relational LessEqual additive .)
    Equal           reduce using rule 71 (relational -> relational LessEqual additive .)
    BitAnd          reduce using rule 71 (relational -> relational LessEqual additive .)
    Xor             reduce using rule 71 (relational -> relational LessEqual additive .)
    BitOr           reduce using rule 71 (relational -> relational LessEqual additive .)
    And             reduce using rule 71 (relational -> relational LessEqual additive .)
    Question        reduce using rule 71 (relational -> relational LessEqual additive .)
    Or              reduce using rule 71 (relational -> relational LessEqual additive .)
    Semi            reduce using rule 71 (relational -> relational LessEqual additive .)
    RParen          reduce using rule 71 (relational -> relational LessEqual additive .)
    Comma           reduce using rule 71 (relational -> relational LessEqual additive .)
    Colon           reduce using rule 71 (relational -> relational LessEqual additive .)
    Plus            shift and go to state 87
    Minus           shift and go to state 88


state 121

    (72) relational -> relational GreaterEqual additive .
    (73) additive -> additive . Plus multiplicative
    (74) additive -> additive . Minus multiplicative

    Less            reduce using rule 72 (relational -> relational GreaterEqual additive .)
    Greater         reduce using rule 72 (relational -> relational GreaterEqual additive .)
    LessEqual       reduce using rule 72 (relational -> relational GreaterEqual additive .)
    GreaterEqual    reduce using rule 72 (relational -> relational GreaterEqual additive .)
    NotEqual        reduce using rule 72 (relational -> relational GreaterEqual additive .)
    Equal           reduce using rule 72 (relational -> relational GreaterEqual additive .)
    BitAnd          reduce using rule 72 (relational -> relational GreaterEqual additive .)
    Xor             reduce using rule 72 (relational -> relational GreaterEqual additive .)
    BitOr           reduce using rule 72 (relational -> relational GreaterEqual additive .)
    And             reduce using rule 72 (relational -> relational GreaterEqual additive .)
    Question        reduce using rule 72 (relational -> relational GreaterEqual additive .)
    Or              reduce using rule 72 (relational -> relational GreaterEqual additive .)
    Semi            reduce using rule 72 (relational -> relational GreaterEqual additive .)
    RParen          reduce using rule 72 (relational -> relational GreaterEqual additive .)
    Comma           reduce using rule 72 (relational -> relational GreaterEqual additive .)
    Colon           reduce using rule 72 (relational -> relational GreaterEqual additive .)
    Plus            shift and go to state 87
    Minus           shift and go to state 88


state 122

    (73) additive -> additive Plus multiplicative .
    (75) multiplicative -> multiplicative . Mul unary
    (76) multiplicative -> multiplicative . Div unary
    (77) multiplicative -> multiplicative . Mod unary

    Plus            reduce using rule 73 (additive -> additive Plus multiplicative .)
    Minus           reduce using rule 73 (additive -> additive Plus multiplicative .)
    Less            reduce using rule 73 (additive -> additive Plus multiplicative .)
    Greater         reduce using rule 73 (additive -> additive Plus multiplicative .)
    LessEqual       reduce using rule 73 (additive -> additive Plus multiplicative .)
    GreaterEqual    reduce using rule 73 (additive -> additive Plus multiplicative .)
    NotEqual        reduce using rule 73 (additive -> additive Plus multiplicative .)
    Equal           reduce using rule 73 (additive -> additive Plus multiplicative .)
    BitAnd          reduce using rule 73 (additive -> additive Plus multiplicative .)
    Xor             reduce using rule 73 (additive -> additive Plus multiplicative .)
    BitOr           reduce using rule 73 (additive -> additive Plus multiplicative .)
    And             reduce using rule 73 (additive -> additive Plus multiplicative .)
    Question        reduce using rule 73 (additive -> additive Plus multiplicative .)
    Or              reduce using rule 73 (additive -> additive Plus multiplicative .)
    Semi            reduce using rule 73 (additive -> additive Plus multiplicative .)
    RParen          reduce using rule 73 (additive -> additive Plus multiplicative .)
    Comma           reduce using rule 73 (additive -> additive Plus multiplicative .)
    Colon           reduce using rule 73 (additive -> additive Plus multiplicative .)
    Mul             shift and go to state 89
    Div             shift and go to state 90
    Mod             shift and go to state 91


state 123

    (74) additive -> additive Minus multiplicative .
    (75) multiplicative -> multiplicative . Mul unary
    (76) multiplicative -> multiplicative . Div unary
    (77) multiplicative -> multiplicative . Mod unary

    Plus            reduce using rule 74 (additive -> additive Minus multiplicative .)
    Minus           reduce using rule 74 (additive -> additive Minus multiplicative .)
    Less            reduce using rule 74 (additive -> additive Minus multiplicative .)
    Greater         reduce using rule 74 (additive -> additive Minus multiplicative .)
    LessEqual       reduce using rule 74 (additive -> additive Minus multiplicative .)
    GreaterEqual    reduce using rule 74 (additive -> additive Minus multiplicative .)
    NotEqual        reduce using rule 74 (additive -> additive Minus multiplicative .)
    Equal           reduce using rule 74 (additive -> additive Minus multiplicative .)
    BitAnd          reduce using rule 74 (additive -> additive Minus multiplicative .)
    Xor             reduce using rule 74 (additive -> additive Minus multiplicative .)
    BitOr           reduce using rule 74 (additive -> additive Minus multiplicative .)
    And             reduce using rule 74 (additive -> additive Minus multiplicative .)
    Question        reduce using rule 74 (additive -> additive Minus multiplicative .)
    Or              reduce using rule 74 (additive -> additive Minus multiplicative .)
    Semi            reduce using rule 74 (additive -> additive Minus multiplicative .)
    RParen          reduce using rule 74 (additive -> additive Minus multiplicative .)
    Comma           reduce using rule 74 (additive -> additive Minus multiplicative .)
    Colon           reduce using rule 74 (additive -> additive Minus multiplicative .)
    Mul             shift and go to state 89
    Div             shift and go to state 90
    Mod             shift and go to state 91


state 124

    (75) multiplicative -> multiplicative Mul unary .

    Mul             reduce using rule 75 (multiplicative -> multiplicative Mul unary .)
    Div             reduce using rule 75 (multiplicative -> multiplicative Mul unary .)
    Mod             reduce using rule 75 (multiplicative -> multiplicative Mul unary .)
    Plus            reduce using rule 75 (multiplicative -> multiplicative Mul unary .)
    Minus           reduce using rule 75 (multiplicative -> multiplicative Mul unary .)
    Less            reduce using rule 75 (multiplicative -> multiplicative Mul unary .)
    Greater         reduce using rule 75 (multiplicative -> multiplicative Mul unary .)
    LessEqual       reduce using rule 75 (multiplicative -> multiplicative Mul unary .)
    GreaterEqual    reduce using rule 75 (multiplicative -> multiplicative Mul unary .)
    NotEqual        reduce using rule 75 (multiplicative -> multiplicative Mul unary .)
    Equal           reduce using rule 75 (multiplicative -> multiplicative Mul unary .)
    BitAnd          reduce using rule 75 (multiplicative -> multiplicative Mul unary .)
    Xor             reduce using rule 75 (multiplicative -> multiplicative Mul unary .)
    BitOr           reduce using rule 75 (multiplicative -> multiplicative Mul unary .)
    And             reduce using rule 75 (multiplicative -> multiplicative Mul unary .)
    Question        reduce using rule 75 (multiplicative -> multiplicative Mul unary .)
    Or              reduce using rule 75 (multiplicative -> multiplicative Mul unary .)
    Semi            reduce using rule 75 (multiplicative -> multiplicative Mul unary .)
    RParen          reduce using rule 75 (multiplicative -> multiplicative Mul unary .)
    Comma           reduce using rule 75 (multiplicative -> multiplicative Mul unary .)
    Colon           reduce using rule 75 (multiplicative -> multiplicative Mul unary .)


state 125

    (76) multiplicative -> multiplicative Div unary .

    Mul             reduce using rule 76 (multiplicative -> multiplicative Div unary .)
    Div             reduce using rule 76 (multiplicative -> multiplicative Div unary .)
    Mod             reduce using rule 76 (multiplicative -> multiplicative Div unary .)
    Plus            reduce using rule 76 (multiplicative -> multiplicative Div unary .)
    Minus           reduce using rule 76 (multiplicative -> multiplicative Div unary .)
    Less            reduce using rule 76 (multiplicative -> multiplicative Div unary .)
    Greater         reduce using rule 76 (multiplicative -> multiplicative Div unary .)
    LessEqual       reduce using rule 76 (multiplicative -> multiplicative Div unary .)
    GreaterEqual    reduce using rule 76 (multiplicative -> multiplicative Div unary .)
    NotEqual        reduce using rule 76 (multiplicative -> multiplicative Div unary .)
    Equal           reduce using rule 76 (multiplicative -> multiplicative Div unary .)
    BitAnd          reduce using rule 76 (multiplicative -> multiplicative Div unary .)
    Xor             reduce using rule 76 (multiplicative -> multiplicative Div unary .)
    BitOr           reduce using rule 76 (multiplicative -> multiplicative Div unary .)
    And             reduce using rule 76 (multiplicative -> multiplicative Div unary .)
    Question        reduce using rule 76 (multiplicative -> multiplicative Div unary .)
    Or              reduce using rule 76 (multiplicative -> multiplicative Div unary .)
    Semi            reduce using rule 76 (multiplicative -> multiplicative Div unary .)
    RParen          reduce using rule 76 (multiplicative -> multiplicative Div unary .)
    Comma           reduce using rule 76 (multiplicative -> multiplicative Div unary .)
    Colon           reduce using rule 76 (multiplicative -> multiplicative Div unary .)


state 126

    (77) multiplicative -> multiplicative Mod unary .

    Mul             reduce using rule 77 (multiplicative -> multiplicative Mod unary .)
    Div             reduce using rule 77 (multiplicative -> multiplicative Mod unary .)
    Mod             reduce using rule 77 (multiplicative -> multiplicative Mod unary .)
    Plus            reduce using rule 77 (multiplicative -> multiplicative Mod unary .)
    Minus           reduce using rule 77 (multiplicative -> multiplicative Mod unary .)
    Less            reduce using rule 77 (multiplicative -> multiplicative Mod unary .)
    Greater         reduce using rule 77 (multiplicative -> multiplicative Mod unary .)
    LessEqual       reduce using rule 77 (multiplicative -> multiplicative Mod unary .)
    GreaterEqual    reduce using rule 77 (multiplicative -> multiplicative Mod unary .)
    NotEqual        reduce using rule 77 (multiplicative -> multiplicative Mod unary .)
    Equal           reduce using rule 77 (multiplicative -> multiplicative Mod unary .)
    BitAnd          reduce using rule 77 (multiplicative -> multiplicative Mod unary .)
    Xor             reduce using rule 77 (multiplicative -> multiplicative Mod unary .)
    BitOr           reduce using rule 77 (multiplicative -> multiplicative Mod unary .)
    And             reduce using rule 77 (multiplicative -> multiplicative Mod unary .)
    Question        reduce using rule 77 (multiplicative -> multiplicative Mod unary .)
    Or              reduce using rule 77 (multiplicative -> multiplicative Mod unary .)
    Semi            reduce using rule 77 (multiplicative -> multiplicative Mod unary .)
    RParen          reduce using rule 77 (multiplicative -> multiplicative Mod unary .)
    Comma           reduce using rule 77 (multiplicative -> multiplicative Mod unary .)
    Colon           reduce using rule 77 (multiplicative -> multiplicative Mod unary .)


state 127

    (39) declaration -> type Identifier Assign expression .

    Semi            reduce using rule 39 (declaration -> type Identifier Assign expression .)


state 128

    (57) postfix -> Identifier LParen expression_list RParen .

    Mul             reduce using rule 57 (postfix -> Identifier LParen expression_list RParen .)
    Div             reduce using rule 57 (postfix -> Identifier LParen expression_list RParen .)
    Mod             reduce using rule 57 (postfix -> Identifier LParen expression_list RParen .)
    Plus            reduce using rule 57 (postfix -> Identifier LParen expression_list RParen .)
    Minus           reduce using rule 57 (postfix -> Identifier LParen expression_list RParen .)
    Less            reduce using rule 57 (postfix -> Identifier LParen expression_list RParen .)
    Greater         reduce using rule 57 (postfix -> Identifier LParen expression_list RParen .)
    LessEqual       reduce using rule 57 (postfix -> Identifier LParen expression_list RParen .)
    GreaterEqual    reduce using rule 57 (postfix -> Identifier LParen expression_list RParen .)
    NotEqual        reduce using rule 57 (postfix -> Identifier LParen expression_list RParen .)
    Equal           reduce using rule 57 (postfix -> Identifier LParen expression_list RParen .)
    BitAnd          reduce using rule 57 (postfix -> Identifier LParen expression_list RParen .)
    Xor             reduce using rule 57 (postfix -> Identifier LParen expression_list RParen .)
    BitOr           reduce using rule 57 (postfix -> Identifier LParen expression_list RParen .)
    And             reduce using rule 57 (postfix -> Identifier LParen expression_list RParen .)
    Question        reduce using rule 57 (postfix -> Identifier LParen expression_list RParen .)
    Or              reduce using rule 57 (postfix -> Identifier LParen expression_list RParen .)
    Semi            reduce using rule 57 (postfix -> Identifier LParen expression_list RParen .)
    RParen          reduce using rule 57 (postfix -> Identifier LParen expression_list RParen .)
    Comma           reduce using rule 57 (postfix -> Identifier LParen expression_list RParen .)
    Colon           reduce using rule 57 (postfix -> Identifier LParen expression_list RParen .)


state 129

    (58) expression_list -> expression_list Comma . expression
    (40) expression -> . assignment
    (41) assignment -> . conditional
    (61) assignment -> . Identifier Assign expression
    (42) conditional -> . logical_or
    (78) conditional -> . logical_or Question expression Colon conditional
    (43) logical_or -> . logical_and
    (62) logical_or -> . logical_or Or logical_and
    (44) logical_and -> . bit_or
    (63) logical_and -> . logical_and And bit_or
    (45) bit_or -> . xor
    (64) bit_or -> . bit_or BitOr xor
    (46) xor -> . bit_and
    (65) xor -> . xor Xor bit_and
    (47) bit_and -> . equality
    (66) bit_and -> . bit_and BitAnd equality
    (48) equality -> . relational
    (67) equality -> . equality NotEqual relational
    (68) equality -> . equality Equal relational
    (49) relational -> . additive
    (69) relational -> . relational Less additive
    (70) relational -> . relational Greater additive
    (71) relational -> . relational LessEqual additive
    (72) relational -> . relational GreaterEqual additive
    (50) additive -> . multiplicative
    (73) additive -> . additive Plus multiplicative
    (74) additive -> . additive Minus multiplicative
    (51) multiplicative -> . unary
    (75) multiplicative -> . multiplicative Mul unary
    (76) multiplicative -> . multiplicative Div unary
    (77) multiplicative -> . multiplicative Mod unary
    (52) unary -> . postfix
    (54) unary -> . Minus unary
    (55) unary -> . BitNot unary
    (56) unary -> . Not unary
    (53) postfix -> . primary
    (57) postfix -> . Identifier LParen expression_list RParen
    (79) primary -> . Integer
    (80) primary -> . Identifier
    (81) primary -> . LParen expression RParen

    Identifier      shift and go to state 23
    Minus           shift and go to state 53
    BitNot          shift and go to state 56
    Not             shift and go to state 57
    Integer         shift and go to state 59
    LParen          shift and go to state 24

    expression                     shift and go to state 137
    assignment                     shift and go to state 42
    conditional                    shift and go to state 43
    logical_or                     shift and go to state 44
    logical_and                    shift and go to state 45
    bit_or                         shift and go to state 46
    xor                            shift and go to state 47
    bit_and                        shift and go to state 48
    equality                       shift and go to state 49
    relational                     shift and go to state 50
    additive                       shift and go to state 51
    multiplicative                 shift and go to state 52
    unary                          shift and go to state 54
    postfix                        shift and go to state 55
    primary                        shift and go to state 58

state 130

    (20) statement_matched -> If LParen expression RParen . statement_matched Else statement_matched
    (21) statement_unmatched -> If LParen expression RParen . statement_matched Else statement_unmatched
    (22) statement_unmatched -> If LParen expression RParen . statement
    (20) statement_matched -> . If LParen expression RParen statement_matched Else statement_matched
    (23) statement_matched -> . While LParen expression RParen statement_matched
    (25) statement_matched -> . Do statement_matched While LParen expression RParen Semi
    (27) statement_matched -> . For LParen opt_expression Semi opt_expression Semi opt_expression RParen statement_matched
    (28) statement_matched -> . For LParen declaration Semi opt_expression Semi opt_expression RParen statement_matched
    (31) statement_matched -> . Return expression Semi
    (32) statement_matched -> . opt_expression Semi
    (33) statement_matched -> . LBrace block RBrace
    (34) statement_matched -> . Break Semi
    (35) statement_matched -> . Continue Semi
    (18) statement -> . statement_matched
    (19) statement -> . statement_unmatched
    (36) opt_expression -> . expression
    (37) opt_expression -> . empty
    (21) statement_unmatched -> . If LParen expression RParen statement_matched Else statement_unmatched
    (22) statement_unmatched -> . If LParen expression RParen statement
    (24) statement_unmatched -> . While LParen expression RParen statement_unmatched
    (26) statement_unmatched -> . Do statement_unmatched While LParen expression RParen Semi
    (29) statement_unmatched -> . For LParen opt_expression Semi opt_expression Semi opt_expression RParen statement_unmatched
    (30) statement_unmatched -> . For LParen declaration Semi opt_expression Semi opt_expression Semi opt_expression RParen statement_unmatched
    (40) expression -> . assignment
    (1) empty -> .
    (41) assignment -> . conditional
    (61) assignment -> . Identifier Assign expression
    (42) conditional -> . logical_or
    (78) conditional -> . logical_or Question expression Colon conditional
    (43) logical_or -> . logical_and
    (62) logical_or -> . logical_or Or logical_and
    (44) logical_and -> . bit_or
    (63) logical_and -> . logical_and And bit_or
    (45) bit_or -> . xor
    (64) bit_or -> . bit_or BitOr xor
    (46) xor -> . bit_and
    (65) xor -> . xor Xor bit_and
    (47) bit_and -> . equality
    (66) bit_and -> . bit_and BitAnd equality
    (48) equality -> . relational
    (67) equality -> . equality NotEqual relational
    (68) equality -> . equality Equal relational
    (49) relational -> . additive
    (69) relational -> . relational Less additive
    (70) relational -> . relational Greater additive
    (71) relational -> . relational LessEqual additive
    (72) relational -> . relational GreaterEqual additive
    (50) additive -> . multiplicative
    (73) additive -> . additive Plus multiplicative
    (74) additive -> . additive Minus multiplicative
    (51) multiplicative -> . unary
    (75) multiplicative -> . multiplicative Mul unary
    (76) multiplicative -> . multiplicative Div unary
    (77) multiplicative -> . multiplicative Mod unary
    (52) unary -> . postfix
    (54) unary -> . Minus unary
    (55) unary -> . BitNot unary
    (56) unary -> . Not unary
    (53) postfix -> . primary
    (57) postfix -> . Identifier LParen expression_list RParen
    (79) primary -> . Integer
    (80) primary -> . Identifier
    (81) primary -> . LParen expression RParen

    If              shift and go to state 33
    While           shift and go to state 34
    Do              shift and go to state 35
    For             shift and go to state 36
    Return          shift and go to state 38
    LBrace          shift and go to state 25
    Break           shift and go to state 39
    Continue        shift and go to state 40
    Semi            reduce using rule 1 (empty -> .)
    Identifier      shift and go to state 23
    Minus           shift and go to state 53
    BitNot          shift and go to state 56
    Not             shift and go to state 57
    Integer         shift and go to state 59
    LParen          shift and go to state 24

    expression                     shift and go to state 32
    statement_matched              shift and go to state 138
    statement_unmatched            shift and go to state 31
    statement                      shift and go to state 139
    opt_expression                 shift and go to state 37
    empty                          shift and go to state 41
    assignment                     shift and go to state 42
    conditional                    shift and go to state 43
    logical_or                     shift and go to state 44
    logical_and                    shift and go to state 45
    bit_or                         shift and go to state 46
    xor                            shift and go to state 47
    bit_and                        shift and go to state 48
    equality                       shift and go to state 49
    relational                     shift and go to state 50
    additive                       shift and go to state 51
    multiplicative                 shift and go to state 52
    unary                          shift and go to state 54
    postfix                        shift and go to state 55
    primary                        shift and go to state 58

state 131

    (23) statement_matched -> While LParen expression RParen . statement_matched
    (24) statement_unmatched -> While LParen expression RParen . statement_unmatched
    (20) statement_matched -> . If LParen expression RParen statement_matched Else statement_matched
    (23) statement_matched -> . While LParen expression RParen statement_matched
    (25) statement_matched -> . Do statement_matched While LParen expression RParen Semi
    (27) statement_matched -> . For LParen opt_expression Semi opt_expression Semi opt_expression RParen statement_matched
    (28) statement_matched -> . For LParen declaration Semi opt_expression Semi opt_expression RParen statement_matched
    (31) statement_matched -> . Return expression Semi
    (32) statement_matched -> . opt_expression Semi
    (33) statement_matched -> . LBrace block RBrace
    (34) statement_matched -> . Break Semi
    (35) statement_matched -> . Continue Semi
    (21) statement_unmatched -> . If LParen expression RParen statement_matched Else statement_unmatched
    (22) statement_unmatched -> . If LParen expression RParen statement
    (24) statement_unmatched -> . While LParen expression RParen statement_unmatched
    (26) statement_unmatched -> . Do statement_unmatched While LParen expression RParen Semi
    (29) statement_unmatched -> . For LParen opt_expression Semi opt_expression Semi opt_expression RParen statement_unmatched
    (30) statement_unmatched -> . For LParen declaration Semi opt_expression Semi opt_expression Semi opt_expression RParen statement_unmatched
    (36) opt_expression -> . expression
    (37) opt_expression -> . empty
    (40) expression -> . assignment
    (1) empty -> .
    (41) assignment -> . conditional
    (61) assignment -> . Identifier Assign expression
    (42) conditional -> . logical_or
    (78) conditional -> . logical_or Question expression Colon conditional
    (43) logical_or -> . logical_and
    (62) logical_or -> . logical_or Or logical_and
    (44) logical_and -> . bit_or
    (63) logical_and -> . logical_and And bit_or
    (45) bit_or -> . xor
    (64) bit_or -> . bit_or BitOr xor
    (46) xor -> . bit_and
    (65) xor -> . xor Xor bit_and
    (47) bit_and -> . equality
    (66) bit_and -> . bit_and BitAnd equality
    (48) equality -> . relational
    (67) equality -> . equality NotEqual relational
    (68) equality -> . equality Equal relational
    (49) relational -> . additive
    (69) relational -> . relational Less additive
    (70) relational -> . relational Greater additive
    (71) relational -> . relational LessEqual additive
    (72) relational -> . relational GreaterEqual additive
    (50) additive -> . multiplicative
    (73) additive -> . additive Plus multiplicative
    (74) additive -> . additive Minus multiplicative
    (51) multiplicative -> . unary
    (75) multiplicative -> . multiplicative Mul unary
    (76) multiplicative -> . multiplicative Div unary
    (77) multiplicative -> . multiplicative Mod unary
    (52) unary -> . postfix
    (54) unary -> . Minus unary
    (55) unary -> . BitNot unary
    (56) unary -> . Not unary
    (53) postfix -> . primary
    (57) postfix -> . Identifier LParen expression_list RParen
    (79) primary -> . Integer
    (80) primary -> . Identifier
    (81) primary -> . LParen expression RParen

    If              shift and go to state 33
    While           shift and go to state 34
    Do              shift and go to state 35
    For             shift and go to state 36
    Return          shift and go to state 38
    LBrace          shift and go to state 25
    Break           shift and go to state 39
    Continue        shift and go to state 40
    Semi            reduce using rule 1 (empty -> .)
    Identifier      shift and go to state 23
    Minus           shift and go to state 53
    BitNot          shift and go to state 56
    Not             shift and go to state 57
    Integer         shift and go to state 59
    LParen          shift and go to state 24

    expression                     shift and go to state 32
    statement_matched              shift and go to state 140
    statement_unmatched            shift and go to state 141
    opt_expression                 shift and go to state 37
    empty                          shift and go to state 41
    assignment                     shift and go to state 42
    conditional                    shift and go to state 43
    logical_or                     shift and go to state 44
    logical_and                    shift and go to state 45
    bit_or                         shift and go to state 46
    xor                            shift and go to state 47
    bit_and                        shift and go to state 48
    equality                       shift and go to state 49
    relational                     shift and go to state 50
    additive                       shift and go to state 51
    multiplicative                 shift and go to state 52
    unary                          shift and go to state 54
    postfix                        shift and go to state 55
    primary                        shift and go to state 58

state 132

    (25) statement_matched -> Do statement_matched While LParen . expression RParen Semi
    (40) expression -> . assignment
    (41) assignment -> . conditional
    (61) assignment -> . Identifier Assign expression
    (42) conditional -> . logical_or
    (78) conditional -> . logical_or Question expression Colon conditional
    (43) logical_or -> . logical_and
    (62) logical_or -> . logical_or Or logical_and
    (44) logical_and -> . bit_or
    (63) logical_and -> . logical_and And bit_or
    (45) bit_or -> . xor
    (64) bit_or -> . bit_or BitOr xor
    (46) xor -> . bit_and
    (65) xor -> . xor Xor bit_and
    (47) bit_and -> . equality
    (66) bit_and -> . bit_and BitAnd equality
    (48) equality -> . relational
    (67) equality -> . equality NotEqual relational
    (68) equality -> . equality Equal relational
    (49) relational -> . additive
    (69) relational -> . relational Less additive
    (70) relational -> . relational Greater additive
    (71) relational -> . relational LessEqual additive
    (72) relational -> . relational GreaterEqual additive
    (50) additive -> . multiplicative
    (73) additive -> . additive Plus multiplicative
    (74) additive -> . additive Minus multiplicative
    (51) multiplicative -> . unary
    (75) multiplicative -> . multiplicative Mul unary
    (76) multiplicative -> . multiplicative Div unary
    (77) multiplicative -> . multiplicative Mod unary
    (52) unary -> . postfix
    (54) unary -> . Minus unary
    (55) unary -> . BitNot unary
    (56) unary -> . Not unary
    (53) postfix -> . primary
    (57) postfix -> . Identifier LParen expression_list RParen
    (79) primary -> . Integer
    (80) primary -> . Identifier
    (81) primary -> . LParen expression RParen

    Identifier      shift and go to state 23
    Minus           shift and go to state 53
    BitNot          shift and go to state 56
    Not             shift and go to state 57
    Integer         shift and go to state 59
    LParen          shift and go to state 24

    expression                     shift and go to state 142
    assignment                     shift and go to state 42
    conditional                    shift and go to state 43
    logical_or                     shift and go to state 44
    logical_and                    shift and go to state 45
    bit_or                         shift and go to state 46
    xor                            shift and go to state 47
    bit_and                        shift and go to state 48
    equality                       shift and go to state 49
    relational                     shift and go to state 50
    additive                       shift and go to state 51
    multiplicative                 shift and go to state 52
    unary                          shift and go to state 54
    postfix                        shift and go to state 55
    primary                        shift and go to state 58

state 133

    (26) statement_unmatched -> Do statement_unmatched While LParen . expression RParen Semi
    (40) expression -> . assignment
    (41) assignment -> . conditional
    (61) assignment -> . Identifier Assign expression
    (42) conditional -> . logical_or
    (78) conditional -> . logical_or Question expression Colon conditional
    (43) logical_or -> . logical_and
    (62) logical_or -> . logical_or Or logical_and
    (44) logical_and -> . bit_or
    (63) logical_and -> . logical_and And bit_or
    (45) bit_or -> . xor
    (64) bit_or -> . bit_or BitOr xor
    (46) xor -> . bit_and
    (65) xor -> . xor Xor bit_and
    (47) bit_and -> . equality
    (66) bit_and -> . bit_and BitAnd equality
    (48) equality -> . relational
    (67) equality -> . equality NotEqual relational
    (68) equality -> . equality Equal relational
    (49) relational -> . additive
    (69) relational -> . relational Less additive
    (70) relational -> . relational Greater additive
    (71) relational -> . relational LessEqual additive
    (72) relational -> . relational GreaterEqual additive
    (50) additive -> . multiplicative
    (73) additive -> . additive Plus multiplicative
    (74) additive -> . additive Minus multiplicative
    (51) multiplicative -> . unary
    (75) multiplicative -> . multiplicative Mul unary
    (76) multiplicative -> . multiplicative Div unary
    (77) multiplicative -> . multiplicative Mod unary
    (52) unary -> . postfix
    (54) unary -> . Minus unary
    (55) unary -> . BitNot unary
    (56) unary -> . Not unary
    (53) postfix -> . primary
    (57) postfix -> . Identifier LParen expression_list RParen
    (79) primary -> . Integer
    (80) primary -> . Identifier
    (81) primary -> . LParen expression RParen

    Identifier      shift and go to state 23
    Minus           shift and go to state 53
    BitNot          shift and go to state 56
    Not             shift and go to state 57
    Integer         shift and go to state 59
    LParen          shift and go to state 24

    expression                     shift and go to state 143
    assignment                     shift and go to state 42
    conditional                    shift and go to state 43
    logical_or                     shift and go to state 44
    logical_and                    shift and go to state 45
    bit_or                         shift and go to state 46
    xor                            shift and go to state 47
    bit_and                        shift and go to state 48
    equality                       shift and go to state 49
    relational                     shift and go to state 50
    additive                       shift and go to state 51
    multiplicative                 shift and go to state 52
    unary                          shift and go to state 54
    postfix                        shift and go to state 55
    primary                        shift and go to state 58

state 134

    (27) statement_matched -> For LParen opt_expression Semi . opt_expression Semi opt_expression RParen statement_matched
    (29) statement_unmatched -> For LParen opt_expression Semi . opt_expression Semi opt_expression RParen statement_unmatched
    (36) opt_expression -> . expression
    (37) opt_expression -> . empty
    (40) expression -> . assignment
    (1) empty -> .
    (41) assignment -> . conditional
    (61) assignment -> . Identifier Assign expression
    (42) conditional -> . logical_or
    (78) conditional -> . logical_or Question expression Colon conditional
    (43) logical_or -> . logical_and
    (62) logical_or -> . logical_or Or logical_and
    (44) logical_and -> . bit_or
    (63) logical_and -> . logical_and And bit_or
    (45) bit_or -> . xor
    (64) bit_or -> . bit_or BitOr xor
    (46) xor -> . bit_and
    (65) xor -> . xor Xor bit_and
    (47) bit_and -> . equality
    (66) bit_and -> . bit_and BitAnd equality
    (48) equality -> . relational
    (67) equality -> . equality NotEqual relational
    (68) equality -> . equality Equal relational
    (49) relational -> . additive
    (69) relational -> . relational Less additive
    (70) relational -> . relational Greater additive
    (71) relational -> . relational LessEqual additive
    (72) relational -> . relational GreaterEqual additive
    (50) additive -> . multiplicative
    (73) additive -> . additive Plus multiplicative
    (74) additive -> . additive Minus multiplicative
    (51) multiplicative -> . unary
    (75) multiplicative -> . multiplicative Mul unary
    (76) multiplicative -> . multiplicative Div unary
    (77) multiplicative -> . multiplicative Mod unary
    (52) unary -> . postfix
    (54) unary -> . Minus unary
    (55) unary -> . BitNot unary
    (56) unary -> . Not unary
    (53) postfix -> . primary
    (57) postfix -> . Identifier LParen expression_list RParen
    (79) primary -> . Integer
    (80) primary -> . Identifier
    (81) primary -> . LParen expression RParen

    Semi            reduce using rule 1 (empty -> .)
    Identifier      shift and go to state 23
    Minus           shift and go to state 53
    BitNot          shift and go to state 56
    Not             shift and go to state 57
    Integer         shift and go to state 59
    LParen          shift and go to state 24

    opt_expression                 shift and go to state 144
    expression                     shift and go to state 32
    empty                          shift and go to state 41
    assignment                     shift and go to state 42
    conditional                    shift and go to state 43
    logical_or                     shift and go to state 44
    logical_and                    shift and go to state 45
    bit_or                         shift and go to state 46
    xor                            shift and go to state 47
    bit_and                        shift and go to state 48
    equality                       shift and go to state 49
    relational                     shift and go to state 50
    additive                       shift and go to state 51
    multiplicative                 shift and go to state 52
    unary                          shift and go to state 54
    postfix                        shift and go to state 55
    primary                        shift and go to state 58

state 135

    (28) statement_matched -> For LParen declaration Semi . opt_expression Semi opt_expression RParen statement_matched
    (30) statement_unmatched -> For LParen declaration Semi . opt_expression Semi opt_expression Semi opt_expression RParen statement_unmatched
    (36) opt_expression -> . expression
    (37) opt_expression -> . empty
    (40) expression -> . assignment
    (1) empty -> .
    (41) assignment -> . conditional
    (61) assignment -> . Identifier Assign expression
    (42) conditional -> . logical_or
    (78) conditional -> . logical_or Question expression Colon conditional
    (43) logical_or -> . logical_and
    (62) logical_or -> . logical_or Or logical_and
    (44) logical_and -> . bit_or
    (63) logical_and -> . logical_and And bit_or
    (45) bit_or -> . xor
    (64) bit_or -> . bit_or BitOr xor
    (46) xor -> . bit_and
    (65) xor -> . xor Xor bit_and
    (47) bit_and -> . equality
    (66) bit_and -> . bit_and BitAnd equality
    (48) equality -> . relational
    (67) equality -> . equality NotEqual relational
    (68) equality -> . equality Equal relational
    (49) relational -> . additive
    (69) relational -> . relational Less additive
    (70) relational -> . relational Greater additive
    (71) relational -> . relational LessEqual additive
    (72) relational -> . relational GreaterEqual additive
    (50) additive -> . multiplicative
    (73) additive -> . additive Plus multiplicative
    (74) additive -> . additive Minus multiplicative
    (51) multiplicative -> . unary
    (75) multiplicative -> . multiplicative Mul unary
    (76) multiplicative -> . multiplicative Div unary
    (77) multiplicative -> . multiplicative Mod unary
    (52) unary -> . postfix
    (54) unary -> . Minus unary
    (55) unary -> . BitNot unary
    (56) unary -> . Not unary
    (53) postfix -> . primary
    (57) postfix -> . Identifier LParen expression_list RParen
    (79) primary -> . Integer
    (80) primary -> . Identifier
    (81) primary -> . LParen expression RParen

    Semi            reduce using rule 1 (empty -> .)
    Identifier      shift and go to state 23
    Minus           shift and go to state 53
    BitNot          shift and go to state 56
    Not             shift and go to state 57
    Integer         shift and go to state 59
    LParen          shift and go to state 24

    opt_expression                 shift and go to state 145
    expression                     shift and go to state 32
    empty                          shift and go to state 41
    assignment                     shift and go to state 42
    conditional                    shift and go to state 43
    logical_or                     shift and go to state 44
    logical_and                    shift and go to state 45
    bit_or                         shift and go to state 46
    xor                            shift and go to state 47
    bit_and                        shift and go to state 48
    equality                       shift and go to state 49
    relational                     shift and go to state 50
    additive                       shift and go to state 51
    multiplicative                 shift and go to state 52
    unary                          shift and go to state 54
    postfix                        shift and go to state 55
    primary                        shift and go to state 58

state 136

    (78) conditional -> logical_or Question expression Colon . conditional
    (42) conditional -> . logical_or
    (78) conditional -> . logical_or Question expression Colon conditional
    (43) logical_or -> . logical_and
    (62) logical_or -> . logical_or Or logical_and
    (44) logical_and -> . bit_or
    (63) logical_and -> . logical_and And bit_or
    (45) bit_or -> . xor
    (64) bit_or -> . bit_or BitOr xor
    (46) xor -> . bit_and
    (65) xor -> . xor Xor bit_and
    (47) bit_and -> . equality
    (66) bit_and -> . bit_and BitAnd equality
    (48) equality -> . relational
    (67) equality -> . equality NotEqual relational
    (68) equality -> . equality Equal relational
    (49) relational -> . additive
    (69) relational -> . relational Less additive
    (70) relational -> . relational Greater additive
    (71) relational -> . relational LessEqual additive
    (72) relational -> . relational GreaterEqual additive
    (50) additive -> . multiplicative
    (73) additive -> . additive Plus multiplicative
    (74) additive -> . additive Minus multiplicative
    (51) multiplicative -> . unary
    (75) multiplicative -> . multiplicative Mul unary
    (76) multiplicative -> . multiplicative Div unary
    (77) multiplicative -> . multiplicative Mod unary
    (52) unary -> . postfix
    (54) unary -> . Minus unary
    (55) unary -> . BitNot unary
    (56) unary -> . Not unary
    (53) postfix -> . primary
    (57) postfix -> . Identifier LParen expression_list RParen
    (79) primary -> . Integer
    (80) primary -> . Identifier
    (81) primary -> . LParen expression RParen

    Minus           shift and go to state 53
    BitNot          shift and go to state 56
    Not             shift and go to state 57
    Identifier      shift and go to state 93
    Integer         shift and go to state 59
    LParen          shift and go to state 24

    logical_or                     shift and go to state 44
    conditional                    shift and go to state 146
    logical_and                    shift and go to state 45
    bit_or                         shift and go to state 46
    xor                            shift and go to state 47
    bit_and                        shift and go to state 48
    equality                       shift and go to state 49
    relational                     shift and go to state 50
    additive                       shift and go to state 51
    multiplicative                 shift and go to state 52
    unary                          shift and go to state 54
    postfix                        shift and go to state 55
    primary                        shift and go to state 58

state 137

    (58) expression_list -> expression_list Comma expression .

    RParen          reduce using rule 58 (expression_list -> expression_list Comma expression .)
    Comma           reduce using rule 58 (expression_list -> expression_list Comma expression .)


state 138

    (20) statement_matched -> If LParen expression RParen statement_matched . Else statement_matched
    (21) statement_unmatched -> If LParen expression RParen statement_matched . Else statement_unmatched
    (18) statement -> statement_matched .

    Else            shift and go to state 147
    RBrace          reduce using rule 18 (statement -> statement_matched .)
    If              reduce using rule 18 (statement -> statement_matched .)
    While           reduce using rule 18 (statement -> statement_matched .)
    Do              reduce using rule 18 (statement -> statement_matched .)
    For             reduce using rule 18 (statement -> statement_matched .)
    Return          reduce using rule 18 (statement -> statement_matched .)
    LBrace          reduce using rule 18 (statement -> statement_matched .)
    Break           reduce using rule 18 (statement -> statement_matched .)
    Continue        reduce using rule 18 (statement -> statement_matched .)
    Int             reduce using rule 18 (statement -> statement_matched .)
    Identifier      reduce using rule 18 (statement -> statement_matched .)
    Minus           reduce using rule 18 (statement -> statement_matched .)
    BitNot          reduce using rule 18 (statement -> statement_matched .)
    Not             reduce using rule 18 (statement -> statement_matched .)
    Integer         reduce using rule 18 (statement -> statement_matched .)
    LParen          reduce using rule 18 (statement -> statement_matched .)
    Semi            reduce using rule 18 (statement -> statement_matched .)


state 139

    (22) statement_unmatched -> If LParen expression RParen statement .

    RBrace          reduce using rule 22 (statement_unmatched -> If LParen expression RParen statement .)
    If              reduce using rule 22 (statement_unmatched -> If LParen expression RParen statement .)
    While           reduce using rule 22 (statement_unmatched -> If LParen expression RParen statement .)
    Do              reduce using rule 22 (statement_unmatched -> If LParen expression RParen statement .)
    For             reduce using rule 22 (statement_unmatched -> If LParen expression RParen statement .)
    Return          reduce using rule 22 (statement_unmatched -> If LParen expression RParen statement .)
    LBrace          reduce using rule 22 (statement_unmatched -> If LParen expression RParen statement .)
    Break           reduce using rule 22 (statement_unmatched -> If LParen expression RParen statement .)
    Continue        reduce using rule 22 (statement_unmatched -> If LParen expression RParen statement .)
    Int             reduce using rule 22 (statement_unmatched -> If LParen expression RParen statement .)
    Identifier      reduce using rule 22 (statement_unmatched -> If LParen expression RParen statement .)
    Minus           reduce using rule 22 (statement_unmatched -> If LParen expression RParen statement .)
    BitNot          reduce using rule 22 (statement_unmatched -> If LParen expression RParen statement .)
    Not             reduce using rule 22 (statement_unmatched -> If LParen expression RParen statement .)
    Integer         reduce using rule 22 (statement_unmatched -> If LParen expression RParen statement .)
    LParen          reduce using rule 22 (statement_unmatched -> If LParen expression RParen statement .)
    Semi            reduce using rule 22 (statement_unmatched -> If LParen expression RParen statement .)


state 140

    (23) statement_matched -> While LParen expression RParen statement_matched .

    RBrace          reduce using rule 23 (statement_matched -> While LParen expression RParen statement_matched .)
    If              reduce using rule 23 (statement_matched -> While LParen expression RParen statement_matched .)
    While           reduce using rule 23 (statement_matched -> While LParen expression RParen statement_matched .)
    Do              reduce using rule 23 (statement_matched -> While LParen expression RParen statement_matched .)
    For             reduce using rule 23 (statement_matched -> While LParen expression RParen statement_matched .)
    Return          reduce using rule 23 (statement_matched -> While LParen expression RParen statement_matched .)
    LBrace          reduce using rule 23 (statement_matched -> While LParen expression RParen statement_matched .)
    Break           reduce using rule 23 (statement_matched -> While LParen expression RParen statement_matched .)
    Continue        reduce using rule 23 (statement_matched -> While LParen expression RParen statement_matched .)
    Int             reduce using rule 23 (statement_matched -> While LParen expression RParen statement_matched .)
    Identifier      reduce using rule 23 (statement_matched -> While LParen expression RParen statement_matched .)
    Minus           reduce using rule 23 (statement_matched -> While LParen expression RParen statement_matched .)
    BitNot          reduce using rule 23 (statement_matched -> While LParen expression RParen statement_matched .)
    Not             reduce using rule 23 (statement_matched -> While LParen expression RParen statement_matched .)
    Integer         reduce using rule 23 (statement_matched -> While LParen expression RParen statement_matched .)
    LParen          reduce using rule 23 (statement_matched -> While LParen expression RParen statement_matched .)
    Semi            reduce using rule 23 (statement_matched -> While LParen expression RParen statement_matched .)
    Else            reduce using rule 23 (statement_matched -> While LParen expression RParen statement_matched .)


state 141

    (24) statement_unmatched -> While LParen expression RParen statement_unmatched .

    RBrace          reduce using rule 24 (statement_unmatched -> While LParen expression RParen statement_unmatched .)
    If              reduce using rule 24 (statement_unmatched -> While LParen expression RParen statement_unmatched .)
    While           reduce using rule 24 (statement_unmatched -> While LParen expression RParen statement_unmatched .)
    Do              reduce using rule 24 (statement_unmatched -> While LParen expression RParen statement_unmatched .)
    For             reduce using rule 24 (statement_unmatched -> While LParen expression RParen statement_unmatched .)
    Return          reduce using rule 24 (statement_unmatched -> While LParen expression RParen statement_unmatched .)
    LBrace          reduce using rule 24 (statement_unmatched -> While LParen expression RParen statement_unmatched .)
    Break           reduce using rule 24 (statement_unmatched -> While LParen expression RParen statement_unmatched .)
    Continue        reduce using rule 24 (statement_unmatched -> While LParen expression RParen statement_unmatched .)
    Int             reduce using rule 24 (statement_unmatched -> While LParen expression RParen statement_unmatched .)
    Identifier      reduce using rule 24 (statement_unmatched -> While LParen expression RParen statement_unmatched .)
    Minus           reduce using rule 24 (statement_unmatched -> While LParen expression RParen statement_unmatched .)
    BitNot          reduce using rule 24 (statement_unmatched -> While LParen expression RParen statement_unmatched .)
    Not             reduce using rule 24 (statement_unmatched -> While LParen expression RParen statement_unmatched .)
    Integer         reduce using rule 24 (statement_unmatched -> While LParen expression RParen statement_unmatched .)
    LParen          reduce using rule 24 (statement_unmatched -> While LParen expression RParen statement_unmatched .)
    Semi            reduce using rule 24 (statement_unmatched -> While LParen expression RParen statement_unmatched .)


state 142

    (25) statement_matched -> Do statement_matched While LParen expression . RParen Semi

    RParen          shift and go to state 148


state 143

    (26) statement_unmatched -> Do statement_unmatched While LParen expression . RParen Semi

    RParen          shift and go to state 149


state 144

    (27) statement_matched -> For LParen opt_expression Semi opt_expression . Semi opt_expression RParen statement_matched
    (29) statement_unmatched -> For LParen opt_expression Semi opt_expression . Semi opt_expression RParen statement_unmatched

    Semi            shift and go to state 150


state 145

    (28) statement_matched -> For LParen declaration Semi opt_expression . Semi opt_expression RParen statement_matched
    (30) statement_unmatched -> For LParen declaration Semi opt_expression . Semi opt_expression Semi opt_expression RParen statement_unmatched

    Semi            shift and go to state 151


state 146

    (78) conditional -> logical_or Question expression Colon conditional .

    Semi            reduce using rule 78 (conditional -> logical_or Question expression Colon conditional .)
    RParen          reduce using rule 78 (conditional -> logical_or Question expression Colon conditional .)
    Comma           reduce using rule 78 (conditional -> logical_or Question expression Colon conditional .)
    Colon           reduce using rule 78 (conditional -> logical_or Question expression Colon conditional .)


state 147

    (20) statement_matched -> If LParen expression RParen statement_matched Else . statement_matched
    (21) statement_unmatched -> If LParen expression RParen statement_matched Else . statement_unmatched
    (20) statement_matched -> . If LParen expression RParen statement_matched Else statement_matched
    (23) statement_matched -> . While LParen expression RParen statement_matched
    (25) statement_matched -> . Do statement_matched While LParen expression RParen Semi
    (27) statement_matched -> . For LParen opt_expression Semi opt_expression Semi opt_expression RParen statement_matched
    (28) statement_matched -> . For LParen declaration Semi opt_expression Semi opt_expression RParen statement_matched
    (31) statement_matched -> . Return expression Semi
    (32) statement_matched -> . opt_expression Semi
    (33) statement_matched -> . LBrace block RBrace
    (34) statement_matched -> . Break Semi
    (35) statement_matched -> . Continue Semi
    (21) statement_unmatched -> . If LParen expression RParen statement_matched Else statement_unmatched
    (22) statement_unmatched -> . If LParen expression RParen statement
    (24) statement_unmatched -> . While LParen expression RParen statement_unmatched
    (26) statement_unmatched -> . Do statement_unmatched While LParen expression RParen Semi
    (29) statement_unmatched -> . For LParen opt_expression Semi opt_expression Semi opt_expression RParen statement_unmatched
    (30) statement_unmatched -> . For LParen declaration Semi opt_expression Semi opt_expression Semi opt_expression RParen statement_unmatched
    (36) opt_expression -> . expression
    (37) opt_expression -> . empty
    (40) expression -> . assignment
    (1) empty -> .
    (41) assignment -> . conditional
    (61) assignment -> . Identifier Assign expression
    (42) conditional -> . logical_or
    (78) conditional -> . logical_or Question expression Colon conditional
    (43) logical_or -> . logical_and
    (62) logical_or -> . logical_or Or logical_and
    (44) logical_and -> . bit_or
    (63) logical_and -> . logical_and And bit_or
    (45) bit_or -> . xor
    (64) bit_or -> . bit_or BitOr xor
    (46) xor -> . bit_and
    (65) xor -> . xor Xor bit_and
    (47) bit_and -> . equality
    (66) bit_and -> . bit_and BitAnd equality
    (48) equality -> . relational
    (67) equality -> . equality NotEqual relational
    (68) equality -> . equality Equal relational
    (49) relational -> . additive
    (69) relational -> . relational Less additive
    (70) relational -> . relational Greater additive
    (71) relational -> . relational LessEqual additive
    (72) relational -> . relational GreaterEqual additive
    (50) additive -> . multiplicative
    (73) additive -> . additive Plus multiplicative
    (74) additive -> . additive Minus multiplicative
    (51) multiplicative -> . unary
    (75) multiplicative -> . multiplicative Mul unary
    (76) multiplicative -> . multiplicative Div unary
    (77) multiplicative -> . multiplicative Mod unary
    (52) unary -> . postfix
    (54) unary -> . Minus unary
    (55) unary -> . BitNot unary
    (56) unary -> . Not unary
    (53) postfix -> . primary
    (57) postfix -> . Identifier LParen expression_list RParen
    (79) primary -> . Integer
    (80) primary -> . Identifier
    (81) primary -> . LParen expression RParen

    If              shift and go to state 33
    While           shift and go to state 34
    Do              shift and go to state 35
    For             shift and go to state 36
    Return          shift and go to state 38
    LBrace          shift and go to state 25
    Break           shift and go to state 39
    Continue        shift and go to state 40
    Semi            reduce using rule 1 (empty -> .)
    Identifier      shift and go to state 23
    Minus           shift and go to state 53
    BitNot          shift and go to state 56
    Not             shift and go to state 57
    Integer         shift and go to state 59
    LParen          shift and go to state 24

    expression                     shift and go to state 32
    statement_matched              shift and go to state 152
    statement_unmatched            shift and go to state 153
    opt_expression                 shift and go to state 37
    empty                          shift and go to state 41
    assignment                     shift and go to state 42
    conditional                    shift and go to state 43
    logical_or                     shift and go to state 44
    logical_and                    shift and go to state 45
    bit_or                         shift and go to state 46
    xor                            shift and go to state 47
    bit_and                        shift and go to state 48
    equality                       shift and go to state 49
    relational                     shift and go to state 50
    additive                       shift and go to state 51
    multiplicative                 shift and go to state 52
    unary                          shift and go to state 54
    postfix                        shift and go to state 55
    primary                        shift and go to state 58

state 148

    (25) statement_matched -> Do statement_matched While LParen expression RParen . Semi

    Semi            shift and go to state 154


state 149

    (26) statement_unmatched -> Do statement_unmatched While LParen expression RParen . Semi

    Semi            shift and go to state 155


state 150

    (27) statement_matched -> For LParen opt_expression Semi opt_expression Semi . opt_expression RParen statement_matched
    (29) statement_unmatched -> For LParen opt_expression Semi opt_expression Semi . opt_expression RParen statement_unmatched
    (36) opt_expression -> . expression
    (37) opt_expression -> . empty
    (40) expression -> . assignment
    (1) empty -> .
    (41) assignment -> . conditional
    (61) assignment -> . Identifier Assign expression
    (42) conditional -> . logical_or
    (78) conditional -> . logical_or Question expression Colon conditional
    (43) logical_or -> . logical_and
    (62) logical_or -> . logical_or Or logical_and
    (44) logical_and -> . bit_or
    (63) logical_and -> . logical_and And bit_or
    (45) bit_or -> . xor
    (64) bit_or -> . bit_or BitOr xor
    (46) xor -> . bit_and
    (65) xor -> . xor Xor bit_and
    (47) bit_and -> . equality
    (66) bit_and -> . bit_and BitAnd equality
    (48) equality -> . relational
    (67) equality -> . equality NotEqual relational
    (68) equality -> . equality Equal relational
    (49) relational -> . additive
    (69) relational -> . relational Less additive
    (70) relational -> . relational Greater additive
    (71) relational -> . relational LessEqual additive
    (72) relational -> . relational GreaterEqual additive
    (50) additive -> . multiplicative
    (73) additive -> . additive Plus multiplicative
    (74) additive -> . additive Minus multiplicative
    (51) multiplicative -> . unary
    (75) multiplicative -> . multiplicative Mul unary
    (76) multiplicative -> . multiplicative Div unary
    (77) multiplicative -> . multiplicative Mod unary
    (52) unary -> . postfix
    (54) unary -> . Minus unary
    (55) unary -> . BitNot unary
    (56) unary -> . Not unary
    (53) postfix -> . primary
    (57) postfix -> . Identifier LParen expression_list RParen
    (79) primary -> . Integer
    (80) primary -> . Identifier
    (81) primary -> . LParen expression RParen

    RParen          reduce using rule 1 (empty -> .)
    Identifier      shift and go to state 23
    Minus           shift and go to state 53
    BitNot          shift and go to state 56
    Not             shift and go to state 57
    Integer         shift and go to state 59
    LParen          shift and go to state 24

    opt_expression                 shift and go to state 156
    expression                     shift and go to state 32
    empty                          shift and go to state 41
    assignment                     shift and go to state 42
    conditional                    shift and go to state 43
    logical_or                     shift and go to state 44
    logical_and                    shift and go to state 45
    bit_or                         shift and go to state 46
    xor                            shift and go to state 47
    bit_and                        shift and go to state 48
    equality                       shift and go to state 49
    relational                     shift and go to state 50
    additive                       shift and go to state 51
    multiplicative                 shift and go to state 52
    unary                          shift and go to state 54
    postfix                        shift and go to state 55
    primary                        shift and go to state 58

state 151

    (28) statement_matched -> For LParen declaration Semi opt_expression Semi . opt_expression RParen statement_matched
    (30) statement_unmatched -> For LParen declaration Semi opt_expression Semi . opt_expression Semi opt_expression RParen statement_unmatched
    (36) opt_expression -> . expression
    (37) opt_expression -> . empty
    (40) expression -> . assignment
    (1) empty -> .
    (41) assignment -> . conditional
    (61) assignment -> . Identifier Assign expression
    (42) conditional -> . logical_or
    (78) conditional -> . logical_or Question expression Colon conditional
    (43) logical_or -> . logical_and
    (62) logical_or -> . logical_or Or logical_and
    (44) logical_and -> . bit_or
    (63) logical_and -> . logical_and And bit_or
    (45) bit_or -> . xor
    (64) bit_or -> . bit_or BitOr xor
    (46) xor -> . bit_and
    (65) xor -> . xor Xor bit_and
    (47) bit_and -> . equality
    (66) bit_and -> . bit_and BitAnd equality
    (48) equality -> . relational
    (67) equality -> . equality NotEqual relational
    (68) equality -> . equality Equal relational
    (49) relational -> . additive
    (69) relational -> . relational Less additive
    (70) relational -> . relational Greater additive
    (71) relational -> . relational LessEqual additive
    (72) relational -> . relational GreaterEqual additive
    (50) additive -> . multiplicative
    (73) additive -> . additive Plus multiplicative
    (74) additive -> . additive Minus multiplicative
    (51) multiplicative -> . unary
    (75) multiplicative -> . multiplicative Mul unary
    (76) multiplicative -> . multiplicative Div unary
    (77) multiplicative -> . multiplicative Mod unary
    (52) unary -> . postfix
    (54) unary -> . Minus unary
    (55) unary -> . BitNot unary
    (56) unary -> . Not unary
    (53) postfix -> . primary
    (57) postfix -> . Identifier LParen expression_list RParen
    (79) primary -> . Integer
    (80) primary -> . Identifier
    (81) primary -> . LParen expression RParen

    RParen          reduce using rule 1 (empty -> .)
    Semi            reduce using rule 1 (empty -> .)
    Identifier      shift and go to state 23
    Minus           shift and go to state 53
    BitNot          shift and go to state 56
    Not             shift and go to state 57
    Integer         shift and go to state 59
    LParen          shift and go to state 24

    opt_expression                 shift and go to state 157
    expression                     shift and go to state 32
    empty                          shift and go to state 41
    assignment                     shift and go to state 42
    conditional                    shift and go to state 43
    logical_or                     shift and go to state 44
    logical_and                    shift and go to state 45
    bit_or                         shift and go to state 46
    xor                            shift and go to state 47
    bit_and                        shift and go to state 48
    equality                       shift and go to state 49
    relational                     shift and go to state 50
    additive                       shift and go to state 51
    multiplicative                 shift and go to state 52
    unary                          shift and go to state 54
    postfix                        shift and go to state 55
    primary                        shift and go to state 58

state 152

    (20) statement_matched -> If LParen expression RParen statement_matched Else statement_matched .

    RBrace          reduce using rule 20 (statement_matched -> If LParen expression RParen statement_matched Else statement_matched .)
    If              reduce using rule 20 (statement_matched -> If LParen expression RParen statement_matched Else statement_matched .)
    While           reduce using rule 20 (statement_matched -> If LParen expression RParen statement_matched Else statement_matched .)
    Do              reduce using rule 20 (statement_matched -> If LParen expression RParen statement_matched Else statement_matched .)
    For             reduce using rule 20 (statement_matched -> If LParen expression RParen statement_matched Else statement_matched .)
    Return          reduce using rule 20 (statement_matched -> If LParen expression RParen statement_matched Else statement_matched .)
    LBrace          reduce using rule 20 (statement_matched -> If LParen expression RParen statement_matched Else statement_matched .)
    Break           reduce using rule 20 (statement_matched -> If LParen expression RParen statement_matched Else statement_matched .)
    Continue        reduce using rule 20 (statement_matched -> If LParen expression RParen statement_matched Else statement_matched .)
    Int             reduce using rule 20 (statement_matched -> If LParen expression RParen statement_matched Else statement_matched .)
    Identifier      reduce using rule 20 (statement_matched -> If LParen expression RParen statement_matched Else statement_matched .)
    Minus           reduce using rule 20 (statement_matched -> If LParen expression RParen statement_matched Else statement_matched .)
    BitNot          reduce using rule 20 (statement_matched -> If LParen expression RParen statement_matched Else statement_matched .)
    Not             reduce using rule 20 (statement_matched -> If LParen expression RParen statement_matched Else statement_matched .)
    Integer         reduce using rule 20 (statement_matched -> If LParen expression RParen statement_matched Else statement_matched .)
    LParen          reduce using rule 20 (statement_matched -> If LParen expression RParen statement_matched Else statement_matched .)
    Semi            reduce using rule 20 (statement_matched -> If LParen expression RParen statement_matched Else statement_matched .)
    Else            reduce using rule 20 (statement_matched -> If LParen expression RParen statement_matched Else statement_matched .)


state 153

    (21) statement_unmatched -> If LParen expression RParen statement_matched Else statement_unmatched .

    RBrace          reduce using rule 21 (statement_unmatched -> If LParen expression RParen statement_matched Else statement_unmatched .)
    If              reduce using rule 21 (statement_unmatched -> If LParen expression RParen statement_matched Else statement_unmatched .)
    While           reduce using rule 21 (statement_unmatched -> If LParen expression RParen statement_matched Else statement_unmatched .)
    Do              reduce using rule 21 (statement_unmatched -> If LParen expression RParen statement_matched Else statement_unmatched .)
    For             reduce using rule 21 (statement_unmatched -> If LParen expression RParen statement_matched Else statement_unmatched .)
    Return          reduce using rule 21 (statement_unmatched -> If LParen expression RParen statement_matched Else statement_unmatched .)
    LBrace          reduce using rule 21 (statement_unmatched -> If LParen expression RParen statement_matched Else statement_unmatched .)
    Break           reduce using rule 21 (statement_unmatched -> If LParen expression RParen statement_matched Else statement_unmatched .)
    Continue        reduce using rule 21 (statement_unmatched -> If LParen expression RParen statement_matched Else statement_unmatched .)
    Int             reduce using rule 21 (statement_unmatched -> If LParen expression RParen statement_matched Else statement_unmatched .)
    Identifier      reduce using rule 21 (statement_unmatched -> If LParen expression RParen statement_matched Else statement_unmatched .)
    Minus           reduce using rule 21 (statement_unmatched -> If LParen expression RParen statement_matched Else statement_unmatched .)
    BitNot          reduce using rule 21 (statement_unmatched -> If LParen expression RParen statement_matched Else statement_unmatched .)
    Not             reduce using rule 21 (statement_unmatched -> If LParen expression RParen statement_matched Else statement_unmatched .)
    Integer         reduce using rule 21 (statement_unmatched -> If LParen expression RParen statement_matched Else statement_unmatched .)
    LParen          reduce using rule 21 (statement_unmatched -> If LParen expression RParen statement_matched Else statement_unmatched .)
    Semi            reduce using rule 21 (statement_unmatched -> If LParen expression RParen statement_matched Else statement_unmatched .)


state 154

    (25) statement_matched -> Do statement_matched While LParen expression RParen Semi .

    RBrace          reduce using rule 25 (statement_matched -> Do statement_matched While LParen expression RParen Semi .)
    If              reduce using rule 25 (statement_matched -> Do statement_matched While LParen expression RParen Semi .)
    While           reduce using rule 25 (statement_matched -> Do statement_matched While LParen expression RParen Semi .)
    Do              reduce using rule 25 (statement_matched -> Do statement_matched While LParen expression RParen Semi .)
    For             reduce using rule 25 (statement_matched -> Do statement_matched While LParen expression RParen Semi .)
    Return          reduce using rule 25 (statement_matched -> Do statement_matched While LParen expression RParen Semi .)
    LBrace          reduce using rule 25 (statement_matched -> Do statement_matched While LParen expression RParen Semi .)
    Break           reduce using rule 25 (statement_matched -> Do statement_matched While LParen expression RParen Semi .)
    Continue        reduce using rule 25 (statement_matched -> Do statement_matched While LParen expression RParen Semi .)
    Int             reduce using rule 25 (statement_matched -> Do statement_matched While LParen expression RParen Semi .)
    Identifier      reduce using rule 25 (statement_matched -> Do statement_matched While LParen expression RParen Semi .)
    Minus           reduce using rule 25 (statement_matched -> Do statement_matched While LParen expression RParen Semi .)
    BitNot          reduce using rule 25 (statement_matched -> Do statement_matched While LParen expression RParen Semi .)
    Not             reduce using rule 25 (statement_matched -> Do statement_matched While LParen expression RParen Semi .)
    Integer         reduce using rule 25 (statement_matched -> Do statement_matched While LParen expression RParen Semi .)
    LParen          reduce using rule 25 (statement_matched -> Do statement_matched While LParen expression RParen Semi .)
    Semi            reduce using rule 25 (statement_matched -> Do statement_matched While LParen expression RParen Semi .)
    Else            reduce using rule 25 (statement_matched -> Do statement_matched While LParen expression RParen Semi .)


state 155

    (26) statement_unmatched -> Do statement_unmatched While LParen expression RParen Semi .

    RBrace          reduce using rule 26 (statement_unmatched -> Do statement_unmatched While LParen expression RParen Semi .)
    If              reduce using rule 26 (statement_unmatched -> Do statement_unmatched While LParen expression RParen Semi .)
    While           reduce using rule 26 (statement_unmatched -> Do statement_unmatched While LParen expression RParen Semi .)
    Do              reduce using rule 26 (statement_unmatched -> Do statement_unmatched While LParen expression RParen Semi .)
    For             reduce using rule 26 (statement_unmatched -> Do statement_unmatched While LParen expression RParen Semi .)
    Return          reduce using rule 26 (statement_unmatched -> Do statement_unmatched While LParen expression RParen Semi .)
    LBrace          reduce using rule 26 (statement_unmatched -> Do statement_unmatched While LParen expression RParen Semi .)
    Break           reduce using rule 26 (statement_unmatched -> Do statement_unmatched While LParen expression RParen Semi .)
    Continue        reduce using rule 26 (statement_unmatched -> Do statement_unmatched While LParen expression RParen Semi .)
    Int             reduce using rule 26 (statement_unmatched -> Do statement_unmatched While LParen expression RParen Semi .)
    Identifier      reduce using rule 26 (statement_unmatched -> Do statement_unmatched While LParen expression RParen Semi .)
    Minus           reduce using rule 26 (statement_unmatched -> Do statement_unmatched While LParen expression RParen Semi .)
    BitNot          reduce using rule 26 (statement_unmatched -> Do statement_unmatched While LParen expression RParen Semi .)
    Not             reduce using rule 26 (statement_unmatched -> Do statement_unmatched While LParen expression RParen Semi .)
    Integer         reduce using rule 26 (statement_unmatched -> Do statement_unmatched While LParen expression RParen Semi .)
    LParen          reduce using rule 26 (statement_unmatched -> Do statement_unmatched While LParen expression RParen Semi .)
    Semi            reduce using rule 26 (statement_unmatched -> Do statement_unmatched While LParen expression RParen Semi .)


state 156

    (27) statement_matched -> For LParen opt_expression Semi opt_expression Semi opt_expression . RParen statement_matched
    (29) statement_unmatched -> For LParen opt_expression Semi opt_expression Semi opt_expression . RParen statement_unmatched

    RParen          shift and go to state 158


state 157

    (28) statement_matched -> For LParen declaration Semi opt_expression Semi opt_expression . RParen statement_matched
    (30) statement_unmatched -> For LParen declaration Semi opt_expression Semi opt_expression . Semi opt_expression RParen statement_unmatched

    RParen          shift and go to state 160
    Semi            shift and go to state 159


state 158

    (27) statement_matched -> For LParen opt_expression Semi opt_expression Semi opt_expression RParen . statement_matched
    (29) statement_unmatched -> For LParen opt_expression Semi opt_expression Semi opt_expression RParen . statement_unmatched
    (20) statement_matched -> . If LParen expression RParen statement_matched Else statement_matched
    (23) statement_matched -> . While LParen expression RParen statement_matched
    (25) statement_matched -> . Do statement_matched While LParen expression RParen Semi
    (27) statement_matched -> . For LParen opt_expression Semi opt_expression Semi opt_expression RParen statement_matched
    (28) statement_matched -> . For LParen declaration Semi opt_expression Semi opt_expression RParen statement_matched
    (31) statement_matched -> . Return expression Semi
    (32) statement_matched -> . opt_expression Semi
    (33) statement_matched -> . LBrace block RBrace
    (34) statement_matched -> . Break Semi
    (35) statement_matched -> . Continue Semi
    (21) statement_unmatched -> . If LParen expression RParen statement_matched Else statement_unmatched
    (22) statement_unmatched -> . If LParen expression RParen statement
    (24) statement_unmatched -> . While LParen expression RParen statement_unmatched
    (26) statement_unmatched -> . Do statement_unmatched While LParen expression RParen Semi
    (29) statement_unmatched -> . For LParen opt_expression Semi opt_expression Semi opt_expression RParen statement_unmatched
    (30) statement_unmatched -> . For LParen declaration Semi opt_expression Semi opt_expression Semi opt_expression RParen statement_unmatched
    (36) opt_expression -> . expression
    (37) opt_expression -> . empty
    (40) expression -> . assignment
    (1) empty -> .
    (41) assignment -> . conditional
    (61) assignment -> . Identifier Assign expression
    (42) conditional -> . logical_or
    (78) conditional -> . logical_or Question expression Colon conditional
    (43) logical_or -> . logical_and
    (62) logical_or -> . logical_or Or logical_and
    (44) logical_and -> . bit_or
    (63) logical_and -> . logical_and And bit_or
    (45) bit_or -> . xor
    (64) bit_or -> . bit_or BitOr xor
    (46) xor -> . bit_and
    (65) xor -> . xor Xor bit_and
    (47) bit_and -> . equality
    (66) bit_and -> . bit_and BitAnd equality
    (48) equality -> . relational
    (67) equality -> . equality NotEqual relational
    (68) equality -> . equality Equal relational
    (49) relational -> . additive
    (69) relational -> . relational Less additive
    (70) relational -> . relational Greater additive
    (71) relational -> . relational LessEqual additive
    (72) relational -> . relational GreaterEqual additive
    (50) additive -> . multiplicative
    (73) additive -> . additive Plus multiplicative
    (74) additive -> . additive Minus multiplicative
    (51) multiplicative -> . unary
    (75) multiplicative -> . multiplicative Mul unary
    (76) multiplicative -> . multiplicative Div unary
    (77) multiplicative -> . multiplicative Mod unary
    (52) unary -> . postfix
    (54) unary -> . Minus unary
    (55) unary -> . BitNot unary
    (56) unary -> . Not unary
    (53) postfix -> . primary
    (57) postfix -> . Identifier LParen expression_list RParen
    (79) primary -> . Integer
    (80) primary -> . Identifier
    (81) primary -> . LParen expression RParen

    If              shift and go to state 33
    While           shift and go to state 34
    Do              shift and go to state 35
    For             shift and go to state 36
    Return          shift and go to state 38
    LBrace          shift and go to state 25
    Break           shift and go to state 39
    Continue        shift and go to state 40
    Semi            reduce using rule 1 (empty -> .)
    Identifier      shift and go to state 23
    Minus           shift and go to state 53
    BitNot          shift and go to state 56
    Not             shift and go to state 57
    Integer         shift and go to state 59
    LParen          shift and go to state 24

    opt_expression                 shift and go to state 37
    statement_matched              shift and go to state 161
    statement_unmatched            shift and go to state 162
    expression                     shift and go to state 32
    empty                          shift and go to state 41
    assignment                     shift and go to state 42
    conditional                    shift and go to state 43
    logical_or                     shift and go to state 44
    logical_and                    shift and go to state 45
    bit_or                         shift and go to state 46
    xor                            shift and go to state 47
    bit_and                        shift and go to state 48
    equality                       shift and go to state 49
    relational                     shift and go to state 50
    additive                       shift and go to state 51
    multiplicative                 shift and go to state 52
    unary                          shift and go to state 54
    postfix                        shift and go to state 55
    primary                        shift and go to state 58

state 159

    (30) statement_unmatched -> For LParen declaration Semi opt_expression Semi opt_expression Semi . opt_expression RParen statement_unmatched
    (36) opt_expression -> . expression
    (37) opt_expression -> . empty
    (40) expression -> . assignment
    (1) empty -> .
    (41) assignment -> . conditional
    (61) assignment -> . Identifier Assign expression
    (42) conditional -> . logical_or
    (78) conditional -> . logical_or Question expression Colon conditional
    (43) logical_or -> . logical_and
    (62) logical_or -> . logical_or Or logical_and
    (44) logical_and -> . bit_or
    (63) logical_and -> . logical_and And bit_or
    (45) bit_or -> . xor
    (64) bit_or -> . bit_or BitOr xor
    (46) xor -> . bit_and
    (65) xor -> . xor Xor bit_and
    (47) bit_and -> . equality
    (66) bit_and -> . bit_and BitAnd equality
    (48) equality -> . relational
    (67) equality -> . equality NotEqual relational
    (68) equality -> . equality Equal relational
    (49) relational -> . additive
    (69) relational -> . relational Less additive
    (70) relational -> . relational Greater additive
    (71) relational -> . relational LessEqual additive
    (72) relational -> . relational GreaterEqual additive
    (50) additive -> . multiplicative
    (73) additive -> . additive Plus multiplicative
    (74) additive -> . additive Minus multiplicative
    (51) multiplicative -> . unary
    (75) multiplicative -> . multiplicative Mul unary
    (76) multiplicative -> . multiplicative Div unary
    (77) multiplicative -> . multiplicative Mod unary
    (52) unary -> . postfix
    (54) unary -> . Minus unary
    (55) unary -> . BitNot unary
    (56) unary -> . Not unary
    (53) postfix -> . primary
    (57) postfix -> . Identifier LParen expression_list RParen
    (79) primary -> . Integer
    (80) primary -> . Identifier
    (81) primary -> . LParen expression RParen

    RParen          reduce using rule 1 (empty -> .)
    Identifier      shift and go to state 23
    Minus           shift and go to state 53
    BitNot          shift and go to state 56
    Not             shift and go to state 57
    Integer         shift and go to state 59
    LParen          shift and go to state 24

    opt_expression                 shift and go to state 163
    expression                     shift and go to state 32
    empty                          shift and go to state 41
    assignment                     shift and go to state 42
    conditional                    shift and go to state 43
    logical_or                     shift and go to state 44
    logical_and                    shift and go to state 45
    bit_or                         shift and go to state 46
    xor                            shift and go to state 47
    bit_and                        shift and go to state 48
    equality                       shift and go to state 49
    relational                     shift and go to state 50
    additive                       shift and go to state 51
    multiplicative                 shift and go to state 52
    unary                          shift and go to state 54
    postfix                        shift and go to state 55
    primary                        shift and go to state 58

state 160

    (28) statement_matched -> For LParen declaration Semi opt_expression Semi opt_expression RParen . statement_matched
    (20) statement_matched -> . If LParen expression RParen statement_matched Else statement_matched
    (23) statement_matched -> . While LParen expression RParen statement_matched
    (25) statement_matched -> . Do statement_matched While LParen expression RParen Semi
    (27) statement_matched -> . For LParen opt_expression Semi opt_expression Semi opt_expression RParen statement_matched
    (28) statement_matched -> . For LParen declaration Semi opt_expression Semi opt_expression RParen statement_matched
    (31) statement_matched -> . Return expression Semi
    (32) statement_matched -> . opt_expression Semi
    (33) statement_matched -> . LBrace block RBrace
    (34) statement_matched -> . Break Semi
    (35) statement_matched -> . Continue Semi
    (36) opt_expression -> . expression
    (37) opt_expression -> . empty
    (40) expression -> . assignment
    (1) empty -> .
    (41) assignment -> . conditional
    (61) assignment -> . Identifier Assign expression
    (42) conditional -> . logical_or
    (78) conditional -> . logical_or Question expression Colon conditional
    (43) logical_or -> . logical_and
    (62) logical_or -> . logical_or Or logical_and
    (44) logical_and -> . bit_or
    (63) logical_and -> . logical_and And bit_or
    (45) bit_or -> . xor
    (64) bit_or -> . bit_or BitOr xor
    (46) xor -> . bit_and
    (65) xor -> . xor Xor bit_and
    (47) bit_and -> . equality
    (66) bit_and -> . bit_and BitAnd equality
    (48) equality -> . relational
    (67) equality -> . equality NotEqual relational
    (68) equality -> . equality Equal relational
    (49) relational -> . additive
    (69) relational -> . relational Less additive
    (70) relational -> . relational Greater additive
    (71) relational -> . relational LessEqual additive
    (72) relational -> . relational GreaterEqual additive
    (50) additive -> . multiplicative
    (73) additive -> . additive Plus multiplicative
    (74) additive -> . additive Minus multiplicative
    (51) multiplicative -> . unary
    (75) multiplicative -> . multiplicative Mul unary
    (76) multiplicative -> . multiplicative Div unary
    (77) multiplicative -> . multiplicative Mod unary
    (52) unary -> . postfix
    (54) unary -> . Minus unary
    (55) unary -> . BitNot unary
    (56) unary -> . Not unary
    (53) postfix -> . primary
    (57) postfix -> . Identifier LParen expression_list RParen
    (79) primary -> . Integer
    (80) primary -> . Identifier
    (81) primary -> . LParen expression RParen

    If              shift and go to state 166
    While           shift and go to state 167
    Do              shift and go to state 168
    For             shift and go to state 164
    Return          shift and go to state 38
    LBrace          shift and go to state 25
    Break           shift and go to state 39
    Continue        shift and go to state 40
    Semi            reduce using rule 1 (empty -> .)
    Identifier      shift and go to state 23
    Minus           shift and go to state 53
    BitNot          shift and go to state 56
    Not             shift and go to state 57
    Integer         shift and go to state 59
    LParen          shift and go to state 24

    opt_expression                 shift and go to state 37
    statement_matched              shift and go to state 165
    expression                     shift and go to state 32
    empty                          shift and go to state 41
    assignment                     shift and go to state 42
    conditional                    shift and go to state 43
    logical_or                     shift and go to state 44
    logical_and                    shift and go to state 45
    bit_or                         shift and go to state 46
    xor                            shift and go to state 47
    bit_and                        shift and go to state 48
    equality                       shift and go to state 49
    relational                     shift and go to state 50
    additive                       shift and go to state 51
    multiplicative                 shift and go to state 52
    unary                          shift and go to state 54
    postfix                        shift and go to state 55
    primary                        shift and go to state 58

state 161

    (27) statement_matched -> For LParen opt_expression Semi opt_expression Semi opt_expression RParen statement_matched .

    RBrace          reduce using rule 27 (statement_matched -> For LParen opt_expression Semi opt_expression Semi opt_expression RParen statement_matched .)
    If              reduce using rule 27 (statement_matched -> For LParen opt_expression Semi opt_expression Semi opt_expression RParen statement_matched .)
    While           reduce using rule 27 (statement_matched -> For LParen opt_expression Semi opt_expression Semi opt_expression RParen statement_matched .)
    Do              reduce using rule 27 (statement_matched -> For LParen opt_expression Semi opt_expression Semi opt_expression RParen statement_matched .)
    For             reduce using rule 27 (statement_matched -> For LParen opt_expression Semi opt_expression Semi opt_expression RParen statement_matched .)
    Return          reduce using rule 27 (statement_matched -> For LParen opt_expression Semi opt_expression Semi opt_expression RParen statement_matched .)
    LBrace          reduce using rule 27 (statement_matched -> For LParen opt_expression Semi opt_expression Semi opt_expression RParen statement_matched .)
    Break           reduce using rule 27 (statement_matched -> For LParen opt_expression Semi opt_expression Semi opt_expression RParen statement_matched .)
    Continue        reduce using rule 27 (statement_matched -> For LParen opt_expression Semi opt_expression Semi opt_expression RParen statement_matched .)
    Int             reduce using rule 27 (statement_matched -> For LParen opt_expression Semi opt_expression Semi opt_expression RParen statement_matched .)
    Identifier      reduce using rule 27 (statement_matched -> For LParen opt_expression Semi opt_expression Semi opt_expression RParen statement_matched .)
    Minus           reduce using rule 27 (statement_matched -> For LParen opt_expression Semi opt_expression Semi opt_expression RParen statement_matched .)
    BitNot          reduce using rule 27 (statement_matched -> For LParen opt_expression Semi opt_expression Semi opt_expression RParen statement_matched .)
    Not             reduce using rule 27 (statement_matched -> For LParen opt_expression Semi opt_expression Semi opt_expression RParen statement_matched .)
    Integer         reduce using rule 27 (statement_matched -> For LParen opt_expression Semi opt_expression Semi opt_expression RParen statement_matched .)
    LParen          reduce using rule 27 (statement_matched -> For LParen opt_expression Semi opt_expression Semi opt_expression RParen statement_matched .)
    Semi            reduce using rule 27 (statement_matched -> For LParen opt_expression Semi opt_expression Semi opt_expression RParen statement_matched .)
    Else            reduce using rule 27 (statement_matched -> For LParen opt_expression Semi opt_expression Semi opt_expression RParen statement_matched .)


state 162

    (29) statement_unmatched -> For LParen opt_expression Semi opt_expression Semi opt_expression RParen statement_unmatched .

    RBrace          reduce using rule 29 (statement_unmatched -> For LParen opt_expression Semi opt_expression Semi opt_expression RParen statement_unmatched .)
    If              reduce using rule 29 (statement_unmatched -> For LParen opt_expression Semi opt_expression Semi opt_expression RParen statement_unmatched .)
    While           reduce using rule 29 (statement_unmatched -> For LParen opt_expression Semi opt_expression Semi opt_expression RParen statement_unmatched .)
    Do              reduce using rule 29 (statement_unmatched -> For LParen opt_expression Semi opt_expression Semi opt_expression RParen statement_unmatched .)
    For             reduce using rule 29 (statement_unmatched -> For LParen opt_expression Semi opt_expression Semi opt_expression RParen statement_unmatched .)
    Return          reduce using rule 29 (statement_unmatched -> For LParen opt_expression Semi opt_expression Semi opt_expression RParen statement_unmatched .)
    LBrace          reduce using rule 29 (statement_unmatched -> For LParen opt_expression Semi opt_expression Semi opt_expression RParen statement_unmatched .)
    Break           reduce using rule 29 (statement_unmatched -> For LParen opt_expression Semi opt_expression Semi opt_expression RParen statement_unmatched .)
    Continue        reduce using rule 29 (statement_unmatched -> For LParen opt_expression Semi opt_expression Semi opt_expression RParen statement_unmatched .)
    Int             reduce using rule 29 (statement_unmatched -> For LParen opt_expression Semi opt_expression Semi opt_expression RParen statement_unmatched .)
    Identifier      reduce using rule 29 (statement_unmatched -> For LParen opt_expression Semi opt_expression Semi opt_expression RParen statement_unmatched .)
    Minus           reduce using rule 29 (statement_unmatched -> For LParen opt_expression Semi opt_expression Semi opt_expression RParen statement_unmatched .)
    BitNot          reduce using rule 29 (statement_unmatched -> For LParen opt_expression Semi opt_expression Semi opt_expression RParen statement_unmatched .)
    Not             reduce using rule 29 (statement_unmatched -> For LParen opt_expression Semi opt_expression Semi opt_expression RParen statement_unmatched .)
    Integer         reduce using rule 29 (statement_unmatched -> For LParen opt_expression Semi opt_expression Semi opt_expression RParen statement_unmatched .)
    LParen          reduce using rule 29 (statement_unmatched -> For LParen opt_expression Semi opt_expression Semi opt_expression RParen statement_unmatched .)
    Semi            reduce using rule 29 (statement_unmatched -> For LParen opt_expression Semi opt_expression Semi opt_expression RParen statement_unmatched .)


state 163

    (30) statement_unmatched -> For LParen declaration Semi opt_expression Semi opt_expression Semi opt_expression . RParen statement_unmatched

    RParen          shift and go to state 169


state 164

    (27) statement_matched -> For . LParen opt_expression Semi opt_expression Semi opt_expression RParen statement_matched
    (28) statement_matched -> For . LParen declaration Semi opt_expression Semi opt_expression RParen statement_matched

    LParen          shift and go to state 170


state 165

    (28) statement_matched -> For LParen declaration Semi opt_expression Semi opt_expression RParen statement_matched .

    RBrace          reduce using rule 28 (statement_matched -> For LParen declaration Semi opt_expression Semi opt_expression RParen statement_matched .)
    If              reduce using rule 28 (statement_matched -> For LParen declaration Semi opt_expression Semi opt_expression RParen statement_matched .)
    While           reduce using rule 28 (statement_matched -> For LParen declaration Semi opt_expression Semi opt_expression RParen statement_matched .)
    Do              reduce using rule 28 (statement_matched -> For LParen declaration Semi opt_expression Semi opt_expression RParen statement_matched .)
    For             reduce using rule 28 (statement_matched -> For LParen declaration Semi opt_expression Semi opt_expression RParen statement_matched .)
    Return          reduce using rule 28 (statement_matched -> For LParen declaration Semi opt_expression Semi opt_expression RParen statement_matched .)
    LBrace          reduce using rule 28 (statement_matched -> For LParen declaration Semi opt_expression Semi opt_expression RParen statement_matched .)
    Break           reduce using rule 28 (statement_matched -> For LParen declaration Semi opt_expression Semi opt_expression RParen statement_matched .)
    Continue        reduce using rule 28 (statement_matched -> For LParen declaration Semi opt_expression Semi opt_expression RParen statement_matched .)
    Int             reduce using rule 28 (statement_matched -> For LParen declaration Semi opt_expression Semi opt_expression RParen statement_matched .)
    Identifier      reduce using rule 28 (statement_matched -> For LParen declaration Semi opt_expression Semi opt_expression RParen statement_matched .)
    Minus           reduce using rule 28 (statement_matched -> For LParen declaration Semi opt_expression Semi opt_expression RParen statement_matched .)
    BitNot          reduce using rule 28 (statement_matched -> For LParen declaration Semi opt_expression Semi opt_expression RParen statement_matched .)
    Not             reduce using rule 28 (statement_matched -> For LParen declaration Semi opt_expression Semi opt_expression RParen statement_matched .)
    Integer         reduce using rule 28 (statement_matched -> For LParen declaration Semi opt_expression Semi opt_expression RParen statement_matched .)
    LParen          reduce using rule 28 (statement_matched -> For LParen declaration Semi opt_expression Semi opt_expression RParen statement_matched .)
    Semi            reduce using rule 28 (statement_matched -> For LParen declaration Semi opt_expression Semi opt_expression RParen statement_matched .)
    Else            reduce using rule 28 (statement_matched -> For LParen declaration Semi opt_expression Semi opt_expression RParen statement_matched .)


state 166

    (20) statement_matched -> If . LParen expression RParen statement_matched Else statement_matched

    LParen          shift and go to state 171


state 167

    (23) statement_matched -> While . LParen expression RParen statement_matched

    LParen          shift and go to state 172


state 168

    (25) statement_matched -> Do . statement_matched While LParen expression RParen Semi
    (20) statement_matched -> . If LParen expression RParen statement_matched Else statement_matched
    (23) statement_matched -> . While LParen expression RParen statement_matched
    (25) statement_matched -> . Do statement_matched While LParen expression RParen Semi
    (27) statement_matched -> . For LParen opt_expression Semi opt_expression Semi opt_expression RParen statement_matched
    (28) statement_matched -> . For LParen declaration Semi opt_expression Semi opt_expression RParen statement_matched
    (31) statement_matched -> . Return expression Semi
    (32) statement_matched -> . opt_expression Semi
    (33) statement_matched -> . LBrace block RBrace
    (34) statement_matched -> . Break Semi
    (35) statement_matched -> . Continue Semi
    (36) opt_expression -> . expression
    (37) opt_expression -> . empty
    (40) expression -> . assignment
    (1) empty -> .
    (41) assignment -> . conditional
    (61) assignment -> . Identifier Assign expression
    (42) conditional -> . logical_or
    (78) conditional -> . logical_or Question expression Colon conditional
    (43) logical_or -> . logical_and
    (62) logical_or -> . logical_or Or logical_and
    (44) logical_and -> . bit_or
    (63) logical_and -> . logical_and And bit_or
    (45) bit_or -> . xor
    (64) bit_or -> . bit_or BitOr xor
    (46) xor -> . bit_and
    (65) xor -> . xor Xor bit_and
    (47) bit_and -> . equality
    (66) bit_and -> . bit_and BitAnd equality
    (48) equality -> . relational
    (67) equality -> . equality NotEqual relational
    (68) equality -> . equality Equal relational
    (49) relational -> . additive
    (69) relational -> . relational Less additive
    (70) relational -> . relational Greater additive
    (71) relational -> . relational LessEqual additive
    (72) relational -> . relational GreaterEqual additive
    (50) additive -> . multiplicative
    (73) additive -> . additive Plus multiplicative
    (74) additive -> . additive Minus multiplicative
    (51) multiplicative -> . unary
    (75) multiplicative -> . multiplicative Mul unary
    (76) multiplicative -> . multiplicative Div unary
    (77) multiplicative -> . multiplicative Mod unary
    (52) unary -> . postfix
    (54) unary -> . Minus unary
    (55) unary -> . BitNot unary
    (56) unary -> . Not unary
    (53) postfix -> . primary
    (57) postfix -> . Identifier LParen expression_list RParen
    (79) primary -> . Integer
    (80) primary -> . Identifier
    (81) primary -> . LParen expression RParen

    If              shift and go to state 166
    While           shift and go to state 167
    Do              shift and go to state 168
    For             shift and go to state 164
    Return          shift and go to state 38
    LBrace          shift and go to state 25
    Break           shift and go to state 39
    Continue        shift and go to state 40
    Semi            reduce using rule 1 (empty -> .)
    Identifier      shift and go to state 23
    Minus           shift and go to state 53
    BitNot          shift and go to state 56
    Not             shift and go to state 57
    Integer         shift and go to state 59
    LParen          shift and go to state 24

    statement_matched              shift and go to state 68
    expression                     shift and go to state 32
    opt_expression                 shift and go to state 37
    empty                          shift and go to state 41
    assignment                     shift and go to state 42
    conditional                    shift and go to state 43
    logical_or                     shift and go to state 44
    logical_and                    shift and go to state 45
    bit_or                         shift and go to state 46
    xor                            shift and go to state 47
    bit_and                        shift and go to state 48
    equality                       shift and go to state 49
    relational                     shift and go to state 50
    additive                       shift and go to state 51
    multiplicative                 shift and go to state 52
    unary                          shift and go to state 54
    postfix                        shift and go to state 55
    primary                        shift and go to state 58

state 169

    (30) statement_unmatched -> For LParen declaration Semi opt_expression Semi opt_expression Semi opt_expression RParen . statement_unmatched
    (21) statement_unmatched -> . If LParen expression RParen statement_matched Else statement_unmatched
    (22) statement_unmatched -> . If LParen expression RParen statement
    (24) statement_unmatched -> . While LParen expression RParen statement_unmatched
    (26) statement_unmatched -> . Do statement_unmatched While LParen expression RParen Semi
    (29) statement_unmatched -> . For LParen opt_expression Semi opt_expression Semi opt_expression RParen statement_unmatched
    (30) statement_unmatched -> . For LParen declaration Semi opt_expression Semi opt_expression Semi opt_expression RParen statement_unmatched

    If              shift and go to state 175
    While           shift and go to state 176
    Do              shift and go to state 177
    For             shift and go to state 173

    statement_unmatched            shift and go to state 174

state 170

    (27) statement_matched -> For LParen . opt_expression Semi opt_expression Semi opt_expression RParen statement_matched
    (28) statement_matched -> For LParen . declaration Semi opt_expression Semi opt_expression RParen statement_matched
    (36) opt_expression -> . expression
    (37) opt_expression -> . empty
    (38) declaration -> . type Identifier
    (39) declaration -> . type Identifier Assign expression
    (40) expression -> . assignment
    (1) empty -> .
    (4) type -> . Int
    (41) assignment -> . conditional
    (61) assignment -> . Identifier Assign expression
    (42) conditional -> . logical_or
    (78) conditional -> . logical_or Question expression Colon conditional
    (43) logical_or -> . logical_and
    (62) logical_or -> . logical_or Or logical_and
    (44) logical_and -> . bit_or
    (63) logical_and -> . logical_and And bit_or
    (45) bit_or -> . xor
    (64) bit_or -> . bit_or BitOr xor
    (46) xor -> . bit_and
    (65) xor -> . xor Xor bit_and
    (47) bit_and -> . equality
    (66) bit_and -> . bit_and BitAnd equality
    (48) equality -> . relational
    (67) equality -> . equality NotEqual relational
    (68) equality -> . equality Equal relational
    (49) relational -> . additive
    (69) relational -> . relational Less additive
    (70) relational -> . relational Greater additive
    (71) relational -> . relational LessEqual additive
    (72) relational -> . relational GreaterEqual additive
    (50) additive -> . multiplicative
    (73) additive -> . additive Plus multiplicative
    (74) additive -> . additive Minus multiplicative
    (51) multiplicative -> . unary
    (75) multiplicative -> . multiplicative Mul unary
    (76) multiplicative -> . multiplicative Div unary
    (77) multiplicative -> . multiplicative Mod unary
    (52) unary -> . postfix
    (54) unary -> . Minus unary
    (55) unary -> . BitNot unary
    (56) unary -> . Not unary
    (53) postfix -> . primary
    (57) postfix -> . Identifier LParen expression_list RParen
    (79) primary -> . Integer
    (80) primary -> . Identifier
    (81) primary -> . LParen expression RParen

    Semi            reduce using rule 1 (empty -> .)
    Int             shift and go to state 7
    Identifier      shift and go to state 23
    Minus           shift and go to state 53
    BitNot          shift and go to state 56
    Not             shift and go to state 57
    Integer         shift and go to state 59
    LParen          shift and go to state 24

    opt_expression                 shift and go to state 178
    declaration                    shift and go to state 179
    expression                     shift and go to state 32
    empty                          shift and go to state 41
    type                           shift and go to state 22
    assignment                     shift and go to state 42
    conditional                    shift and go to state 43
    logical_or                     shift and go to state 44
    logical_and                    shift and go to state 45
    bit_or                         shift and go to state 46
    xor                            shift and go to state 47
    bit_and                        shift and go to state 48
    equality                       shift and go to state 49
    relational                     shift and go to state 50
    additive                       shift and go to state 51
    multiplicative                 shift and go to state 52
    unary                          shift and go to state 54
    postfix                        shift and go to state 55
    primary                        shift and go to state 58

state 171

    (20) statement_matched -> If LParen . expression RParen statement_matched Else statement_matched
    (40) expression -> . assignment
    (41) assignment -> . conditional
    (61) assignment -> . Identifier Assign expression
    (42) conditional -> . logical_or
    (78) conditional -> . logical_or Question expression Colon conditional
    (43) logical_or -> . logical_and
    (62) logical_or -> . logical_or Or logical_and
    (44) logical_and -> . bit_or
    (63) logical_and -> . logical_and And bit_or
    (45) bit_or -> . xor
    (64) bit_or -> . bit_or BitOr xor
    (46) xor -> . bit_and
    (65) xor -> . xor Xor bit_and
    (47) bit_and -> . equality
    (66) bit_and -> . bit_and BitAnd equality
    (48) equality -> . relational
    (67) equality -> . equality NotEqual relational
    (68) equality -> . equality Equal relational
    (49) relational -> . additive
    (69) relational -> . relational Less additive
    (70) relational -> . relational Greater additive
    (71) relational -> . relational LessEqual additive
    (72) relational -> . relational GreaterEqual additive
    (50) additive -> . multiplicative
    (73) additive -> . additive Plus multiplicative
    (74) additive -> . additive Minus multiplicative
    (51) multiplicative -> . unary
    (75) multiplicative -> . multiplicative Mul unary
    (76) multiplicative -> . multiplicative Div unary
    (77) multiplicative -> . multiplicative Mod unary
    (52) unary -> . postfix
    (54) unary -> . Minus unary
    (55) unary -> . BitNot unary
    (56) unary -> . Not unary
    (53) postfix -> . primary
    (57) postfix -> . Identifier LParen expression_list RParen
    (79) primary -> . Integer
    (80) primary -> . Identifier
    (81) primary -> . LParen expression RParen

    Identifier      shift and go to state 23
    Minus           shift and go to state 53
    BitNot          shift and go to state 56
    Not             shift and go to state 57
    Integer         shift and go to state 59
    LParen          shift and go to state 24

    expression                     shift and go to state 180
    assignment                     shift and go to state 42
    conditional                    shift and go to state 43
    logical_or                     shift and go to state 44
    logical_and                    shift and go to state 45
    bit_or                         shift and go to state 46
    xor                            shift and go to state 47
    bit_and                        shift and go to state 48
    equality                       shift and go to state 49
    relational                     shift and go to state 50
    additive                       shift and go to state 51
    multiplicative                 shift and go to state 52
    unary                          shift and go to state 54
    postfix                        shift and go to state 55
    primary                        shift and go to state 58

state 172

    (23) statement_matched -> While LParen . expression RParen statement_matched
    (40) expression -> . assignment
    (41) assignment -> . conditional
    (61) assignment -> . Identifier Assign expression
    (42) conditional -> . logical_or
    (78) conditional -> . logical_or Question expression Colon conditional
    (43) logical_or -> . logical_and
    (62) logical_or -> . logical_or Or logical_and
    (44) logical_and -> . bit_or
    (63) logical_and -> . logical_and And bit_or
    (45) bit_or -> . xor
    (64) bit_or -> . bit_or BitOr xor
    (46) xor -> . bit_and
    (65) xor -> . xor Xor bit_and
    (47) bit_and -> . equality
    (66) bit_and -> . bit_and BitAnd equality
    (48) equality -> . relational
    (67) equality -> . equality NotEqual relational
    (68) equality -> . equality Equal relational
    (49) relational -> . additive
    (69) relational -> . relational Less additive
    (70) relational -> . relational Greater additive
    (71) relational -> . relational LessEqual additive
    (72) relational -> . relational GreaterEqual additive
    (50) additive -> . multiplicative
    (73) additive -> . additive Plus multiplicative
    (74) additive -> . additive Minus multiplicative
    (51) multiplicative -> . unary
    (75) multiplicative -> . multiplicative Mul unary
    (76) multiplicative -> . multiplicative Div unary
    (77) multiplicative -> . multiplicative Mod unary
    (52) unary -> . postfix
    (54) unary -> . Minus unary
    (55) unary -> . BitNot unary
    (56) unary -> . Not unary
    (53) postfix -> . primary
    (57) postfix -> . Identifier LParen expression_list RParen
    (79) primary -> . Integer
    (80) primary -> . Identifier
    (81) primary -> . LParen expression RParen

    Identifier      shift and go to state 23
    Minus           shift and go to state 53
    BitNot          shift and go to state 56
    Not             shift and go to state 57
    Integer         shift and go to state 59
    LParen          shift and go to state 24

    expression                     shift and go to state 181
    assignment                     shift and go to state 42
    conditional                    shift and go to state 43
    logical_or                     shift and go to state 44
    logical_and                    shift and go to state 45
    bit_or                         shift and go to state 46
    xor                            shift and go to state 47
    bit_and                        shift and go to state 48
    equality                       shift and go to state 49
    relational                     shift and go to state 50
    additive                       shift and go to state 51
    multiplicative                 shift and go to state 52
    unary                          shift and go to state 54
    postfix                        shift and go to state 55
    primary                        shift and go to state 58

state 173

    (29) statement_unmatched -> For . LParen opt_expression Semi opt_expression Semi opt_expression RParen statement_unmatched
    (30) statement_unmatched -> For . LParen declaration Semi opt_expression Semi opt_expression Semi opt_expression RParen statement_unmatched

    LParen          shift and go to state 182


state 174

    (30) statement_unmatched -> For LParen declaration Semi opt_expression Semi opt_expression Semi opt_expression RParen statement_unmatched .

    RBrace          reduce using rule 30 (statement_unmatched -> For LParen declaration Semi opt_expression Semi opt_expression Semi opt_expression RParen statement_unmatched .)
    If              reduce using rule 30 (statement_unmatched -> For LParen declaration Semi opt_expression Semi opt_expression Semi opt_expression RParen statement_unmatched .)
    While           reduce using rule 30 (statement_unmatched -> For LParen declaration Semi opt_expression Semi opt_expression Semi opt_expression RParen statement_unmatched .)
    Do              reduce using rule 30 (statement_unmatched -> For LParen declaration Semi opt_expression Semi opt_expression Semi opt_expression RParen statement_unmatched .)
    For             reduce using rule 30 (statement_unmatched -> For LParen declaration Semi opt_expression Semi opt_expression Semi opt_expression RParen statement_unmatched .)
    Return          reduce using rule 30 (statement_unmatched -> For LParen declaration Semi opt_expression Semi opt_expression Semi opt_expression RParen statement_unmatched .)
    LBrace          reduce using rule 30 (statement_unmatched -> For LParen declaration Semi opt_expression Semi opt_expression Semi opt_expression RParen statement_unmatched .)
    Break           reduce using rule 30 (statement_unmatched -> For LParen declaration Semi opt_expression Semi opt_expression Semi opt_expression RParen statement_unmatched .)
    Continue        reduce using rule 30 (statement_unmatched -> For LParen declaration Semi opt_expression Semi opt_expression Semi opt_expression RParen statement_unmatched .)
    Int             reduce using rule 30 (statement_unmatched -> For LParen declaration Semi opt_expression Semi opt_expression Semi opt_expression RParen statement_unmatched .)
    Identifier      reduce using rule 30 (statement_unmatched -> For LParen declaration Semi opt_expression Semi opt_expression Semi opt_expression RParen statement_unmatched .)
    Minus           reduce using rule 30 (statement_unmatched -> For LParen declaration Semi opt_expression Semi opt_expression Semi opt_expression RParen statement_unmatched .)
    BitNot          reduce using rule 30 (statement_unmatched -> For LParen declaration Semi opt_expression Semi opt_expression Semi opt_expression RParen statement_unmatched .)
    Not             reduce using rule 30 (statement_unmatched -> For LParen declaration Semi opt_expression Semi opt_expression Semi opt_expression RParen statement_unmatched .)
    Integer         reduce using rule 30 (statement_unmatched -> For LParen declaration Semi opt_expression Semi opt_expression Semi opt_expression RParen statement_unmatched .)
    LParen          reduce using rule 30 (statement_unmatched -> For LParen declaration Semi opt_expression Semi opt_expression Semi opt_expression RParen statement_unmatched .)
    Semi            reduce using rule 30 (statement_unmatched -> For LParen declaration Semi opt_expression Semi opt_expression Semi opt_expression RParen statement_unmatched .)


state 175

    (21) statement_unmatched -> If . LParen expression RParen statement_matched Else statement_unmatched
    (22) statement_unmatched -> If . LParen expression RParen statement

    LParen          shift and go to state 183


state 176

    (24) statement_unmatched -> While . LParen expression RParen statement_unmatched

    LParen          shift and go to state 184


state 177

    (26) statement_unmatched -> Do . statement_unmatched While LParen expression RParen Semi
    (21) statement_unmatched -> . If LParen expression RParen statement_matched Else statement_unmatched
    (22) statement_unmatched -> . If LParen expression RParen statement
    (24) statement_unmatched -> . While LParen expression RParen statement_unmatched
    (26) statement_unmatched -> . Do statement_unmatched While LParen expression RParen Semi
    (29) statement_unmatched -> . For LParen opt_expression Semi opt_expression Semi opt_expression RParen statement_unmatched
    (30) statement_unmatched -> . For LParen declaration Semi opt_expression Semi opt_expression Semi opt_expression RParen statement_unmatched

    If              shift and go to state 175
    While           shift and go to state 176
    Do              shift and go to state 177
    For             shift and go to state 173

    statement_unmatched            shift and go to state 69

state 178

    (27) statement_matched -> For LParen opt_expression . Semi opt_expression Semi opt_expression RParen statement_matched

    Semi            shift and go to state 185


state 179

    (28) statement_matched -> For LParen declaration . Semi opt_expression Semi opt_expression RParen statement_matched

    Semi            shift and go to state 186


state 180

    (20) statement_matched -> If LParen expression . RParen statement_matched Else statement_matched

    RParen          shift and go to state 187


state 181

    (23) statement_matched -> While LParen expression . RParen statement_matched

    RParen          shift and go to state 188


state 182

    (29) statement_unmatched -> For LParen . opt_expression Semi opt_expression Semi opt_expression RParen statement_unmatched
    (30) statement_unmatched -> For LParen . declaration Semi opt_expression Semi opt_expression Semi opt_expression RParen statement_unmatched
    (36) opt_expression -> . expression
    (37) opt_expression -> . empty
    (38) declaration -> . type Identifier
    (39) declaration -> . type Identifier Assign expression
    (40) expression -> . assignment
    (1) empty -> .
    (4) type -> . Int
    (41) assignment -> . conditional
    (61) assignment -> . Identifier Assign expression
    (42) conditional -> . logical_or
    (78) conditional -> . logical_or Question expression Colon conditional
    (43) logical_or -> . logical_and
    (62) logical_or -> . logical_or Or logical_and
    (44) logical_and -> . bit_or
    (63) logical_and -> . logical_and And bit_or
    (45) bit_or -> . xor
    (64) bit_or -> . bit_or BitOr xor
    (46) xor -> . bit_and
    (65) xor -> . xor Xor bit_and
    (47) bit_and -> . equality
    (66) bit_and -> . bit_and BitAnd equality
    (48) equality -> . relational
    (67) equality -> . equality NotEqual relational
    (68) equality -> . equality Equal relational
    (49) relational -> . additive
    (69) relational -> . relational Less additive
    (70) relational -> . relational Greater additive
    (71) relational -> . relational LessEqual additive
    (72) relational -> . relational GreaterEqual additive
    (50) additive -> . multiplicative
    (73) additive -> . additive Plus multiplicative
    (74) additive -> . additive Minus multiplicative
    (51) multiplicative -> . unary
    (75) multiplicative -> . multiplicative Mul unary
    (76) multiplicative -> . multiplicative Div unary
    (77) multiplicative -> . multiplicative Mod unary
    (52) unary -> . postfix
    (54) unary -> . Minus unary
    (55) unary -> . BitNot unary
    (56) unary -> . Not unary
    (53) postfix -> . primary
    (57) postfix -> . Identifier LParen expression_list RParen
    (79) primary -> . Integer
    (80) primary -> . Identifier
    (81) primary -> . LParen expression RParen

    Semi            reduce using rule 1 (empty -> .)
    Int             shift and go to state 7
    Identifier      shift and go to state 23
    Minus           shift and go to state 53
    BitNot          shift and go to state 56
    Not             shift and go to state 57
    Integer         shift and go to state 59
    LParen          shift and go to state 24

    opt_expression                 shift and go to state 189
    declaration                    shift and go to state 190
    expression                     shift and go to state 32
    empty                          shift and go to state 41
    type                           shift and go to state 22
    assignment                     shift and go to state 42
    conditional                    shift and go to state 43
    logical_or                     shift and go to state 44
    logical_and                    shift and go to state 45
    bit_or                         shift and go to state 46
    xor                            shift and go to state 47
    bit_and                        shift and go to state 48
    equality                       shift and go to state 49
    relational                     shift and go to state 50
    additive                       shift and go to state 51
    multiplicative                 shift and go to state 52
    unary                          shift and go to state 54
    postfix                        shift and go to state 55
    primary                        shift and go to state 58

state 183

    (21) statement_unmatched -> If LParen . expression RParen statement_matched Else statement_unmatched
    (22) statement_unmatched -> If LParen . expression RParen statement
    (40) expression -> . assignment
    (41) assignment -> . conditional
    (61) assignment -> . Identifier Assign expression
    (42) conditional -> . logical_or
    (78) conditional -> . logical_or Question expression Colon conditional
    (43) logical_or -> . logical_and
    (62) logical_or -> . logical_or Or logical_and
    (44) logical_and -> . bit_or
    (63) logical_and -> . logical_and And bit_or
    (45) bit_or -> . xor
    (64) bit_or -> . bit_or BitOr xor
    (46) xor -> . bit_and
    (65) xor -> . xor Xor bit_and
    (47) bit_and -> . equality
    (66) bit_and -> . bit_and BitAnd equality
    (48) equality -> . relational
    (67) equality -> . equality NotEqual relational
    (68) equality -> . equality Equal relational
    (49) relational -> . additive
    (69) relational -> . relational Less additive
    (70) relational -> . relational Greater additive
    (71) relational -> . relational LessEqual additive
    (72) relational -> . relational GreaterEqual additive
    (50) additive -> . multiplicative
    (73) additive -> . additive Plus multiplicative
    (74) additive -> . additive Minus multiplicative
    (51) multiplicative -> . unary
    (75) multiplicative -> . multiplicative Mul unary
    (76) multiplicative -> . multiplicative Div unary
    (77) multiplicative -> . multiplicative Mod unary
    (52) unary -> . postfix
    (54) unary -> . Minus unary
    (55) unary -> . BitNot unary
    (56) unary -> . Not unary
    (53) postfix -> . primary
    (57) postfix -> . Identifier LParen expression_list RParen
    (79) primary -> . Integer
    (80) primary -> . Identifier
    (81) primary -> . LParen expression RParen

    Identifier      shift and go to state 23
    Minus           shift and go to state 53
    BitNot          shift and go to state 56
    Not             shift and go to state 57
    Integer         shift and go to state 59
    LParen          shift and go to state 24

    expression                     shift and go to state 191
    assignment                     shift and go to state 42
    conditional                    shift and go to state 43
    logical_or                     shift and go to state 44
    logical_and                    shift and go to state 45
    bit_or                         shift and go to state 46
    xor                            shift and go to state 47
    bit_and                        shift and go to state 48
    equality                       shift and go to state 49
    relational                     shift and go to state 50
    additive                       shift and go to state 51
    multiplicative                 shift and go to state 52
    unary                          shift and go to state 54
    postfix                        shift and go to state 55
    primary                        shift and go to state 58

state 184

    (24) statement_unmatched -> While LParen . expression RParen statement_unmatched
    (40) expression -> . assignment
    (41) assignment -> . conditional
    (61) assignment -> . Identifier Assign expression
    (42) conditional -> . logical_or
    (78) conditional -> . logical_or Question expression Colon conditional
    (43) logical_or -> . logical_and
    (62) logical_or -> . logical_or Or logical_and
    (44) logical_and -> . bit_or
    (63) logical_and -> . logical_and And bit_or
    (45) bit_or -> . xor
    (64) bit_or -> . bit_or BitOr xor
    (46) xor -> . bit_and
    (65) xor -> . xor Xor bit_and
    (47) bit_and -> . equality
    (66) bit_and -> . bit_and BitAnd equality
    (48) equality -> . relational
    (67) equality -> . equality NotEqual relational
    (68) equality -> . equality Equal relational
    (49) relational -> . additive
    (69) relational -> . relational Less additive
    (70) relational -> . relational Greater additive
    (71) relational -> . relational LessEqual additive
    (72) relational -> . relational GreaterEqual additive
    (50) additive -> . multiplicative
    (73) additive -> . additive Plus multiplicative
    (74) additive -> . additive Minus multiplicative
    (51) multiplicative -> . unary
    (75) multiplicative -> . multiplicative Mul unary
    (76) multiplicative -> . multiplicative Div unary
    (77) multiplicative -> . multiplicative Mod unary
    (52) unary -> . postfix
    (54) unary -> . Minus unary
    (55) unary -> . BitNot unary
    (56) unary -> . Not unary
    (53) postfix -> . primary
    (57) postfix -> . Identifier LParen expression_list RParen
    (79) primary -> . Integer
    (80) primary -> . Identifier
    (81) primary -> . LParen expression RParen

    Identifier      shift and go to state 23
    Minus           shift and go to state 53
    BitNot          shift and go to state 56
    Not             shift and go to state 57
    Integer         shift and go to state 59
    LParen          shift and go to state 24

    expression                     shift and go to state 192
    assignment                     shift and go to state 42
    conditional                    shift and go to state 43
    logical_or                     shift and go to state 44
    logical_and                    shift and go to state 45
    bit_or                         shift and go to state 46
    xor                            shift and go to state 47
    bit_and                        shift and go to state 48
    equality                       shift and go to state 49
    relational                     shift and go to state 50
    additive                       shift and go to state 51
    multiplicative                 shift and go to state 52
    unary                          shift and go to state 54
    postfix                        shift and go to state 55
    primary                        shift and go to state 58

state 185

    (27) statement_matched -> For LParen opt_expression Semi . opt_expression Semi opt_expression RParen statement_matched
    (36) opt_expression -> . expression
    (37) opt_expression -> . empty
    (40) expression -> . assignment
    (1) empty -> .
    (41) assignment -> . conditional
    (61) assignment -> . Identifier Assign expression
    (42) conditional -> . logical_or
    (78) conditional -> . logical_or Question expression Colon conditional
    (43) logical_or -> . logical_and
    (62) logical_or -> . logical_or Or logical_and
    (44) logical_and -> . bit_or
    (63) logical_and -> . logical_and And bit_or
    (45) bit_or -> . xor
    (64) bit_or -> . bit_or BitOr xor
    (46) xor -> . bit_and
    (65) xor -> . xor Xor bit_and
    (47) bit_and -> . equality
    (66) bit_and -> . bit_and BitAnd equality
    (48) equality -> . relational
    (67) equality -> . equality NotEqual relational
    (68) equality -> . equality Equal relational
    (49) relational -> . additive
    (69) relational -> . relational Less additive
    (70) relational -> . relational Greater additive
    (71) relational -> . relational LessEqual additive
    (72) relational -> . relational GreaterEqual additive
    (50) additive -> . multiplicative
    (73) additive -> . additive Plus multiplicative
    (74) additive -> . additive Minus multiplicative
    (51) multiplicative -> . unary
    (75) multiplicative -> . multiplicative Mul unary
    (76) multiplicative -> . multiplicative Div unary
    (77) multiplicative -> . multiplicative Mod unary
    (52) unary -> . postfix
    (54) unary -> . Minus unary
    (55) unary -> . BitNot unary
    (56) unary -> . Not unary
    (53) postfix -> . primary
    (57) postfix -> . Identifier LParen expression_list RParen
    (79) primary -> . Integer
    (80) primary -> . Identifier
    (81) primary -> . LParen expression RParen

    Semi            reduce using rule 1 (empty -> .)
    Identifier      shift and go to state 23
    Minus           shift and go to state 53
    BitNot          shift and go to state 56
    Not             shift and go to state 57
    Integer         shift and go to state 59
    LParen          shift and go to state 24

    opt_expression                 shift and go to state 193
    expression                     shift and go to state 32
    empty                          shift and go to state 41
    assignment                     shift and go to state 42
    conditional                    shift and go to state 43
    logical_or                     shift and go to state 44
    logical_and                    shift and go to state 45
    bit_or                         shift and go to state 46
    xor                            shift and go to state 47
    bit_and                        shift and go to state 48
    equality                       shift and go to state 49
    relational                     shift and go to state 50
    additive                       shift and go to state 51
    multiplicative                 shift and go to state 52
    unary                          shift and go to state 54
    postfix                        shift and go to state 55
    primary                        shift and go to state 58

state 186

    (28) statement_matched -> For LParen declaration Semi . opt_expression Semi opt_expression RParen statement_matched
    (36) opt_expression -> . expression
    (37) opt_expression -> . empty
    (40) expression -> . assignment
    (1) empty -> .
    (41) assignment -> . conditional
    (61) assignment -> . Identifier Assign expression
    (42) conditional -> . logical_or
    (78) conditional -> . logical_or Question expression Colon conditional
    (43) logical_or -> . logical_and
    (62) logical_or -> . logical_or Or logical_and
    (44) logical_and -> . bit_or
    (63) logical_and -> . logical_and And bit_or
    (45) bit_or -> . xor
    (64) bit_or -> . bit_or BitOr xor
    (46) xor -> . bit_and
    (65) xor -> . xor Xor bit_and
    (47) bit_and -> . equality
    (66) bit_and -> . bit_and BitAnd equality
    (48) equality -> . relational
    (67) equality -> . equality NotEqual relational
    (68) equality -> . equality Equal relational
    (49) relational -> . additive
    (69) relational -> . relational Less additive
    (70) relational -> . relational Greater additive
    (71) relational -> . relational LessEqual additive
    (72) relational -> . relational GreaterEqual additive
    (50) additive -> . multiplicative
    (73) additive -> . additive Plus multiplicative
    (74) additive -> . additive Minus multiplicative
    (51) multiplicative -> . unary
    (75) multiplicative -> . multiplicative Mul unary
    (76) multiplicative -> . multiplicative Div unary
    (77) multiplicative -> . multiplicative Mod unary
    (52) unary -> . postfix
    (54) unary -> . Minus unary
    (55) unary -> . BitNot unary
    (56) unary -> . Not unary
    (53) postfix -> . primary
    (57) postfix -> . Identifier LParen expression_list RParen
    (79) primary -> . Integer
    (80) primary -> . Identifier
    (81) primary -> . LParen expression RParen

    Semi            reduce using rule 1 (empty -> .)
    Identifier      shift and go to state 23
    Minus           shift and go to state 53
    BitNot          shift and go to state 56
    Not             shift and go to state 57
    Integer         shift and go to state 59
    LParen          shift and go to state 24

    opt_expression                 shift and go to state 194
    expression                     shift and go to state 32
    empty                          shift and go to state 41
    assignment                     shift and go to state 42
    conditional                    shift and go to state 43
    logical_or                     shift and go to state 44
    logical_and                    shift and go to state 45
    bit_or                         shift and go to state 46
    xor                            shift and go to state 47
    bit_and                        shift and go to state 48
    equality                       shift and go to state 49
    relational                     shift and go to state 50
    additive                       shift and go to state 51
    multiplicative                 shift and go to state 52
    unary                          shift and go to state 54
    postfix                        shift and go to state 55
    primary                        shift and go to state 58

state 187

    (20) statement_matched -> If LParen expression RParen . statement_matched Else statement_matched
    (20) statement_matched -> . If LParen expression RParen statement_matched Else statement_matched
    (23) statement_matched -> . While LParen expression RParen statement_matched
    (25) statement_matched -> . Do statement_matched While LParen expression RParen Semi
    (27) statement_matched -> . For LParen opt_expression Semi opt_expression Semi opt_expression RParen statement_matched
    (28) statement_matched -> . For LParen declaration Semi opt_expression Semi opt_expression RParen statement_matched
    (31) statement_matched -> . Return expression Semi
    (32) statement_matched -> . opt_expression Semi
    (33) statement_matched -> . LBrace block RBrace
    (34) statement_matched -> . Break Semi
    (35) statement_matched -> . Continue Semi
    (36) opt_expression -> . expression
    (37) opt_expression -> . empty
    (40) expression -> . assignment
    (1) empty -> .
    (41) assignment -> . conditional
    (61) assignment -> . Identifier Assign expression
    (42) conditional -> . logical_or
    (78) conditional -> . logical_or Question expression Colon conditional
    (43) logical_or -> . logical_and
    (62) logical_or -> . logical_or Or logical_and
    (44) logical_and -> . bit_or
    (63) logical_and -> . logical_and And bit_or
    (45) bit_or -> . xor
    (64) bit_or -> . bit_or BitOr xor
    (46) xor -> . bit_and
    (65) xor -> . xor Xor bit_and
    (47) bit_and -> . equality
    (66) bit_and -> . bit_and BitAnd equality
    (48) equality -> . relational
    (67) equality -> . equality NotEqual relational
    (68) equality -> . equality Equal relational
    (49) relational -> . additive
    (69) relational -> . relational Less additive
    (70) relational -> . relational Greater additive
    (71) relational -> . relational LessEqual additive
    (72) relational -> . relational GreaterEqual additive
    (50) additive -> . multiplicative
    (73) additive -> . additive Plus multiplicative
    (74) additive -> . additive Minus multiplicative
    (51) multiplicative -> . unary
    (75) multiplicative -> . multiplicative Mul unary
    (76) multiplicative -> . multiplicative Div unary
    (77) multiplicative -> . multiplicative Mod unary
    (52) unary -> . postfix
    (54) unary -> . Minus unary
    (55) unary -> . BitNot unary
    (56) unary -> . Not unary
    (53) postfix -> . primary
    (57) postfix -> . Identifier LParen expression_list RParen
    (79) primary -> . Integer
    (80) primary -> . Identifier
    (81) primary -> . LParen expression RParen

    If              shift and go to state 166
    While           shift and go to state 167
    Do              shift and go to state 168
    For             shift and go to state 164
    Return          shift and go to state 38
    LBrace          shift and go to state 25
    Break           shift and go to state 39
    Continue        shift and go to state 40
    Semi            reduce using rule 1 (empty -> .)
    Identifier      shift and go to state 23
    Minus           shift and go to state 53
    BitNot          shift and go to state 56
    Not             shift and go to state 57
    Integer         shift and go to state 59
    LParen          shift and go to state 24

    expression                     shift and go to state 32
    statement_matched              shift and go to state 195
    opt_expression                 shift and go to state 37
    empty                          shift and go to state 41
    assignment                     shift and go to state 42
    conditional                    shift and go to state 43
    logical_or                     shift and go to state 44
    logical_and                    shift and go to state 45
    bit_or                         shift and go to state 46
    xor                            shift and go to state 47
    bit_and                        shift and go to state 48
    equality                       shift and go to state 49
    relational                     shift and go to state 50
    additive                       shift and go to state 51
    multiplicative                 shift and go to state 52
    unary                          shift and go to state 54
    postfix                        shift and go to state 55
    primary                        shift and go to state 58

state 188

    (23) statement_matched -> While LParen expression RParen . statement_matched
    (20) statement_matched -> . If LParen expression RParen statement_matched Else statement_matched
    (23) statement_matched -> . While LParen expression RParen statement_matched
    (25) statement_matched -> . Do statement_matched While LParen expression RParen Semi
    (27) statement_matched -> . For LParen opt_expression Semi opt_expression Semi opt_expression RParen statement_matched
    (28) statement_matched -> . For LParen declaration Semi opt_expression Semi opt_expression RParen statement_matched
    (31) statement_matched -> . Return expression Semi
    (32) statement_matched -> . opt_expression Semi
    (33) statement_matched -> . LBrace block RBrace
    (34) statement_matched -> . Break Semi
    (35) statement_matched -> . Continue Semi
    (36) opt_expression -> . expression
    (37) opt_expression -> . empty
    (40) expression -> . assignment
    (1) empty -> .
    (41) assignment -> . conditional
    (61) assignment -> . Identifier Assign expression
    (42) conditional -> . logical_or
    (78) conditional -> . logical_or Question expression Colon conditional
    (43) logical_or -> . logical_and
    (62) logical_or -> . logical_or Or logical_and
    (44) logical_and -> . bit_or
    (63) logical_and -> . logical_and And bit_or
    (45) bit_or -> . xor
    (64) bit_or -> . bit_or BitOr xor
    (46) xor -> . bit_and
    (65) xor -> . xor Xor bit_and
    (47) bit_and -> . equality
    (66) bit_and -> . bit_and BitAnd equality
    (48) equality -> . relational
    (67) equality -> . equality NotEqual relational
    (68) equality -> . equality Equal relational
    (49) relational -> . additive
    (69) relational -> . relational Less additive
    (70) relational -> . relational Greater additive
    (71) relational -> . relational LessEqual additive
    (72) relational -> . relational GreaterEqual additive
    (50) additive -> . multiplicative
    (73) additive -> . additive Plus multiplicative
    (74) additive -> . additive Minus multiplicative
    (51) multiplicative -> . unary
    (75) multiplicative -> . multiplicative Mul unary
    (76) multiplicative -> . multiplicative Div unary
    (77) multiplicative -> . multiplicative Mod unary
    (52) unary -> . postfix
    (54) unary -> . Minus unary
    (55) unary -> . BitNot unary
    (56) unary -> . Not unary
    (53) postfix -> . primary
    (57) postfix -> . Identifier LParen expression_list RParen
    (79) primary -> . Integer
    (80) primary -> . Identifier
    (81) primary -> . LParen expression RParen

    If              shift and go to state 166
    While           shift and go to state 167
    Do              shift and go to state 168
    For             shift and go to state 164
    Return          shift and go to state 38
    LBrace          shift and go to state 25
    Break           shift and go to state 39
    Continue        shift and go to state 40
    Semi            reduce using rule 1 (empty -> .)
    Identifier      shift and go to state 23
    Minus           shift and go to state 53
    BitNot          shift and go to state 56
    Not             shift and go to state 57
    Integer         shift and go to state 59
    LParen          shift and go to state 24

    expression                     shift and go to state 32
    statement_matched              shift and go to state 140
    opt_expression                 shift and go to state 37
    empty                          shift and go to state 41
    assignment                     shift and go to state 42
    conditional                    shift and go to state 43
    logical_or                     shift and go to state 44
    logical_and                    shift and go to state 45
    bit_or                         shift and go to state 46
    xor                            shift and go to state 47
    bit_and                        shift and go to state 48
    equality                       shift and go to state 49
    relational                     shift and go to state 50
    additive                       shift and go to state 51
    multiplicative                 shift and go to state 52
    unary                          shift and go to state 54
    postfix                        shift and go to state 55
    primary                        shift and go to state 58

state 189

    (29) statement_unmatched -> For LParen opt_expression . Semi opt_expression Semi opt_expression RParen statement_unmatched

    Semi            shift and go to state 196


state 190

    (30) statement_unmatched -> For LParen declaration . Semi opt_expression Semi opt_expression Semi opt_expression RParen statement_unmatched

    Semi            shift and go to state 197


state 191

    (21) statement_unmatched -> If LParen expression . RParen statement_matched Else statement_unmatched
    (22) statement_unmatched -> If LParen expression . RParen statement

    RParen          shift and go to state 198


state 192

    (24) statement_unmatched -> While LParen expression . RParen statement_unmatched

    RParen          shift and go to state 199


state 193

    (27) statement_matched -> For LParen opt_expression Semi opt_expression . Semi opt_expression RParen statement_matched

    Semi            shift and go to state 200


state 194

    (28) statement_matched -> For LParen declaration Semi opt_expression . Semi opt_expression RParen statement_matched

    Semi            shift and go to state 201


state 195

    (20) statement_matched -> If LParen expression RParen statement_matched . Else statement_matched

    Else            shift and go to state 202


state 196

    (29) statement_unmatched -> For LParen opt_expression Semi . opt_expression Semi opt_expression RParen statement_unmatched
    (36) opt_expression -> . expression
    (37) opt_expression -> . empty
    (40) expression -> . assignment
    (1) empty -> .
    (41) assignment -> . conditional
    (61) assignment -> . Identifier Assign expression
    (42) conditional -> . logical_or
    (78) conditional -> . logical_or Question expression Colon conditional
    (43) logical_or -> . logical_and
    (62) logical_or -> . logical_or Or logical_and
    (44) logical_and -> . bit_or
    (63) logical_and -> . logical_and And bit_or
    (45) bit_or -> . xor
    (64) bit_or -> . bit_or BitOr xor
    (46) xor -> . bit_and
    (65) xor -> . xor Xor bit_and
    (47) bit_and -> . equality
    (66) bit_and -> . bit_and BitAnd equality
    (48) equality -> . relational
    (67) equality -> . equality NotEqual relational
    (68) equality -> . equality Equal relational
    (49) relational -> . additive
    (69) relational -> . relational Less additive
    (70) relational -> . relational Greater additive
    (71) relational -> . relational LessEqual additive
    (72) relational -> . relational GreaterEqual additive
    (50) additive -> . multiplicative
    (73) additive -> . additive Plus multiplicative
    (74) additive -> . additive Minus multiplicative
    (51) multiplicative -> . unary
    (75) multiplicative -> . multiplicative Mul unary
    (76) multiplicative -> . multiplicative Div unary
    (77) multiplicative -> . multiplicative Mod unary
    (52) unary -> . postfix
    (54) unary -> . Minus unary
    (55) unary -> . BitNot unary
    (56) unary -> . Not unary
    (53) postfix -> . primary
    (57) postfix -> . Identifier LParen expression_list RParen
    (79) primary -> . Integer
    (80) primary -> . Identifier
    (81) primary -> . LParen expression RParen

    Semi            reduce using rule 1 (empty -> .)
    Identifier      shift and go to state 23
    Minus           shift and go to state 53
    BitNot          shift and go to state 56
    Not             shift and go to state 57
    Integer         shift and go to state 59
    LParen          shift and go to state 24

    opt_expression                 shift and go to state 203
    expression                     shift and go to state 32
    empty                          shift and go to state 41
    assignment                     shift and go to state 42
    conditional                    shift and go to state 43
    logical_or                     shift and go to state 44
    logical_and                    shift and go to state 45
    bit_or                         shift and go to state 46
    xor                            shift and go to state 47
    bit_and                        shift and go to state 48
    equality                       shift and go to state 49
    relational                     shift and go to state 50
    additive                       shift and go to state 51
    multiplicative                 shift and go to state 52
    unary                          shift and go to state 54
    postfix                        shift and go to state 55
    primary                        shift and go to state 58

state 197

    (30) statement_unmatched -> For LParen declaration Semi . opt_expression Semi opt_expression Semi opt_expression RParen statement_unmatched
    (36) opt_expression -> . expression
    (37) opt_expression -> . empty
    (40) expression -> . assignment
    (1) empty -> .
    (41) assignment -> . conditional
    (61) assignment -> . Identifier Assign expression
    (42) conditional -> . logical_or
    (78) conditional -> . logical_or Question expression Colon conditional
    (43) logical_or -> . logical_and
    (62) logical_or -> . logical_or Or logical_and
    (44) logical_and -> . bit_or
    (63) logical_and -> . logical_and And bit_or
    (45) bit_or -> . xor
    (64) bit_or -> . bit_or BitOr xor
    (46) xor -> . bit_and
    (65) xor -> . xor Xor bit_and
    (47) bit_and -> . equality
    (66) bit_and -> . bit_and BitAnd equality
    (48) equality -> . relational
    (67) equality -> . equality NotEqual relational
    (68) equality -> . equality Equal relational
    (49) relational -> . additive
    (69) relational -> . relational Less additive
    (70) relational -> . relational Greater additive
    (71) relational -> . relational LessEqual additive
    (72) relational -> . relational GreaterEqual additive
    (50) additive -> . multiplicative
    (73) additive -> . additive Plus multiplicative
    (74) additive -> . additive Minus multiplicative
    (51) multiplicative -> . unary
    (75) multiplicative -> . multiplicative Mul unary
    (76) multiplicative -> . multiplicative Div unary
    (77) multiplicative -> . multiplicative Mod unary
    (52) unary -> . postfix
    (54) unary -> . Minus unary
    (55) unary -> . BitNot unary
    (56) unary -> . Not unary
    (53) postfix -> . primary
    (57) postfix -> . Identifier LParen expression_list RParen
    (79) primary -> . Integer
    (80) primary -> . Identifier
    (81) primary -> . LParen expression RParen

    Semi            reduce using rule 1 (empty -> .)
    Identifier      shift and go to state 23
    Minus           shift and go to state 53
    BitNot          shift and go to state 56
    Not             shift and go to state 57
    Integer         shift and go to state 59
    LParen          shift and go to state 24

    opt_expression                 shift and go to state 204
    expression                     shift and go to state 32
    empty                          shift and go to state 41
    assignment                     shift and go to state 42
    conditional                    shift and go to state 43
    logical_or                     shift and go to state 44
    logical_and                    shift and go to state 45
    bit_or                         shift and go to state 46
    xor                            shift and go to state 47
    bit_and                        shift and go to state 48
    equality                       shift and go to state 49
    relational                     shift and go to state 50
    additive                       shift and go to state 51
    multiplicative                 shift and go to state 52
    unary                          shift and go to state 54
    postfix                        shift and go to state 55
    primary                        shift and go to state 58

state 198

    (21) statement_unmatched -> If LParen expression RParen . statement_matched Else statement_unmatched
    (22) statement_unmatched -> If LParen expression RParen . statement
    (20) statement_matched -> . If LParen expression RParen statement_matched Else statement_matched
    (23) statement_matched -> . While LParen expression RParen statement_matched
    (25) statement_matched -> . Do statement_matched While LParen expression RParen Semi
    (27) statement_matched -> . For LParen opt_expression Semi opt_expression Semi opt_expression RParen statement_matched
    (28) statement_matched -> . For LParen declaration Semi opt_expression Semi opt_expression RParen statement_matched
    (31) statement_matched -> . Return expression Semi
    (32) statement_matched -> . opt_expression Semi
    (33) statement_matched -> . LBrace block RBrace
    (34) statement_matched -> . Break Semi
    (35) statement_matched -> . Continue Semi
    (18) statement -> . statement_matched
    (19) statement -> . statement_unmatched
    (36) opt_expression -> . expression
    (37) opt_expression -> . empty
    (21) statement_unmatched -> . If LParen expression RParen statement_matched Else statement_unmatched
    (22) statement_unmatched -> . If LParen expression RParen statement
    (24) statement_unmatched -> . While LParen expression RParen statement_unmatched
    (26) statement_unmatched -> . Do statement_unmatched While LParen expression RParen Semi
    (29) statement_unmatched -> . For LParen opt_expression Semi opt_expression Semi opt_expression RParen statement_unmatched
    (30) statement_unmatched -> . For LParen declaration Semi opt_expression Semi opt_expression Semi opt_expression RParen statement_unmatched
    (40) expression -> . assignment
    (1) empty -> .
    (41) assignment -> . conditional
    (61) assignment -> . Identifier Assign expression
    (42) conditional -> . logical_or
    (78) conditional -> . logical_or Question expression Colon conditional
    (43) logical_or -> . logical_and
    (62) logical_or -> . logical_or Or logical_and
    (44) logical_and -> . bit_or
    (63) logical_and -> . logical_and And bit_or
    (45) bit_or -> . xor
    (64) bit_or -> . bit_or BitOr xor
    (46) xor -> . bit_and
    (65) xor -> . xor Xor bit_and
    (47) bit_and -> . equality
    (66) bit_and -> . bit_and BitAnd equality
    (48) equality -> . relational
    (67) equality -> . equality NotEqual relational
    (68) equality -> . equality Equal relational
    (49) relational -> . additive
    (69) relational -> . relational Less additive
    (70) relational -> . relational Greater additive
    (71) relational -> . relational LessEqual additive
    (72) relational -> . relational GreaterEqual additive
    (50) additive -> . multiplicative
    (73) additive -> . additive Plus multiplicative
    (74) additive -> . additive Minus multiplicative
    (51) multiplicative -> . unary
    (75) multiplicative -> . multiplicative Mul unary
    (76) multiplicative -> . multiplicative Div unary
    (77) multiplicative -> . multiplicative Mod unary
    (52) unary -> . postfix
    (54) unary -> . Minus unary
    (55) unary -> . BitNot unary
    (56) unary -> . Not unary
    (53) postfix -> . primary
    (57) postfix -> . Identifier LParen expression_list RParen
    (79) primary -> . Integer
    (80) primary -> . Identifier
    (81) primary -> . LParen expression RParen

    If              shift and go to state 33
    While           shift and go to state 34
    Do              shift and go to state 35
    For             shift and go to state 36
    Return          shift and go to state 38
    LBrace          shift and go to state 25
    Break           shift and go to state 39
    Continue        shift and go to state 40
    Semi            reduce using rule 1 (empty -> .)
    Identifier      shift and go to state 23
    Minus           shift and go to state 53
    BitNot          shift and go to state 56
    Not             shift and go to state 57
    Integer         shift and go to state 59
    LParen          shift and go to state 24

    expression                     shift and go to state 32
    statement_matched              shift and go to state 205
    statement_unmatched            shift and go to state 31
    statement                      shift and go to state 139
    opt_expression                 shift and go to state 37
    empty                          shift and go to state 41
    assignment                     shift and go to state 42
    conditional                    shift and go to state 43
    logical_or                     shift and go to state 44
    logical_and                    shift and go to state 45
    bit_or                         shift and go to state 46
    xor                            shift and go to state 47
    bit_and                        shift and go to state 48
    equality                       shift and go to state 49
    relational                     shift and go to state 50
    additive                       shift and go to state 51
    multiplicative                 shift and go to state 52
    unary                          shift and go to state 54
    postfix                        shift and go to state 55
    primary                        shift and go to state 58

state 199

    (24) statement_unmatched -> While LParen expression RParen . statement_unmatched
    (21) statement_unmatched -> . If LParen expression RParen statement_matched Else statement_unmatched
    (22) statement_unmatched -> . If LParen expression RParen statement
    (24) statement_unmatched -> . While LParen expression RParen statement_unmatched
    (26) statement_unmatched -> . Do statement_unmatched While LParen expression RParen Semi
    (29) statement_unmatched -> . For LParen opt_expression Semi opt_expression Semi opt_expression RParen statement_unmatched
    (30) statement_unmatched -> . For LParen declaration Semi opt_expression Semi opt_expression Semi opt_expression RParen statement_unmatched

    If              shift and go to state 175
    While           shift and go to state 176
    Do              shift and go to state 177
    For             shift and go to state 173

    statement_unmatched            shift and go to state 141

state 200

    (27) statement_matched -> For LParen opt_expression Semi opt_expression Semi . opt_expression RParen statement_matched
    (36) opt_expression -> . expression
    (37) opt_expression -> . empty
    (40) expression -> . assignment
    (1) empty -> .
    (41) assignment -> . conditional
    (61) assignment -> . Identifier Assign expression
    (42) conditional -> . logical_or
    (78) conditional -> . logical_or Question expression Colon conditional
    (43) logical_or -> . logical_and
    (62) logical_or -> . logical_or Or logical_and
    (44) logical_and -> . bit_or
    (63) logical_and -> . logical_and And bit_or
    (45) bit_or -> . xor
    (64) bit_or -> . bit_or BitOr xor
    (46) xor -> . bit_and
    (65) xor -> . xor Xor bit_and
    (47) bit_and -> . equality
    (66) bit_and -> . bit_and BitAnd equality
    (48) equality -> . relational
    (67) equality -> . equality NotEqual relational
    (68) equality -> . equality Equal relational
    (49) relational -> . additive
    (69) relational -> . relational Less additive
    (70) relational -> . relational Greater additive
    (71) relational -> . relational LessEqual additive
    (72) relational -> . relational GreaterEqual additive
    (50) additive -> . multiplicative
    (73) additive -> . additive Plus multiplicative
    (74) additive -> . additive Minus multiplicative
    (51) multiplicative -> . unary
    (75) multiplicative -> . multiplicative Mul unary
    (76) multiplicative -> . multiplicative Div unary
    (77) multiplicative -> . multiplicative Mod unary
    (52) unary -> . postfix
    (54) unary -> . Minus unary
    (55) unary -> . BitNot unary
    (56) unary -> . Not unary
    (53) postfix -> . primary
    (57) postfix -> . Identifier LParen expression_list RParen
    (79) primary -> . Integer
    (80) primary -> . Identifier
    (81) primary -> . LParen expression RParen

    RParen          reduce using rule 1 (empty -> .)
    Identifier      shift and go to state 23
    Minus           shift and go to state 53
    BitNot          shift and go to state 56
    Not             shift and go to state 57
    Integer         shift and go to state 59
    LParen          shift and go to state 24

    opt_expression                 shift and go to state 206
    expression                     shift and go to state 32
    empty                          shift and go to state 41
    assignment                     shift and go to state 42
    conditional                    shift and go to state 43
    logical_or                     shift and go to state 44
    logical_and                    shift and go to state 45
    bit_or                         shift and go to state 46
    xor                            shift and go to state 47
    bit_and                        shift and go to state 48
    equality                       shift and go to state 49
    relational                     shift and go to state 50
    additive                       shift and go to state 51
    multiplicative                 shift and go to state 52
    unary                          shift and go to state 54
    postfix                        shift and go to state 55
    primary                        shift and go to state 58

state 201

    (28) statement_matched -> For LParen declaration Semi opt_expression Semi . opt_expression RParen statement_matched
    (36) opt_expression -> . expression
    (37) opt_expression -> . empty
    (40) expression -> . assignment
    (1) empty -> .
    (41) assignment -> . conditional
    (61) assignment -> . Identifier Assign expression
    (42) conditional -> . logical_or
    (78) conditional -> . logical_or Question expression Colon conditional
    (43) logical_or -> . logical_and
    (62) logical_or -> . logical_or Or logical_and
    (44) logical_and -> . bit_or
    (63) logical_and -> . logical_and And bit_or
    (45) bit_or -> . xor
    (64) bit_or -> . bit_or BitOr xor
    (46) xor -> . bit_and
    (65) xor -> . xor Xor bit_and
    (47) bit_and -> . equality
    (66) bit_and -> . bit_and BitAnd equality
    (48) equality -> . relational
    (67) equality -> . equality NotEqual relational
    (68) equality -> . equality Equal relational
    (49) relational -> . additive
    (69) relational -> . relational Less additive
    (70) relational -> . relational Greater additive
    (71) relational -> . relational LessEqual additive
    (72) relational -> . relational GreaterEqual additive
    (50) additive -> . multiplicative
    (73) additive -> . additive Plus multiplicative
    (74) additive -> . additive Minus multiplicative
    (51) multiplicative -> . unary
    (75) multiplicative -> . multiplicative Mul unary
    (76) multiplicative -> . multiplicative Div unary
    (77) multiplicative -> . multiplicative Mod unary
    (52) unary -> . postfix
    (54) unary -> . Minus unary
    (55) unary -> . BitNot unary
    (56) unary -> . Not unary
    (53) postfix -> . primary
    (57) postfix -> . Identifier LParen expression_list RParen
    (79) primary -> . Integer
    (80) primary -> . Identifier
    (81) primary -> . LParen expression RParen

    RParen          reduce using rule 1 (empty -> .)
    Identifier      shift and go to state 23
    Minus           shift and go to state 53
    BitNot          shift and go to state 56
    Not             shift and go to state 57
    Integer         shift and go to state 59
    LParen          shift and go to state 24

    opt_expression                 shift and go to state 207
    expression                     shift and go to state 32
    empty                          shift and go to state 41
    assignment                     shift and go to state 42
    conditional                    shift and go to state 43
    logical_or                     shift and go to state 44
    logical_and                    shift and go to state 45
    bit_or                         shift and go to state 46
    xor                            shift and go to state 47
    bit_and                        shift and go to state 48
    equality                       shift and go to state 49
    relational                     shift and go to state 50
    additive                       shift and go to state 51
    multiplicative                 shift and go to state 52
    unary                          shift and go to state 54
    postfix                        shift and go to state 55
    primary                        shift and go to state 58

state 202

    (20) statement_matched -> If LParen expression RParen statement_matched Else . statement_matched
    (20) statement_matched -> . If LParen expression RParen statement_matched Else statement_matched
    (23) statement_matched -> . While LParen expression RParen statement_matched
    (25) statement_matched -> . Do statement_matched While LParen expression RParen Semi
    (27) statement_matched -> . For LParen opt_expression Semi opt_expression Semi opt_expression RParen statement_matched
    (28) statement_matched -> . For LParen declaration Semi opt_expression Semi opt_expression RParen statement_matched
    (31) statement_matched -> . Return expression Semi
    (32) statement_matched -> . opt_expression Semi
    (33) statement_matched -> . LBrace block RBrace
    (34) statement_matched -> . Break Semi
    (35) statement_matched -> . Continue Semi
    (36) opt_expression -> . expression
    (37) opt_expression -> . empty
    (40) expression -> . assignment
    (1) empty -> .
    (41) assignment -> . conditional
    (61) assignment -> . Identifier Assign expression
    (42) conditional -> . logical_or
    (78) conditional -> . logical_or Question expression Colon conditional
    (43) logical_or -> . logical_and
    (62) logical_or -> . logical_or Or logical_and
    (44) logical_and -> . bit_or
    (63) logical_and -> . logical_and And bit_or
    (45) bit_or -> . xor
    (64) bit_or -> . bit_or BitOr xor
    (46) xor -> . bit_and
    (65) xor -> . xor Xor bit_and
    (47) bit_and -> . equality
    (66) bit_and -> . bit_and BitAnd equality
    (48) equality -> . relational
    (67) equality -> . equality NotEqual relational
    (68) equality -> . equality Equal relational
    (49) relational -> . additive
    (69) relational -> . relational Less additive
    (70) relational -> . relational Greater additive
    (71) relational -> . relational LessEqual additive
    (72) relational -> . relational GreaterEqual additive
    (50) additive -> . multiplicative
    (73) additive -> . additive Plus multiplicative
    (74) additive -> . additive Minus multiplicative
    (51) multiplicative -> . unary
    (75) multiplicative -> . multiplicative Mul unary
    (76) multiplicative -> . multiplicative Div unary
    (77) multiplicative -> . multiplicative Mod unary
    (52) unary -> . postfix
    (54) unary -> . Minus unary
    (55) unary -> . BitNot unary
    (56) unary -> . Not unary
    (53) postfix -> . primary
    (57) postfix -> . Identifier LParen expression_list RParen
    (79) primary -> . Integer
    (80) primary -> . Identifier
    (81) primary -> . LParen expression RParen

    If              shift and go to state 166
    While           shift and go to state 167
    Do              shift and go to state 168
    For             shift and go to state 164
    Return          shift and go to state 38
    LBrace          shift and go to state 25
    Break           shift and go to state 39
    Continue        shift and go to state 40
    Semi            reduce using rule 1 (empty -> .)
    Identifier      shift and go to state 23
    Minus           shift and go to state 53
    BitNot          shift and go to state 56
    Not             shift and go to state 57
    Integer         shift and go to state 59
    LParen          shift and go to state 24

    expression                     shift and go to state 32
    statement_matched              shift and go to state 152
    opt_expression                 shift and go to state 37
    empty                          shift and go to state 41
    assignment                     shift and go to state 42
    conditional                    shift and go to state 43
    logical_or                     shift and go to state 44
    logical_and                    shift and go to state 45
    bit_or                         shift and go to state 46
    xor                            shift and go to state 47
    bit_and                        shift and go to state 48
    equality                       shift and go to state 49
    relational                     shift and go to state 50
    additive                       shift and go to state 51
    multiplicative                 shift and go to state 52
    unary                          shift and go to state 54
    postfix                        shift and go to state 55
    primary                        shift and go to state 58

state 203

    (29) statement_unmatched -> For LParen opt_expression Semi opt_expression . Semi opt_expression RParen statement_unmatched

    Semi            shift and go to state 208


state 204

    (30) statement_unmatched -> For LParen declaration Semi opt_expression . Semi opt_expression Semi opt_expression RParen statement_unmatched

    Semi            shift and go to state 209


state 205

    (21) statement_unmatched -> If LParen expression RParen statement_matched . Else statement_unmatched
    (18) statement -> statement_matched .

    Else            shift and go to state 210
    RBrace          reduce using rule 18 (statement -> statement_matched .)
    If              reduce using rule 18 (statement -> statement_matched .)
    While           reduce using rule 18 (statement -> statement_matched .)
    Do              reduce using rule 18 (statement -> statement_matched .)
    For             reduce using rule 18 (statement -> statement_matched .)
    Return          reduce using rule 18 (statement -> statement_matched .)
    LBrace          reduce using rule 18 (statement -> statement_matched .)
    Break           reduce using rule 18 (statement -> statement_matched .)
    Continue        reduce using rule 18 (statement -> statement_matched .)
    Int             reduce using rule 18 (statement -> statement_matched .)
    Identifier      reduce using rule 18 (statement -> statement_matched .)
    Minus           reduce using rule 18 (statement -> statement_matched .)
    BitNot          reduce using rule 18 (statement -> statement_matched .)
    Not             reduce using rule 18 (statement -> statement_matched .)
    Integer         reduce using rule 18 (statement -> statement_matched .)
    LParen          reduce using rule 18 (statement -> statement_matched .)
    Semi            reduce using rule 18 (statement -> statement_matched .)


state 206

    (27) statement_matched -> For LParen opt_expression Semi opt_expression Semi opt_expression . RParen statement_matched

    RParen          shift and go to state 211


state 207

    (28) statement_matched -> For LParen declaration Semi opt_expression Semi opt_expression . RParen statement_matched

    RParen          shift and go to state 160


state 208

    (29) statement_unmatched -> For LParen opt_expression Semi opt_expression Semi . opt_expression RParen statement_unmatched
    (36) opt_expression -> . expression
    (37) opt_expression -> . empty
    (40) expression -> . assignment
    (1) empty -> .
    (41) assignment -> . conditional
    (61) assignment -> . Identifier Assign expression
    (42) conditional -> . logical_or
    (78) conditional -> . logical_or Question expression Colon conditional
    (43) logical_or -> . logical_and
    (62) logical_or -> . logical_or Or logical_and
    (44) logical_and -> . bit_or
    (63) logical_and -> . logical_and And bit_or
    (45) bit_or -> . xor
    (64) bit_or -> . bit_or BitOr xor
    (46) xor -> . bit_and
    (65) xor -> . xor Xor bit_and
    (47) bit_and -> . equality
    (66) bit_and -> . bit_and BitAnd equality
    (48) equality -> . relational
    (67) equality -> . equality NotEqual relational
    (68) equality -> . equality Equal relational
    (49) relational -> . additive
    (69) relational -> . relational Less additive
    (70) relational -> . relational Greater additive
    (71) relational -> . relational LessEqual additive
    (72) relational -> . relational GreaterEqual additive
    (50) additive -> . multiplicative
    (73) additive -> . additive Plus multiplicative
    (74) additive -> . additive Minus multiplicative
    (51) multiplicative -> . unary
    (75) multiplicative -> . multiplicative Mul unary
    (76) multiplicative -> . multiplicative Div unary
    (77) multiplicative -> . multiplicative Mod unary
    (52) unary -> . postfix
    (54) unary -> . Minus unary
    (55) unary -> . BitNot unary
    (56) unary -> . Not unary
    (53) postfix -> . primary
    (57) postfix -> . Identifier LParen expression_list RParen
    (79) primary -> . Integer
    (80) primary -> . Identifier
    (81) primary -> . LParen expression RParen

    RParen          reduce using rule 1 (empty -> .)
    Identifier      shift and go to state 23
    Minus           shift and go to state 53
    BitNot          shift and go to state 56
    Not             shift and go to state 57
    Integer         shift and go to state 59
    LParen          shift and go to state 24

    opt_expression                 shift and go to state 212
    expression                     shift and go to state 32
    empty                          shift and go to state 41
    assignment                     shift and go to state 42
    conditional                    shift and go to state 43
    logical_or                     shift and go to state 44
    logical_and                    shift and go to state 45
    bit_or                         shift and go to state 46
    xor                            shift and go to state 47
    bit_and                        shift and go to state 48
    equality                       shift and go to state 49
    relational                     shift and go to state 50
    additive                       shift and go to state 51
    multiplicative                 shift and go to state 52
    unary                          shift and go to state 54
    postfix                        shift and go to state 55
    primary                        shift and go to state 58

state 209

    (30) statement_unmatched -> For LParen declaration Semi opt_expression Semi . opt_expression Semi opt_expression RParen statement_unmatched
    (36) opt_expression -> . expression
    (37) opt_expression -> . empty
    (40) expression -> . assignment
    (1) empty -> .
    (41) assignment -> . conditional
    (61) assignment -> . Identifier Assign expression
    (42) conditional -> . logical_or
    (78) conditional -> . logical_or Question expression Colon conditional
    (43) logical_or -> . logical_and
    (62) logical_or -> . logical_or Or logical_and
    (44) logical_and -> . bit_or
    (63) logical_and -> . logical_and And bit_or
    (45) bit_or -> . xor
    (64) bit_or -> . bit_or BitOr xor
    (46) xor -> . bit_and
    (65) xor -> . xor Xor bit_and
    (47) bit_and -> . equality
    (66) bit_and -> . bit_and BitAnd equality
    (48) equality -> . relational
    (67) equality -> . equality NotEqual relational
    (68) equality -> . equality Equal relational
    (49) relational -> . additive
    (69) relational -> . relational Less additive
    (70) relational -> . relational Greater additive
    (71) relational -> . relational LessEqual additive
    (72) relational -> . relational GreaterEqual additive
    (50) additive -> . multiplicative
    (73) additive -> . additive Plus multiplicative
    (74) additive -> . additive Minus multiplicative
    (51) multiplicative -> . unary
    (75) multiplicative -> . multiplicative Mul unary
    (76) multiplicative -> . multiplicative Div unary
    (77) multiplicative -> . multiplicative Mod unary
    (52) unary -> . postfix
    (54) unary -> . Minus unary
    (55) unary -> . BitNot unary
    (56) unary -> . Not unary
    (53) postfix -> . primary
    (57) postfix -> . Identifier LParen expression_list RParen
    (79) primary -> . Integer
    (80) primary -> . Identifier
    (81) primary -> . LParen expression RParen

    Semi            reduce using rule 1 (empty -> .)
    Identifier      shift and go to state 23
    Minus           shift and go to state 53
    BitNot          shift and go to state 56
    Not             shift and go to state 57
    Integer         shift and go to state 59
    LParen          shift and go to state 24

    opt_expression                 shift and go to state 213
    expression                     shift and go to state 32
    empty                          shift and go to state 41
    assignment                     shift and go to state 42
    conditional                    shift and go to state 43
    logical_or                     shift and go to state 44
    logical_and                    shift and go to state 45
    bit_or                         shift and go to state 46
    xor                            shift and go to state 47
    bit_and                        shift and go to state 48
    equality                       shift and go to state 49
    relational                     shift and go to state 50
    additive                       shift and go to state 51
    multiplicative                 shift and go to state 52
    unary                          shift and go to state 54
    postfix                        shift and go to state 55
    primary                        shift and go to state 58

state 210

    (21) statement_unmatched -> If LParen expression RParen statement_matched Else . statement_unmatched
    (21) statement_unmatched -> . If LParen expression RParen statement_matched Else statement_unmatched
    (22) statement_unmatched -> . If LParen expression RParen statement
    (24) statement_unmatched -> . While LParen expression RParen statement_unmatched
    (26) statement_unmatched -> . Do statement_unmatched While LParen expression RParen Semi
    (29) statement_unmatched -> . For LParen opt_expression Semi opt_expression Semi opt_expression RParen statement_unmatched
    (30) statement_unmatched -> . For LParen declaration Semi opt_expression Semi opt_expression Semi opt_expression RParen statement_unmatched

    If              shift and go to state 175
    While           shift and go to state 176
    Do              shift and go to state 177
    For             shift and go to state 173

    statement_unmatched            shift and go to state 153

state 211

    (27) statement_matched -> For LParen opt_expression Semi opt_expression Semi opt_expression RParen . statement_matched
    (20) statement_matched -> . If LParen expression RParen statement_matched Else statement_matched
    (23) statement_matched -> . While LParen expression RParen statement_matched
    (25) statement_matched -> . Do statement_matched While LParen expression RParen Semi
    (27) statement_matched -> . For LParen opt_expression Semi opt_expression Semi opt_expression RParen statement_matched
    (28) statement_matched -> . For LParen declaration Semi opt_expression Semi opt_expression RParen statement_matched
    (31) statement_matched -> . Return expression Semi
    (32) statement_matched -> . opt_expression Semi
    (33) statement_matched -> . LBrace block RBrace
    (34) statement_matched -> . Break Semi
    (35) statement_matched -> . Continue Semi
    (36) opt_expression -> . expression
    (37) opt_expression -> . empty
    (40) expression -> . assignment
    (1) empty -> .
    (41) assignment -> . conditional
    (61) assignment -> . Identifier Assign expression
    (42) conditional -> . logical_or
    (78) conditional -> . logical_or Question expression Colon conditional
    (43) logical_or -> . logical_and
    (62) logical_or -> . logical_or Or logical_and
    (44) logical_and -> . bit_or
    (63) logical_and -> . logical_and And bit_or
    (45) bit_or -> . xor
    (64) bit_or -> . bit_or BitOr xor
    (46) xor -> . bit_and
    (65) xor -> . xor Xor bit_and
    (47) bit_and -> . equality
    (66) bit_and -> . bit_and BitAnd equality
    (48) equality -> . relational
    (67) equality -> . equality NotEqual relational
    (68) equality -> . equality Equal relational
    (49) relational -> . additive
    (69) relational -> . relational Less additive
    (70) relational -> . relational Greater additive
    (71) relational -> . relational LessEqual additive
    (72) relational -> . relational GreaterEqual additive
    (50) additive -> . multiplicative
    (73) additive -> . additive Plus multiplicative
    (74) additive -> . additive Minus multiplicative
    (51) multiplicative -> . unary
    (75) multiplicative -> . multiplicative Mul unary
    (76) multiplicative -> . multiplicative Div unary
    (77) multiplicative -> . multiplicative Mod unary
    (52) unary -> . postfix
    (54) unary -> . Minus unary
    (55) unary -> . BitNot unary
    (56) unary -> . Not unary
    (53) postfix -> . primary
    (57) postfix -> . Identifier LParen expression_list RParen
    (79) primary -> . Integer
    (80) primary -> . Identifier
    (81) primary -> . LParen expression RParen

    If              shift and go to state 166
    While           shift and go to state 167
    Do              shift and go to state 168
    For             shift and go to state 164
    Return          shift and go to state 38
    LBrace          shift and go to state 25
    Break           shift and go to state 39
    Continue        shift and go to state 40
    Semi            reduce using rule 1 (empty -> .)
    Identifier      shift and go to state 23
    Minus           shift and go to state 53
    BitNot          shift and go to state 56
    Not             shift and go to state 57
    Integer         shift and go to state 59
    LParen          shift and go to state 24

    opt_expression                 shift and go to state 37
    statement_matched              shift and go to state 161
    expression                     shift and go to state 32
    empty                          shift and go to state 41
    assignment                     shift and go to state 42
    conditional                    shift and go to state 43
    logical_or                     shift and go to state 44
    logical_and                    shift and go to state 45
    bit_or                         shift and go to state 46
    xor                            shift and go to state 47
    bit_and                        shift and go to state 48
    equality                       shift and go to state 49
    relational                     shift and go to state 50
    additive                       shift and go to state 51
    multiplicative                 shift and go to state 52
    unary                          shift and go to state 54
    postfix                        shift and go to state 55
    primary                        shift and go to state 58

state 212

    (29) statement_unmatched -> For LParen opt_expression Semi opt_expression Semi opt_expression . RParen statement_unmatched

    RParen          shift and go to state 214


state 213

    (30) statement_unmatched -> For LParen declaration Semi opt_expression Semi opt_expression . Semi opt_expression RParen statement_unmatched

    Semi            shift and go to state 159


state 214

    (29) statement_unmatched -> For LParen opt_expression Semi opt_expression Semi opt_expression RParen . statement_unmatched
    (21) statement_unmatched -> . If LParen expression RParen statement_matched Else statement_unmatched
    (22) statement_unmatched -> . If LParen expression RParen statement
    (24) statement_unmatched -> . While LParen expression RParen statement_unmatched
    (26) statement_unmatched -> . Do statement_unmatched While LParen expression RParen Semi
    (29) statement_unmatched -> . For LParen opt_expression Semi opt_expression Semi opt_expression RParen statement_unmatched
    (30) statement_unmatched -> . For LParen declaration Semi opt_expression Semi opt_expression Semi opt_expression RParen statement_unmatched

    If              shift and go to state 175
    While           shift and go to state 176
    Do              shift and go to state 177
    For             shift and go to state 173

    statement_unmatched            shift and go to state 162
