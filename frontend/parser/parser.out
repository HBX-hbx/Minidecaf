Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Grammar

Rule 0     S' -> program
Rule 1     empty -> <empty>
Rule 2     program -> program function
Rule 3     program -> program declaration Semi
Rule 4     program -> empty
Rule 5     type -> Int
Rule 6     function -> function_def
Rule 7     function -> function_decl
Rule 8     function_def -> type Identifier LParen parameter_list RParen LBrace block RBrace
Rule 9     function_decl -> type Identifier LParen parameter_list RParen Semi
Rule 10    parameter_list -> parameter_list Comma type_identifier_union
Rule 11    parameter_list -> type_identifier_union
Rule 12    int_index_list -> LBrack Integer RBrack int_index_list
Rule 13    int_index_list -> empty
Rule 14    type_identifier_union -> type
Rule 15    type_identifier_union -> type Identifier int_index_list
Rule 16    type_identifier_union -> type Identifier LBrack RBrack int_index_list
Rule 17    parameter_list -> empty
Rule 18    block -> block block_item
Rule 19    block -> empty
Rule 20    block_item -> statement
Rule 21    block_item -> declaration Semi
Rule 22    statement_matched -> If LParen expression RParen statement_matched Else statement_matched
Rule 23    statement_unmatched -> If LParen expression RParen statement_matched Else statement_unmatched
Rule 24    statement_unmatched -> If LParen expression RParen statement
Rule 25    statement -> statement_matched
Rule 26    statement -> statement_unmatched
Rule 27    statement_matched -> While LParen expression RParen statement_matched
Rule 28    statement_unmatched -> While LParen expression RParen statement_unmatched
Rule 29    statement_matched -> Do statement_matched While LParen expression RParen Semi
Rule 30    statement_unmatched -> Do statement_unmatched While LParen expression RParen Semi
Rule 31    statement_matched -> For LParen p_decl_opt_expr_union Semi opt_expression Semi opt_expression RParen statement_matched
Rule 32    statement_unmatched -> For LParen p_decl_opt_expr_union Semi opt_expression Semi opt_expression RParen statement_unmatched
Rule 33    p_decl_opt_expr_union -> declaration
Rule 34    p_decl_opt_expr_union -> opt_expression
Rule 35    statement_matched -> Return expression Semi
Rule 36    statement_matched -> opt_expression Semi
Rule 37    statement_matched -> LBrace block RBrace
Rule 38    statement_matched -> Break Semi
Rule 39    statement_matched -> Continue Semi
Rule 40    opt_expression -> expression
Rule 41    opt_expression -> empty
Rule 42    declaration -> type Identifier
Rule 43    declaration -> type Identifier index_list
Rule 44    declaration -> type Identifier Assign expression
Rule 45    declaration -> type Identifier index_list Assign LBrace array_init_list RBrace
Rule 46    array_init_list -> array_init_list Comma Integer
Rule 47    array_init_list -> Integer
Rule 48    array_init_list -> empty
Rule 49    index_list -> index_list_r LBrack expression RBrack
Rule 50    index_list_r -> index_list_r LBrack expression RBrack
Rule 51    index_list_r -> empty
Rule 52    expression -> assignment
Rule 53    assignment -> conditional
Rule 54    conditional -> logical_or
Rule 55    logical_or -> logical_and
Rule 56    logical_and -> bit_or
Rule 57    bit_or -> xor
Rule 58    xor -> bit_and
Rule 59    bit_and -> equality
Rule 60    equality -> relational
Rule 61    relational -> additive
Rule 62    additive -> multiplicative
Rule 63    multiplicative -> unary
Rule 64    unary -> postfix
Rule 65    postfix -> primary
Rule 66    unary -> Minus unary
Rule 67    unary -> BitNot unary
Rule 68    unary -> Not unary
Rule 69    assignment -> Identifier index_list Assign expression
Rule 70    postfix -> Identifier LParen expression_list RParen
Rule 71    postfix -> Identifier index_list
Rule 72    expression_list -> expression_list Comma expression
Rule 73    expression_list -> expression
Rule 74    expression_list -> empty
Rule 75    assignment -> Identifier Assign expression
Rule 76    logical_or -> logical_or Or logical_and
Rule 77    logical_and -> logical_and And bit_or
Rule 78    bit_or -> bit_or BitOr xor
Rule 79    xor -> xor Xor bit_and
Rule 80    bit_and -> bit_and BitAnd equality
Rule 81    equality -> equality NotEqual relational
Rule 82    equality -> equality Equal relational
Rule 83    relational -> relational Less additive
Rule 84    relational -> relational Greater additive
Rule 85    relational -> relational LessEqual additive
Rule 86    relational -> relational GreaterEqual additive
Rule 87    additive -> additive Plus multiplicative
Rule 88    additive -> additive Minus multiplicative
Rule 89    multiplicative -> multiplicative Mul unary
Rule 90    multiplicative -> multiplicative Div unary
Rule 91    multiplicative -> multiplicative Mod unary
Rule 92    conditional -> logical_or Question expression Colon conditional
Rule 93    primary -> Integer
Rule 94    primary -> Identifier
Rule 95    primary -> LParen expression RParen

Terminals, with rules where they appear

And                  : 77
Assign               : 44 45 69 75
BitAnd               : 80
BitNot               : 67
BitOr                : 78
Break                : 38
Colon                : 92
Comma                : 10 46 72
Continue             : 39
Div                  : 90
Do                   : 29 30
Else                 : 22 23
Equal                : 82
For                  : 31 32
Greater              : 84
GreaterEqual         : 86
Identifier           : 8 9 15 16 42 43 44 45 69 70 71 75 94
If                   : 22 23 24
Int                  : 5
Integer              : 12 46 47 93
LBrace               : 8 37 45
LBrack               : 12 16 49 50
LParen               : 8 9 22 23 24 27 28 29 30 31 32 70 95
Less                 : 83
LessEqual            : 85
Minus                : 66 88
Mod                  : 91
Mul                  : 89
Not                  : 68
NotEqual             : 81
Or                   : 76
Plus                 : 87
Question             : 92
RBrace               : 8 37 45
RBrack               : 12 16 49 50
RParen               : 8 9 22 23 24 27 28 29 30 31 32 70 95
Return               : 35
Semi                 : 3 9 21 29 30 31 31 32 32 35 36 38 39
While                : 27 28 29 30
Xor                  : 79
error                : 

Nonterminals, with rules where they appear

additive             : 61 83 84 85 86 87 88
array_init_list      : 45 46
assignment           : 52
bit_and              : 58 79 80
bit_or               : 56 77 78
block                : 8 18 37
block_item           : 18
conditional          : 53 92
declaration          : 3 21 33
empty                : 4 13 17 19 41 48 51 74
equality             : 59 80 81 82
expression           : 22 23 24 27 28 29 30 35 40 44 49 50 69 72 73 75 92 95
expression_list      : 70 72
function             : 2
function_decl        : 7
function_def         : 6
index_list           : 43 45 69 71
index_list_r         : 49 50
int_index_list       : 12 15 16
logical_and          : 55 76 77
logical_or           : 54 76 92
multiplicative       : 62 87 88 89 90 91
opt_expression       : 31 31 32 32 34 36
p_decl_opt_expr_union : 31 32
parameter_list       : 8 9 10
postfix              : 64
primary              : 65
program              : 2 3 0
relational           : 60 81 82 83 84 85 86
statement            : 20 24
statement_matched    : 22 22 23 25 27 29 31
statement_unmatched  : 23 26 28 30 32
type                 : 8 9 14 15 16 42 43 44 45
type_identifier_union : 10 11
unary                : 63 66 67 68 89 90 91
xor                  : 57 78 79

Parsing method: LALR

state 0

    (0) S' -> . program
    (2) program -> . program function
    (3) program -> . program declaration Semi
    (4) program -> . empty
    (1) empty -> .

    Int             reduce using rule 1 (empty -> .)
    $end            reduce using rule 1 (empty -> .)

    program                        shift and go to state 1
    empty                          shift and go to state 2

state 1

    (0) S' -> program .
    (2) program -> program . function
    (3) program -> program . declaration Semi
    (6) function -> . function_def
    (7) function -> . function_decl
    (42) declaration -> . type Identifier
    (43) declaration -> . type Identifier index_list
    (44) declaration -> . type Identifier Assign expression
    (45) declaration -> . type Identifier index_list Assign LBrace array_init_list RBrace
    (8) function_def -> . type Identifier LParen parameter_list RParen LBrace block RBrace
    (9) function_decl -> . type Identifier LParen parameter_list RParen Semi
    (5) type -> . Int

    Int             shift and go to state 8

    function                       shift and go to state 3
    declaration                    shift and go to state 4
    function_def                   shift and go to state 5
    function_decl                  shift and go to state 6
    type                           shift and go to state 7

state 2

    (4) program -> empty .

    Int             reduce using rule 4 (program -> empty .)
    $end            reduce using rule 4 (program -> empty .)


state 3

    (2) program -> program function .

    Int             reduce using rule 2 (program -> program function .)
    $end            reduce using rule 2 (program -> program function .)


state 4

    (3) program -> program declaration . Semi

    Semi            shift and go to state 9


state 5

    (6) function -> function_def .

    Int             reduce using rule 6 (function -> function_def .)
    $end            reduce using rule 6 (function -> function_def .)


state 6

    (7) function -> function_decl .

    Int             reduce using rule 7 (function -> function_decl .)
    $end            reduce using rule 7 (function -> function_decl .)


state 7

    (42) declaration -> type . Identifier
    (43) declaration -> type . Identifier index_list
    (44) declaration -> type . Identifier Assign expression
    (45) declaration -> type . Identifier index_list Assign LBrace array_init_list RBrace
    (8) function_def -> type . Identifier LParen parameter_list RParen LBrace block RBrace
    (9) function_decl -> type . Identifier LParen parameter_list RParen Semi

    Identifier      shift and go to state 10


state 8

    (5) type -> Int .

    Identifier      reduce using rule 5 (type -> Int .)
    RParen          reduce using rule 5 (type -> Int .)
    Comma           reduce using rule 5 (type -> Int .)


state 9

    (3) program -> program declaration Semi .

    Int             reduce using rule 3 (program -> program declaration Semi .)
    $end            reduce using rule 3 (program -> program declaration Semi .)


state 10

    (42) declaration -> type Identifier .
    (43) declaration -> type Identifier . index_list
    (44) declaration -> type Identifier . Assign expression
    (45) declaration -> type Identifier . index_list Assign LBrace array_init_list RBrace
    (8) function_def -> type Identifier . LParen parameter_list RParen LBrace block RBrace
    (9) function_decl -> type Identifier . LParen parameter_list RParen Semi
    (49) index_list -> . index_list_r LBrack expression RBrack
    (50) index_list_r -> . index_list_r LBrack expression RBrack
    (51) index_list_r -> . empty
    (1) empty -> .

    Semi            reduce using rule 42 (declaration -> type Identifier .)
    Assign          shift and go to state 12
    LParen          shift and go to state 13
    LBrack          reduce using rule 1 (empty -> .)

    index_list                     shift and go to state 11
    index_list_r                   shift and go to state 14
    empty                          shift and go to state 15

state 11

    (43) declaration -> type Identifier index_list .
    (45) declaration -> type Identifier index_list . Assign LBrace array_init_list RBrace

    Semi            reduce using rule 43 (declaration -> type Identifier index_list .)
    Assign          shift and go to state 16


state 12

    (44) declaration -> type Identifier Assign . expression
    (52) expression -> . assignment
    (53) assignment -> . conditional
    (69) assignment -> . Identifier index_list Assign expression
    (75) assignment -> . Identifier Assign expression
    (54) conditional -> . logical_or
    (92) conditional -> . logical_or Question expression Colon conditional
    (55) logical_or -> . logical_and
    (76) logical_or -> . logical_or Or logical_and
    (56) logical_and -> . bit_or
    (77) logical_and -> . logical_and And bit_or
    (57) bit_or -> . xor
    (78) bit_or -> . bit_or BitOr xor
    (58) xor -> . bit_and
    (79) xor -> . xor Xor bit_and
    (59) bit_and -> . equality
    (80) bit_and -> . bit_and BitAnd equality
    (60) equality -> . relational
    (81) equality -> . equality NotEqual relational
    (82) equality -> . equality Equal relational
    (61) relational -> . additive
    (83) relational -> . relational Less additive
    (84) relational -> . relational Greater additive
    (85) relational -> . relational LessEqual additive
    (86) relational -> . relational GreaterEqual additive
    (62) additive -> . multiplicative
    (87) additive -> . additive Plus multiplicative
    (88) additive -> . additive Minus multiplicative
    (63) multiplicative -> . unary
    (89) multiplicative -> . multiplicative Mul unary
    (90) multiplicative -> . multiplicative Div unary
    (91) multiplicative -> . multiplicative Mod unary
    (64) unary -> . postfix
    (66) unary -> . Minus unary
    (67) unary -> . BitNot unary
    (68) unary -> . Not unary
    (65) postfix -> . primary
    (70) postfix -> . Identifier LParen expression_list RParen
    (71) postfix -> . Identifier index_list
    (93) primary -> . Integer
    (94) primary -> . Identifier
    (95) primary -> . LParen expression RParen

    Identifier      shift and go to state 17
    Minus           shift and go to state 30
    BitNot          shift and go to state 33
    Not             shift and go to state 34
    Integer         shift and go to state 37
    LParen          shift and go to state 36

    expression                     shift and go to state 18
    assignment                     shift and go to state 19
    conditional                    shift and go to state 20
    logical_or                     shift and go to state 21
    logical_and                    shift and go to state 22
    bit_or                         shift and go to state 23
    xor                            shift and go to state 24
    bit_and                        shift and go to state 25
    equality                       shift and go to state 26
    relational                     shift and go to state 27
    additive                       shift and go to state 28
    multiplicative                 shift and go to state 29
    unary                          shift and go to state 31
    postfix                        shift and go to state 32
    primary                        shift and go to state 35

state 13

    (8) function_def -> type Identifier LParen . parameter_list RParen LBrace block RBrace
    (9) function_decl -> type Identifier LParen . parameter_list RParen Semi
    (10) parameter_list -> . parameter_list Comma type_identifier_union
    (11) parameter_list -> . type_identifier_union
    (17) parameter_list -> . empty
    (14) type_identifier_union -> . type
    (15) type_identifier_union -> . type Identifier int_index_list
    (16) type_identifier_union -> . type Identifier LBrack RBrack int_index_list
    (1) empty -> .
    (5) type -> . Int

    RParen          reduce using rule 1 (empty -> .)
    Comma           reduce using rule 1 (empty -> .)
    Int             shift and go to state 8

    type                           shift and go to state 38
    parameter_list                 shift and go to state 39
    type_identifier_union          shift and go to state 40
    empty                          shift and go to state 41

state 14

    (49) index_list -> index_list_r . LBrack expression RBrack
    (50) index_list_r -> index_list_r . LBrack expression RBrack

    LBrack          shift and go to state 42


state 15

    (51) index_list_r -> empty .

    LBrack          reduce using rule 51 (index_list_r -> empty .)


state 16

    (45) declaration -> type Identifier index_list Assign . LBrace array_init_list RBrace

    LBrace          shift and go to state 43


state 17

    (69) assignment -> Identifier . index_list Assign expression
    (75) assignment -> Identifier . Assign expression
    (70) postfix -> Identifier . LParen expression_list RParen
    (71) postfix -> Identifier . index_list
    (94) primary -> Identifier .
    (49) index_list -> . index_list_r LBrack expression RBrack
    (50) index_list_r -> . index_list_r LBrack expression RBrack
    (51) index_list_r -> . empty
    (1) empty -> .

    Assign          shift and go to state 45
    LParen          shift and go to state 46
    Mul             reduce using rule 94 (primary -> Identifier .)
    Div             reduce using rule 94 (primary -> Identifier .)
    Mod             reduce using rule 94 (primary -> Identifier .)
    Plus            reduce using rule 94 (primary -> Identifier .)
    Minus           reduce using rule 94 (primary -> Identifier .)
    Less            reduce using rule 94 (primary -> Identifier .)
    Greater         reduce using rule 94 (primary -> Identifier .)
    LessEqual       reduce using rule 94 (primary -> Identifier .)
    GreaterEqual    reduce using rule 94 (primary -> Identifier .)
    NotEqual        reduce using rule 94 (primary -> Identifier .)
    Equal           reduce using rule 94 (primary -> Identifier .)
    BitAnd          reduce using rule 94 (primary -> Identifier .)
    Xor             reduce using rule 94 (primary -> Identifier .)
    BitOr           reduce using rule 94 (primary -> Identifier .)
    And             reduce using rule 94 (primary -> Identifier .)
    Question        reduce using rule 94 (primary -> Identifier .)
    Or              reduce using rule 94 (primary -> Identifier .)
    Semi            reduce using rule 94 (primary -> Identifier .)
    RParen          reduce using rule 94 (primary -> Identifier .)
    RBrack          reduce using rule 94 (primary -> Identifier .)
    Comma           reduce using rule 94 (primary -> Identifier .)
    Colon           reduce using rule 94 (primary -> Identifier .)
    LBrack          reduce using rule 1 (empty -> .)

    index_list                     shift and go to state 44
    index_list_r                   shift and go to state 14
    empty                          shift and go to state 15

state 18

    (44) declaration -> type Identifier Assign expression .

    Semi            reduce using rule 44 (declaration -> type Identifier Assign expression .)


state 19

    (52) expression -> assignment .

    Semi            reduce using rule 52 (expression -> assignment .)
    RParen          reduce using rule 52 (expression -> assignment .)
    RBrack          reduce using rule 52 (expression -> assignment .)
    Comma           reduce using rule 52 (expression -> assignment .)
    Colon           reduce using rule 52 (expression -> assignment .)


state 20

    (53) assignment -> conditional .

    Semi            reduce using rule 53 (assignment -> conditional .)
    RParen          reduce using rule 53 (assignment -> conditional .)
    RBrack          reduce using rule 53 (assignment -> conditional .)
    Comma           reduce using rule 53 (assignment -> conditional .)
    Colon           reduce using rule 53 (assignment -> conditional .)


state 21

    (54) conditional -> logical_or .
    (92) conditional -> logical_or . Question expression Colon conditional
    (76) logical_or -> logical_or . Or logical_and

    Semi            reduce using rule 54 (conditional -> logical_or .)
    RParen          reduce using rule 54 (conditional -> logical_or .)
    RBrack          reduce using rule 54 (conditional -> logical_or .)
    Comma           reduce using rule 54 (conditional -> logical_or .)
    Colon           reduce using rule 54 (conditional -> logical_or .)
    Question        shift and go to state 47
    Or              shift and go to state 48


state 22

    (55) logical_or -> logical_and .
    (77) logical_and -> logical_and . And bit_or

    Question        reduce using rule 55 (logical_or -> logical_and .)
    Or              reduce using rule 55 (logical_or -> logical_and .)
    Semi            reduce using rule 55 (logical_or -> logical_and .)
    RParen          reduce using rule 55 (logical_or -> logical_and .)
    RBrack          reduce using rule 55 (logical_or -> logical_and .)
    Comma           reduce using rule 55 (logical_or -> logical_and .)
    Colon           reduce using rule 55 (logical_or -> logical_and .)
    And             shift and go to state 49


state 23

    (56) logical_and -> bit_or .
    (78) bit_or -> bit_or . BitOr xor

    And             reduce using rule 56 (logical_and -> bit_or .)
    Question        reduce using rule 56 (logical_and -> bit_or .)
    Or              reduce using rule 56 (logical_and -> bit_or .)
    Semi            reduce using rule 56 (logical_and -> bit_or .)
    RParen          reduce using rule 56 (logical_and -> bit_or .)
    RBrack          reduce using rule 56 (logical_and -> bit_or .)
    Comma           reduce using rule 56 (logical_and -> bit_or .)
    Colon           reduce using rule 56 (logical_and -> bit_or .)
    BitOr           shift and go to state 50


state 24

    (57) bit_or -> xor .
    (79) xor -> xor . Xor bit_and

    BitOr           reduce using rule 57 (bit_or -> xor .)
    And             reduce using rule 57 (bit_or -> xor .)
    Question        reduce using rule 57 (bit_or -> xor .)
    Or              reduce using rule 57 (bit_or -> xor .)
    Semi            reduce using rule 57 (bit_or -> xor .)
    RParen          reduce using rule 57 (bit_or -> xor .)
    RBrack          reduce using rule 57 (bit_or -> xor .)
    Comma           reduce using rule 57 (bit_or -> xor .)
    Colon           reduce using rule 57 (bit_or -> xor .)
    Xor             shift and go to state 51


state 25

    (58) xor -> bit_and .
    (80) bit_and -> bit_and . BitAnd equality

    Xor             reduce using rule 58 (xor -> bit_and .)
    BitOr           reduce using rule 58 (xor -> bit_and .)
    And             reduce using rule 58 (xor -> bit_and .)
    Question        reduce using rule 58 (xor -> bit_and .)
    Or              reduce using rule 58 (xor -> bit_and .)
    Semi            reduce using rule 58 (xor -> bit_and .)
    RParen          reduce using rule 58 (xor -> bit_and .)
    RBrack          reduce using rule 58 (xor -> bit_and .)
    Comma           reduce using rule 58 (xor -> bit_and .)
    Colon           reduce using rule 58 (xor -> bit_and .)
    BitAnd          shift and go to state 52


state 26

    (59) bit_and -> equality .
    (81) equality -> equality . NotEqual relational
    (82) equality -> equality . Equal relational

    BitAnd          reduce using rule 59 (bit_and -> equality .)
    Xor             reduce using rule 59 (bit_and -> equality .)
    BitOr           reduce using rule 59 (bit_and -> equality .)
    And             reduce using rule 59 (bit_and -> equality .)
    Question        reduce using rule 59 (bit_and -> equality .)
    Or              reduce using rule 59 (bit_and -> equality .)
    Semi            reduce using rule 59 (bit_and -> equality .)
    RParen          reduce using rule 59 (bit_and -> equality .)
    RBrack          reduce using rule 59 (bit_and -> equality .)
    Comma           reduce using rule 59 (bit_and -> equality .)
    Colon           reduce using rule 59 (bit_and -> equality .)
    NotEqual        shift and go to state 53
    Equal           shift and go to state 54


state 27

    (60) equality -> relational .
    (83) relational -> relational . Less additive
    (84) relational -> relational . Greater additive
    (85) relational -> relational . LessEqual additive
    (86) relational -> relational . GreaterEqual additive

    NotEqual        reduce using rule 60 (equality -> relational .)
    Equal           reduce using rule 60 (equality -> relational .)
    BitAnd          reduce using rule 60 (equality -> relational .)
    Xor             reduce using rule 60 (equality -> relational .)
    BitOr           reduce using rule 60 (equality -> relational .)
    And             reduce using rule 60 (equality -> relational .)
    Question        reduce using rule 60 (equality -> relational .)
    Or              reduce using rule 60 (equality -> relational .)
    Semi            reduce using rule 60 (equality -> relational .)
    RParen          reduce using rule 60 (equality -> relational .)
    RBrack          reduce using rule 60 (equality -> relational .)
    Comma           reduce using rule 60 (equality -> relational .)
    Colon           reduce using rule 60 (equality -> relational .)
    Less            shift and go to state 55
    Greater         shift and go to state 56
    LessEqual       shift and go to state 57
    GreaterEqual    shift and go to state 58


state 28

    (61) relational -> additive .
    (87) additive -> additive . Plus multiplicative
    (88) additive -> additive . Minus multiplicative

    Less            reduce using rule 61 (relational -> additive .)
    Greater         reduce using rule 61 (relational -> additive .)
    LessEqual       reduce using rule 61 (relational -> additive .)
    GreaterEqual    reduce using rule 61 (relational -> additive .)
    NotEqual        reduce using rule 61 (relational -> additive .)
    Equal           reduce using rule 61 (relational -> additive .)
    BitAnd          reduce using rule 61 (relational -> additive .)
    Xor             reduce using rule 61 (relational -> additive .)
    BitOr           reduce using rule 61 (relational -> additive .)
    And             reduce using rule 61 (relational -> additive .)
    Question        reduce using rule 61 (relational -> additive .)
    Or              reduce using rule 61 (relational -> additive .)
    Semi            reduce using rule 61 (relational -> additive .)
    RParen          reduce using rule 61 (relational -> additive .)
    RBrack          reduce using rule 61 (relational -> additive .)
    Comma           reduce using rule 61 (relational -> additive .)
    Colon           reduce using rule 61 (relational -> additive .)
    Plus            shift and go to state 59
    Minus           shift and go to state 60


state 29

    (62) additive -> multiplicative .
    (89) multiplicative -> multiplicative . Mul unary
    (90) multiplicative -> multiplicative . Div unary
    (91) multiplicative -> multiplicative . Mod unary

    Plus            reduce using rule 62 (additive -> multiplicative .)
    Minus           reduce using rule 62 (additive -> multiplicative .)
    Less            reduce using rule 62 (additive -> multiplicative .)
    Greater         reduce using rule 62 (additive -> multiplicative .)
    LessEqual       reduce using rule 62 (additive -> multiplicative .)
    GreaterEqual    reduce using rule 62 (additive -> multiplicative .)
    NotEqual        reduce using rule 62 (additive -> multiplicative .)
    Equal           reduce using rule 62 (additive -> multiplicative .)
    BitAnd          reduce using rule 62 (additive -> multiplicative .)
    Xor             reduce using rule 62 (additive -> multiplicative .)
    BitOr           reduce using rule 62 (additive -> multiplicative .)
    And             reduce using rule 62 (additive -> multiplicative .)
    Question        reduce using rule 62 (additive -> multiplicative .)
    Or              reduce using rule 62 (additive -> multiplicative .)
    Semi            reduce using rule 62 (additive -> multiplicative .)
    RParen          reduce using rule 62 (additive -> multiplicative .)
    RBrack          reduce using rule 62 (additive -> multiplicative .)
    Comma           reduce using rule 62 (additive -> multiplicative .)
    Colon           reduce using rule 62 (additive -> multiplicative .)
    Mul             shift and go to state 61
    Div             shift and go to state 62
    Mod             shift and go to state 63


state 30

    (66) unary -> Minus . unary
    (64) unary -> . postfix
    (66) unary -> . Minus unary
    (67) unary -> . BitNot unary
    (68) unary -> . Not unary
    (65) postfix -> . primary
    (70) postfix -> . Identifier LParen expression_list RParen
    (71) postfix -> . Identifier index_list
    (93) primary -> . Integer
    (94) primary -> . Identifier
    (95) primary -> . LParen expression RParen

    Minus           shift and go to state 30
    BitNot          shift and go to state 33
    Not             shift and go to state 34
    Identifier      shift and go to state 65
    Integer         shift and go to state 37
    LParen          shift and go to state 36

    unary                          shift and go to state 64
    postfix                        shift and go to state 32
    primary                        shift and go to state 35

state 31

    (63) multiplicative -> unary .

    Mul             reduce using rule 63 (multiplicative -> unary .)
    Div             reduce using rule 63 (multiplicative -> unary .)
    Mod             reduce using rule 63 (multiplicative -> unary .)
    Plus            reduce using rule 63 (multiplicative -> unary .)
    Minus           reduce using rule 63 (multiplicative -> unary .)
    Less            reduce using rule 63 (multiplicative -> unary .)
    Greater         reduce using rule 63 (multiplicative -> unary .)
    LessEqual       reduce using rule 63 (multiplicative -> unary .)
    GreaterEqual    reduce using rule 63 (multiplicative -> unary .)
    NotEqual        reduce using rule 63 (multiplicative -> unary .)
    Equal           reduce using rule 63 (multiplicative -> unary .)
    BitAnd          reduce using rule 63 (multiplicative -> unary .)
    Xor             reduce using rule 63 (multiplicative -> unary .)
    BitOr           reduce using rule 63 (multiplicative -> unary .)
    And             reduce using rule 63 (multiplicative -> unary .)
    Question        reduce using rule 63 (multiplicative -> unary .)
    Or              reduce using rule 63 (multiplicative -> unary .)
    Semi            reduce using rule 63 (multiplicative -> unary .)
    RParen          reduce using rule 63 (multiplicative -> unary .)
    RBrack          reduce using rule 63 (multiplicative -> unary .)
    Comma           reduce using rule 63 (multiplicative -> unary .)
    Colon           reduce using rule 63 (multiplicative -> unary .)


state 32

    (64) unary -> postfix .

    Mul             reduce using rule 64 (unary -> postfix .)
    Div             reduce using rule 64 (unary -> postfix .)
    Mod             reduce using rule 64 (unary -> postfix .)
    Plus            reduce using rule 64 (unary -> postfix .)
    Minus           reduce using rule 64 (unary -> postfix .)
    Less            reduce using rule 64 (unary -> postfix .)
    Greater         reduce using rule 64 (unary -> postfix .)
    LessEqual       reduce using rule 64 (unary -> postfix .)
    GreaterEqual    reduce using rule 64 (unary -> postfix .)
    NotEqual        reduce using rule 64 (unary -> postfix .)
    Equal           reduce using rule 64 (unary -> postfix .)
    BitAnd          reduce using rule 64 (unary -> postfix .)
    Xor             reduce using rule 64 (unary -> postfix .)
    BitOr           reduce using rule 64 (unary -> postfix .)
    And             reduce using rule 64 (unary -> postfix .)
    Question        reduce using rule 64 (unary -> postfix .)
    Or              reduce using rule 64 (unary -> postfix .)
    Semi            reduce using rule 64 (unary -> postfix .)
    RParen          reduce using rule 64 (unary -> postfix .)
    RBrack          reduce using rule 64 (unary -> postfix .)
    Comma           reduce using rule 64 (unary -> postfix .)
    Colon           reduce using rule 64 (unary -> postfix .)


state 33

    (67) unary -> BitNot . unary
    (64) unary -> . postfix
    (66) unary -> . Minus unary
    (67) unary -> . BitNot unary
    (68) unary -> . Not unary
    (65) postfix -> . primary
    (70) postfix -> . Identifier LParen expression_list RParen
    (71) postfix -> . Identifier index_list
    (93) primary -> . Integer
    (94) primary -> . Identifier
    (95) primary -> . LParen expression RParen

    Minus           shift and go to state 30
    BitNot          shift and go to state 33
    Not             shift and go to state 34
    Identifier      shift and go to state 65
    Integer         shift and go to state 37
    LParen          shift and go to state 36

    unary                          shift and go to state 66
    postfix                        shift and go to state 32
    primary                        shift and go to state 35

state 34

    (68) unary -> Not . unary
    (64) unary -> . postfix
    (66) unary -> . Minus unary
    (67) unary -> . BitNot unary
    (68) unary -> . Not unary
    (65) postfix -> . primary
    (70) postfix -> . Identifier LParen expression_list RParen
    (71) postfix -> . Identifier index_list
    (93) primary -> . Integer
    (94) primary -> . Identifier
    (95) primary -> . LParen expression RParen

    Minus           shift and go to state 30
    BitNot          shift and go to state 33
    Not             shift and go to state 34
    Identifier      shift and go to state 65
    Integer         shift and go to state 37
    LParen          shift and go to state 36

    unary                          shift and go to state 67
    postfix                        shift and go to state 32
    primary                        shift and go to state 35

state 35

    (65) postfix -> primary .

    Mul             reduce using rule 65 (postfix -> primary .)
    Div             reduce using rule 65 (postfix -> primary .)
    Mod             reduce using rule 65 (postfix -> primary .)
    Plus            reduce using rule 65 (postfix -> primary .)
    Minus           reduce using rule 65 (postfix -> primary .)
    Less            reduce using rule 65 (postfix -> primary .)
    Greater         reduce using rule 65 (postfix -> primary .)
    LessEqual       reduce using rule 65 (postfix -> primary .)
    GreaterEqual    reduce using rule 65 (postfix -> primary .)
    NotEqual        reduce using rule 65 (postfix -> primary .)
    Equal           reduce using rule 65 (postfix -> primary .)
    BitAnd          reduce using rule 65 (postfix -> primary .)
    Xor             reduce using rule 65 (postfix -> primary .)
    BitOr           reduce using rule 65 (postfix -> primary .)
    And             reduce using rule 65 (postfix -> primary .)
    Question        reduce using rule 65 (postfix -> primary .)
    Or              reduce using rule 65 (postfix -> primary .)
    Semi            reduce using rule 65 (postfix -> primary .)
    RParen          reduce using rule 65 (postfix -> primary .)
    RBrack          reduce using rule 65 (postfix -> primary .)
    Comma           reduce using rule 65 (postfix -> primary .)
    Colon           reduce using rule 65 (postfix -> primary .)


state 36

    (95) primary -> LParen . expression RParen
    (52) expression -> . assignment
    (53) assignment -> . conditional
    (69) assignment -> . Identifier index_list Assign expression
    (75) assignment -> . Identifier Assign expression
    (54) conditional -> . logical_or
    (92) conditional -> . logical_or Question expression Colon conditional
    (55) logical_or -> . logical_and
    (76) logical_or -> . logical_or Or logical_and
    (56) logical_and -> . bit_or
    (77) logical_and -> . logical_and And bit_or
    (57) bit_or -> . xor
    (78) bit_or -> . bit_or BitOr xor
    (58) xor -> . bit_and
    (79) xor -> . xor Xor bit_and
    (59) bit_and -> . equality
    (80) bit_and -> . bit_and BitAnd equality
    (60) equality -> . relational
    (81) equality -> . equality NotEqual relational
    (82) equality -> . equality Equal relational
    (61) relational -> . additive
    (83) relational -> . relational Less additive
    (84) relational -> . relational Greater additive
    (85) relational -> . relational LessEqual additive
    (86) relational -> . relational GreaterEqual additive
    (62) additive -> . multiplicative
    (87) additive -> . additive Plus multiplicative
    (88) additive -> . additive Minus multiplicative
    (63) multiplicative -> . unary
    (89) multiplicative -> . multiplicative Mul unary
    (90) multiplicative -> . multiplicative Div unary
    (91) multiplicative -> . multiplicative Mod unary
    (64) unary -> . postfix
    (66) unary -> . Minus unary
    (67) unary -> . BitNot unary
    (68) unary -> . Not unary
    (65) postfix -> . primary
    (70) postfix -> . Identifier LParen expression_list RParen
    (71) postfix -> . Identifier index_list
    (93) primary -> . Integer
    (94) primary -> . Identifier
    (95) primary -> . LParen expression RParen

    Identifier      shift and go to state 17
    Minus           shift and go to state 30
    BitNot          shift and go to state 33
    Not             shift and go to state 34
    Integer         shift and go to state 37
    LParen          shift and go to state 36

    expression                     shift and go to state 68
    assignment                     shift and go to state 19
    conditional                    shift and go to state 20
    logical_or                     shift and go to state 21
    logical_and                    shift and go to state 22
    bit_or                         shift and go to state 23
    xor                            shift and go to state 24
    bit_and                        shift and go to state 25
    equality                       shift and go to state 26
    relational                     shift and go to state 27
    additive                       shift and go to state 28
    multiplicative                 shift and go to state 29
    unary                          shift and go to state 31
    postfix                        shift and go to state 32
    primary                        shift and go to state 35

state 37

    (93) primary -> Integer .

    Mul             reduce using rule 93 (primary -> Integer .)
    Div             reduce using rule 93 (primary -> Integer .)
    Mod             reduce using rule 93 (primary -> Integer .)
    Plus            reduce using rule 93 (primary -> Integer .)
    Minus           reduce using rule 93 (primary -> Integer .)
    Less            reduce using rule 93 (primary -> Integer .)
    Greater         reduce using rule 93 (primary -> Integer .)
    LessEqual       reduce using rule 93 (primary -> Integer .)
    GreaterEqual    reduce using rule 93 (primary -> Integer .)
    NotEqual        reduce using rule 93 (primary -> Integer .)
    Equal           reduce using rule 93 (primary -> Integer .)
    BitAnd          reduce using rule 93 (primary -> Integer .)
    Xor             reduce using rule 93 (primary -> Integer .)
    BitOr           reduce using rule 93 (primary -> Integer .)
    And             reduce using rule 93 (primary -> Integer .)
    Question        reduce using rule 93 (primary -> Integer .)
    Or              reduce using rule 93 (primary -> Integer .)
    Semi            reduce using rule 93 (primary -> Integer .)
    RParen          reduce using rule 93 (primary -> Integer .)
    RBrack          reduce using rule 93 (primary -> Integer .)
    Comma           reduce using rule 93 (primary -> Integer .)
    Colon           reduce using rule 93 (primary -> Integer .)


state 38

    (14) type_identifier_union -> type .
    (15) type_identifier_union -> type . Identifier int_index_list
    (16) type_identifier_union -> type . Identifier LBrack RBrack int_index_list

    RParen          reduce using rule 14 (type_identifier_union -> type .)
    Comma           reduce using rule 14 (type_identifier_union -> type .)
    Identifier      shift and go to state 69


state 39

    (8) function_def -> type Identifier LParen parameter_list . RParen LBrace block RBrace
    (9) function_decl -> type Identifier LParen parameter_list . RParen Semi
    (10) parameter_list -> parameter_list . Comma type_identifier_union

    RParen          shift and go to state 70
    Comma           shift and go to state 71


state 40

    (11) parameter_list -> type_identifier_union .

    RParen          reduce using rule 11 (parameter_list -> type_identifier_union .)
    Comma           reduce using rule 11 (parameter_list -> type_identifier_union .)


state 41

    (17) parameter_list -> empty .

    RParen          reduce using rule 17 (parameter_list -> empty .)
    Comma           reduce using rule 17 (parameter_list -> empty .)


state 42

    (49) index_list -> index_list_r LBrack . expression RBrack
    (50) index_list_r -> index_list_r LBrack . expression RBrack
    (52) expression -> . assignment
    (53) assignment -> . conditional
    (69) assignment -> . Identifier index_list Assign expression
    (75) assignment -> . Identifier Assign expression
    (54) conditional -> . logical_or
    (92) conditional -> . logical_or Question expression Colon conditional
    (55) logical_or -> . logical_and
    (76) logical_or -> . logical_or Or logical_and
    (56) logical_and -> . bit_or
    (77) logical_and -> . logical_and And bit_or
    (57) bit_or -> . xor
    (78) bit_or -> . bit_or BitOr xor
    (58) xor -> . bit_and
    (79) xor -> . xor Xor bit_and
    (59) bit_and -> . equality
    (80) bit_and -> . bit_and BitAnd equality
    (60) equality -> . relational
    (81) equality -> . equality NotEqual relational
    (82) equality -> . equality Equal relational
    (61) relational -> . additive
    (83) relational -> . relational Less additive
    (84) relational -> . relational Greater additive
    (85) relational -> . relational LessEqual additive
    (86) relational -> . relational GreaterEqual additive
    (62) additive -> . multiplicative
    (87) additive -> . additive Plus multiplicative
    (88) additive -> . additive Minus multiplicative
    (63) multiplicative -> . unary
    (89) multiplicative -> . multiplicative Mul unary
    (90) multiplicative -> . multiplicative Div unary
    (91) multiplicative -> . multiplicative Mod unary
    (64) unary -> . postfix
    (66) unary -> . Minus unary
    (67) unary -> . BitNot unary
    (68) unary -> . Not unary
    (65) postfix -> . primary
    (70) postfix -> . Identifier LParen expression_list RParen
    (71) postfix -> . Identifier index_list
    (93) primary -> . Integer
    (94) primary -> . Identifier
    (95) primary -> . LParen expression RParen

    Identifier      shift and go to state 17
    Minus           shift and go to state 30
    BitNot          shift and go to state 33
    Not             shift and go to state 34
    Integer         shift and go to state 37
    LParen          shift and go to state 36

    expression                     shift and go to state 72
    assignment                     shift and go to state 19
    conditional                    shift and go to state 20
    logical_or                     shift and go to state 21
    logical_and                    shift and go to state 22
    bit_or                         shift and go to state 23
    xor                            shift and go to state 24
    bit_and                        shift and go to state 25
    equality                       shift and go to state 26
    relational                     shift and go to state 27
    additive                       shift and go to state 28
    multiplicative                 shift and go to state 29
    unary                          shift and go to state 31
    postfix                        shift and go to state 32
    primary                        shift and go to state 35

state 43

    (45) declaration -> type Identifier index_list Assign LBrace . array_init_list RBrace
    (46) array_init_list -> . array_init_list Comma Integer
    (47) array_init_list -> . Integer
    (48) array_init_list -> . empty
    (1) empty -> .

    Integer         shift and go to state 74
    RBrace          reduce using rule 1 (empty -> .)
    Comma           reduce using rule 1 (empty -> .)

    array_init_list                shift and go to state 73
    empty                          shift and go to state 75

state 44

    (69) assignment -> Identifier index_list . Assign expression
    (71) postfix -> Identifier index_list .

    Assign          shift and go to state 76
    Mul             reduce using rule 71 (postfix -> Identifier index_list .)
    Div             reduce using rule 71 (postfix -> Identifier index_list .)
    Mod             reduce using rule 71 (postfix -> Identifier index_list .)
    Plus            reduce using rule 71 (postfix -> Identifier index_list .)
    Minus           reduce using rule 71 (postfix -> Identifier index_list .)
    Less            reduce using rule 71 (postfix -> Identifier index_list .)
    Greater         reduce using rule 71 (postfix -> Identifier index_list .)
    LessEqual       reduce using rule 71 (postfix -> Identifier index_list .)
    GreaterEqual    reduce using rule 71 (postfix -> Identifier index_list .)
    NotEqual        reduce using rule 71 (postfix -> Identifier index_list .)
    Equal           reduce using rule 71 (postfix -> Identifier index_list .)
    BitAnd          reduce using rule 71 (postfix -> Identifier index_list .)
    Xor             reduce using rule 71 (postfix -> Identifier index_list .)
    BitOr           reduce using rule 71 (postfix -> Identifier index_list .)
    And             reduce using rule 71 (postfix -> Identifier index_list .)
    Question        reduce using rule 71 (postfix -> Identifier index_list .)
    Or              reduce using rule 71 (postfix -> Identifier index_list .)
    Semi            reduce using rule 71 (postfix -> Identifier index_list .)
    RParen          reduce using rule 71 (postfix -> Identifier index_list .)
    RBrack          reduce using rule 71 (postfix -> Identifier index_list .)
    Comma           reduce using rule 71 (postfix -> Identifier index_list .)
    Colon           reduce using rule 71 (postfix -> Identifier index_list .)


state 45

    (75) assignment -> Identifier Assign . expression
    (52) expression -> . assignment
    (53) assignment -> . conditional
    (69) assignment -> . Identifier index_list Assign expression
    (75) assignment -> . Identifier Assign expression
    (54) conditional -> . logical_or
    (92) conditional -> . logical_or Question expression Colon conditional
    (55) logical_or -> . logical_and
    (76) logical_or -> . logical_or Or logical_and
    (56) logical_and -> . bit_or
    (77) logical_and -> . logical_and And bit_or
    (57) bit_or -> . xor
    (78) bit_or -> . bit_or BitOr xor
    (58) xor -> . bit_and
    (79) xor -> . xor Xor bit_and
    (59) bit_and -> . equality
    (80) bit_and -> . bit_and BitAnd equality
    (60) equality -> . relational
    (81) equality -> . equality NotEqual relational
    (82) equality -> . equality Equal relational
    (61) relational -> . additive
    (83) relational -> . relational Less additive
    (84) relational -> . relational Greater additive
    (85) relational -> . relational LessEqual additive
    (86) relational -> . relational GreaterEqual additive
    (62) additive -> . multiplicative
    (87) additive -> . additive Plus multiplicative
    (88) additive -> . additive Minus multiplicative
    (63) multiplicative -> . unary
    (89) multiplicative -> . multiplicative Mul unary
    (90) multiplicative -> . multiplicative Div unary
    (91) multiplicative -> . multiplicative Mod unary
    (64) unary -> . postfix
    (66) unary -> . Minus unary
    (67) unary -> . BitNot unary
    (68) unary -> . Not unary
    (65) postfix -> . primary
    (70) postfix -> . Identifier LParen expression_list RParen
    (71) postfix -> . Identifier index_list
    (93) primary -> . Integer
    (94) primary -> . Identifier
    (95) primary -> . LParen expression RParen

    Identifier      shift and go to state 17
    Minus           shift and go to state 30
    BitNot          shift and go to state 33
    Not             shift and go to state 34
    Integer         shift and go to state 37
    LParen          shift and go to state 36

    expression                     shift and go to state 77
    assignment                     shift and go to state 19
    conditional                    shift and go to state 20
    logical_or                     shift and go to state 21
    logical_and                    shift and go to state 22
    bit_or                         shift and go to state 23
    xor                            shift and go to state 24
    bit_and                        shift and go to state 25
    equality                       shift and go to state 26
    relational                     shift and go to state 27
    additive                       shift and go to state 28
    multiplicative                 shift and go to state 29
    unary                          shift and go to state 31
    postfix                        shift and go to state 32
    primary                        shift and go to state 35

state 46

    (70) postfix -> Identifier LParen . expression_list RParen
    (72) expression_list -> . expression_list Comma expression
    (73) expression_list -> . expression
    (74) expression_list -> . empty
    (52) expression -> . assignment
    (1) empty -> .
    (53) assignment -> . conditional
    (69) assignment -> . Identifier index_list Assign expression
    (75) assignment -> . Identifier Assign expression
    (54) conditional -> . logical_or
    (92) conditional -> . logical_or Question expression Colon conditional
    (55) logical_or -> . logical_and
    (76) logical_or -> . logical_or Or logical_and
    (56) logical_and -> . bit_or
    (77) logical_and -> . logical_and And bit_or
    (57) bit_or -> . xor
    (78) bit_or -> . bit_or BitOr xor
    (58) xor -> . bit_and
    (79) xor -> . xor Xor bit_and
    (59) bit_and -> . equality
    (80) bit_and -> . bit_and BitAnd equality
    (60) equality -> . relational
    (81) equality -> . equality NotEqual relational
    (82) equality -> . equality Equal relational
    (61) relational -> . additive
    (83) relational -> . relational Less additive
    (84) relational -> . relational Greater additive
    (85) relational -> . relational LessEqual additive
    (86) relational -> . relational GreaterEqual additive
    (62) additive -> . multiplicative
    (87) additive -> . additive Plus multiplicative
    (88) additive -> . additive Minus multiplicative
    (63) multiplicative -> . unary
    (89) multiplicative -> . multiplicative Mul unary
    (90) multiplicative -> . multiplicative Div unary
    (91) multiplicative -> . multiplicative Mod unary
    (64) unary -> . postfix
    (66) unary -> . Minus unary
    (67) unary -> . BitNot unary
    (68) unary -> . Not unary
    (65) postfix -> . primary
    (70) postfix -> . Identifier LParen expression_list RParen
    (71) postfix -> . Identifier index_list
    (93) primary -> . Integer
    (94) primary -> . Identifier
    (95) primary -> . LParen expression RParen

    RParen          reduce using rule 1 (empty -> .)
    Comma           reduce using rule 1 (empty -> .)
    Identifier      shift and go to state 17
    Minus           shift and go to state 30
    BitNot          shift and go to state 33
    Not             shift and go to state 34
    Integer         shift and go to state 37
    LParen          shift and go to state 36

    expression_list                shift and go to state 78
    expression                     shift and go to state 79
    empty                          shift and go to state 80
    assignment                     shift and go to state 19
    conditional                    shift and go to state 20
    logical_or                     shift and go to state 21
    logical_and                    shift and go to state 22
    bit_or                         shift and go to state 23
    xor                            shift and go to state 24
    bit_and                        shift and go to state 25
    equality                       shift and go to state 26
    relational                     shift and go to state 27
    additive                       shift and go to state 28
    multiplicative                 shift and go to state 29
    unary                          shift and go to state 31
    postfix                        shift and go to state 32
    primary                        shift and go to state 35

state 47

    (92) conditional -> logical_or Question . expression Colon conditional
    (52) expression -> . assignment
    (53) assignment -> . conditional
    (69) assignment -> . Identifier index_list Assign expression
    (75) assignment -> . Identifier Assign expression
    (54) conditional -> . logical_or
    (92) conditional -> . logical_or Question expression Colon conditional
    (55) logical_or -> . logical_and
    (76) logical_or -> . logical_or Or logical_and
    (56) logical_and -> . bit_or
    (77) logical_and -> . logical_and And bit_or
    (57) bit_or -> . xor
    (78) bit_or -> . bit_or BitOr xor
    (58) xor -> . bit_and
    (79) xor -> . xor Xor bit_and
    (59) bit_and -> . equality
    (80) bit_and -> . bit_and BitAnd equality
    (60) equality -> . relational
    (81) equality -> . equality NotEqual relational
    (82) equality -> . equality Equal relational
    (61) relational -> . additive
    (83) relational -> . relational Less additive
    (84) relational -> . relational Greater additive
    (85) relational -> . relational LessEqual additive
    (86) relational -> . relational GreaterEqual additive
    (62) additive -> . multiplicative
    (87) additive -> . additive Plus multiplicative
    (88) additive -> . additive Minus multiplicative
    (63) multiplicative -> . unary
    (89) multiplicative -> . multiplicative Mul unary
    (90) multiplicative -> . multiplicative Div unary
    (91) multiplicative -> . multiplicative Mod unary
    (64) unary -> . postfix
    (66) unary -> . Minus unary
    (67) unary -> . BitNot unary
    (68) unary -> . Not unary
    (65) postfix -> . primary
    (70) postfix -> . Identifier LParen expression_list RParen
    (71) postfix -> . Identifier index_list
    (93) primary -> . Integer
    (94) primary -> . Identifier
    (95) primary -> . LParen expression RParen

    Identifier      shift and go to state 17
    Minus           shift and go to state 30
    BitNot          shift and go to state 33
    Not             shift and go to state 34
    Integer         shift and go to state 37
    LParen          shift and go to state 36

    logical_or                     shift and go to state 21
    expression                     shift and go to state 81
    conditional                    shift and go to state 20
    assignment                     shift and go to state 19
    logical_and                    shift and go to state 22
    bit_or                         shift and go to state 23
    xor                            shift and go to state 24
    bit_and                        shift and go to state 25
    equality                       shift and go to state 26
    relational                     shift and go to state 27
    additive                       shift and go to state 28
    multiplicative                 shift and go to state 29
    unary                          shift and go to state 31
    postfix                        shift and go to state 32
    primary                        shift and go to state 35

state 48

    (76) logical_or -> logical_or Or . logical_and
    (56) logical_and -> . bit_or
    (77) logical_and -> . logical_and And bit_or
    (57) bit_or -> . xor
    (78) bit_or -> . bit_or BitOr xor
    (58) xor -> . bit_and
    (79) xor -> . xor Xor bit_and
    (59) bit_and -> . equality
    (80) bit_and -> . bit_and BitAnd equality
    (60) equality -> . relational
    (81) equality -> . equality NotEqual relational
    (82) equality -> . equality Equal relational
    (61) relational -> . additive
    (83) relational -> . relational Less additive
    (84) relational -> . relational Greater additive
    (85) relational -> . relational LessEqual additive
    (86) relational -> . relational GreaterEqual additive
    (62) additive -> . multiplicative
    (87) additive -> . additive Plus multiplicative
    (88) additive -> . additive Minus multiplicative
    (63) multiplicative -> . unary
    (89) multiplicative -> . multiplicative Mul unary
    (90) multiplicative -> . multiplicative Div unary
    (91) multiplicative -> . multiplicative Mod unary
    (64) unary -> . postfix
    (66) unary -> . Minus unary
    (67) unary -> . BitNot unary
    (68) unary -> . Not unary
    (65) postfix -> . primary
    (70) postfix -> . Identifier LParen expression_list RParen
    (71) postfix -> . Identifier index_list
    (93) primary -> . Integer
    (94) primary -> . Identifier
    (95) primary -> . LParen expression RParen

    Minus           shift and go to state 30
    BitNot          shift and go to state 33
    Not             shift and go to state 34
    Identifier      shift and go to state 65
    Integer         shift and go to state 37
    LParen          shift and go to state 36

    logical_and                    shift and go to state 82
    bit_or                         shift and go to state 23
    xor                            shift and go to state 24
    bit_and                        shift and go to state 25
    equality                       shift and go to state 26
    relational                     shift and go to state 27
    additive                       shift and go to state 28
    multiplicative                 shift and go to state 29
    unary                          shift and go to state 31
    postfix                        shift and go to state 32
    primary                        shift and go to state 35

state 49

    (77) logical_and -> logical_and And . bit_or
    (57) bit_or -> . xor
    (78) bit_or -> . bit_or BitOr xor
    (58) xor -> . bit_and
    (79) xor -> . xor Xor bit_and
    (59) bit_and -> . equality
    (80) bit_and -> . bit_and BitAnd equality
    (60) equality -> . relational
    (81) equality -> . equality NotEqual relational
    (82) equality -> . equality Equal relational
    (61) relational -> . additive
    (83) relational -> . relational Less additive
    (84) relational -> . relational Greater additive
    (85) relational -> . relational LessEqual additive
    (86) relational -> . relational GreaterEqual additive
    (62) additive -> . multiplicative
    (87) additive -> . additive Plus multiplicative
    (88) additive -> . additive Minus multiplicative
    (63) multiplicative -> . unary
    (89) multiplicative -> . multiplicative Mul unary
    (90) multiplicative -> . multiplicative Div unary
    (91) multiplicative -> . multiplicative Mod unary
    (64) unary -> . postfix
    (66) unary -> . Minus unary
    (67) unary -> . BitNot unary
    (68) unary -> . Not unary
    (65) postfix -> . primary
    (70) postfix -> . Identifier LParen expression_list RParen
    (71) postfix -> . Identifier index_list
    (93) primary -> . Integer
    (94) primary -> . Identifier
    (95) primary -> . LParen expression RParen

    Minus           shift and go to state 30
    BitNot          shift and go to state 33
    Not             shift and go to state 34
    Identifier      shift and go to state 65
    Integer         shift and go to state 37
    LParen          shift and go to state 36

    bit_or                         shift and go to state 83
    xor                            shift and go to state 24
    bit_and                        shift and go to state 25
    equality                       shift and go to state 26
    relational                     shift and go to state 27
    additive                       shift and go to state 28
    multiplicative                 shift and go to state 29
    unary                          shift and go to state 31
    postfix                        shift and go to state 32
    primary                        shift and go to state 35

state 50

    (78) bit_or -> bit_or BitOr . xor
    (58) xor -> . bit_and
    (79) xor -> . xor Xor bit_and
    (59) bit_and -> . equality
    (80) bit_and -> . bit_and BitAnd equality
    (60) equality -> . relational
    (81) equality -> . equality NotEqual relational
    (82) equality -> . equality Equal relational
    (61) relational -> . additive
    (83) relational -> . relational Less additive
    (84) relational -> . relational Greater additive
    (85) relational -> . relational LessEqual additive
    (86) relational -> . relational GreaterEqual additive
    (62) additive -> . multiplicative
    (87) additive -> . additive Plus multiplicative
    (88) additive -> . additive Minus multiplicative
    (63) multiplicative -> . unary
    (89) multiplicative -> . multiplicative Mul unary
    (90) multiplicative -> . multiplicative Div unary
    (91) multiplicative -> . multiplicative Mod unary
    (64) unary -> . postfix
    (66) unary -> . Minus unary
    (67) unary -> . BitNot unary
    (68) unary -> . Not unary
    (65) postfix -> . primary
    (70) postfix -> . Identifier LParen expression_list RParen
    (71) postfix -> . Identifier index_list
    (93) primary -> . Integer
    (94) primary -> . Identifier
    (95) primary -> . LParen expression RParen

    Minus           shift and go to state 30
    BitNot          shift and go to state 33
    Not             shift and go to state 34
    Identifier      shift and go to state 65
    Integer         shift and go to state 37
    LParen          shift and go to state 36

    xor                            shift and go to state 84
    bit_and                        shift and go to state 25
    equality                       shift and go to state 26
    relational                     shift and go to state 27
    additive                       shift and go to state 28
    multiplicative                 shift and go to state 29
    unary                          shift and go to state 31
    postfix                        shift and go to state 32
    primary                        shift and go to state 35

state 51

    (79) xor -> xor Xor . bit_and
    (59) bit_and -> . equality
    (80) bit_and -> . bit_and BitAnd equality
    (60) equality -> . relational
    (81) equality -> . equality NotEqual relational
    (82) equality -> . equality Equal relational
    (61) relational -> . additive
    (83) relational -> . relational Less additive
    (84) relational -> . relational Greater additive
    (85) relational -> . relational LessEqual additive
    (86) relational -> . relational GreaterEqual additive
    (62) additive -> . multiplicative
    (87) additive -> . additive Plus multiplicative
    (88) additive -> . additive Minus multiplicative
    (63) multiplicative -> . unary
    (89) multiplicative -> . multiplicative Mul unary
    (90) multiplicative -> . multiplicative Div unary
    (91) multiplicative -> . multiplicative Mod unary
    (64) unary -> . postfix
    (66) unary -> . Minus unary
    (67) unary -> . BitNot unary
    (68) unary -> . Not unary
    (65) postfix -> . primary
    (70) postfix -> . Identifier LParen expression_list RParen
    (71) postfix -> . Identifier index_list
    (93) primary -> . Integer
    (94) primary -> . Identifier
    (95) primary -> . LParen expression RParen

    Minus           shift and go to state 30
    BitNot          shift and go to state 33
    Not             shift and go to state 34
    Identifier      shift and go to state 65
    Integer         shift and go to state 37
    LParen          shift and go to state 36

    bit_and                        shift and go to state 85
    equality                       shift and go to state 26
    relational                     shift and go to state 27
    additive                       shift and go to state 28
    multiplicative                 shift and go to state 29
    unary                          shift and go to state 31
    postfix                        shift and go to state 32
    primary                        shift and go to state 35

state 52

    (80) bit_and -> bit_and BitAnd . equality
    (60) equality -> . relational
    (81) equality -> . equality NotEqual relational
    (82) equality -> . equality Equal relational
    (61) relational -> . additive
    (83) relational -> . relational Less additive
    (84) relational -> . relational Greater additive
    (85) relational -> . relational LessEqual additive
    (86) relational -> . relational GreaterEqual additive
    (62) additive -> . multiplicative
    (87) additive -> . additive Plus multiplicative
    (88) additive -> . additive Minus multiplicative
    (63) multiplicative -> . unary
    (89) multiplicative -> . multiplicative Mul unary
    (90) multiplicative -> . multiplicative Div unary
    (91) multiplicative -> . multiplicative Mod unary
    (64) unary -> . postfix
    (66) unary -> . Minus unary
    (67) unary -> . BitNot unary
    (68) unary -> . Not unary
    (65) postfix -> . primary
    (70) postfix -> . Identifier LParen expression_list RParen
    (71) postfix -> . Identifier index_list
    (93) primary -> . Integer
    (94) primary -> . Identifier
    (95) primary -> . LParen expression RParen

    Minus           shift and go to state 30
    BitNot          shift and go to state 33
    Not             shift and go to state 34
    Identifier      shift and go to state 65
    Integer         shift and go to state 37
    LParen          shift and go to state 36

    equality                       shift and go to state 86
    relational                     shift and go to state 27
    additive                       shift and go to state 28
    multiplicative                 shift and go to state 29
    unary                          shift and go to state 31
    postfix                        shift and go to state 32
    primary                        shift and go to state 35

state 53

    (81) equality -> equality NotEqual . relational
    (61) relational -> . additive
    (83) relational -> . relational Less additive
    (84) relational -> . relational Greater additive
    (85) relational -> . relational LessEqual additive
    (86) relational -> . relational GreaterEqual additive
    (62) additive -> . multiplicative
    (87) additive -> . additive Plus multiplicative
    (88) additive -> . additive Minus multiplicative
    (63) multiplicative -> . unary
    (89) multiplicative -> . multiplicative Mul unary
    (90) multiplicative -> . multiplicative Div unary
    (91) multiplicative -> . multiplicative Mod unary
    (64) unary -> . postfix
    (66) unary -> . Minus unary
    (67) unary -> . BitNot unary
    (68) unary -> . Not unary
    (65) postfix -> . primary
    (70) postfix -> . Identifier LParen expression_list RParen
    (71) postfix -> . Identifier index_list
    (93) primary -> . Integer
    (94) primary -> . Identifier
    (95) primary -> . LParen expression RParen

    Minus           shift and go to state 30
    BitNot          shift and go to state 33
    Not             shift and go to state 34
    Identifier      shift and go to state 65
    Integer         shift and go to state 37
    LParen          shift and go to state 36

    relational                     shift and go to state 87
    additive                       shift and go to state 28
    multiplicative                 shift and go to state 29
    unary                          shift and go to state 31
    postfix                        shift and go to state 32
    primary                        shift and go to state 35

state 54

    (82) equality -> equality Equal . relational
    (61) relational -> . additive
    (83) relational -> . relational Less additive
    (84) relational -> . relational Greater additive
    (85) relational -> . relational LessEqual additive
    (86) relational -> . relational GreaterEqual additive
    (62) additive -> . multiplicative
    (87) additive -> . additive Plus multiplicative
    (88) additive -> . additive Minus multiplicative
    (63) multiplicative -> . unary
    (89) multiplicative -> . multiplicative Mul unary
    (90) multiplicative -> . multiplicative Div unary
    (91) multiplicative -> . multiplicative Mod unary
    (64) unary -> . postfix
    (66) unary -> . Minus unary
    (67) unary -> . BitNot unary
    (68) unary -> . Not unary
    (65) postfix -> . primary
    (70) postfix -> . Identifier LParen expression_list RParen
    (71) postfix -> . Identifier index_list
    (93) primary -> . Integer
    (94) primary -> . Identifier
    (95) primary -> . LParen expression RParen

    Minus           shift and go to state 30
    BitNot          shift and go to state 33
    Not             shift and go to state 34
    Identifier      shift and go to state 65
    Integer         shift and go to state 37
    LParen          shift and go to state 36

    relational                     shift and go to state 88
    additive                       shift and go to state 28
    multiplicative                 shift and go to state 29
    unary                          shift and go to state 31
    postfix                        shift and go to state 32
    primary                        shift and go to state 35

state 55

    (83) relational -> relational Less . additive
    (62) additive -> . multiplicative
    (87) additive -> . additive Plus multiplicative
    (88) additive -> . additive Minus multiplicative
    (63) multiplicative -> . unary
    (89) multiplicative -> . multiplicative Mul unary
    (90) multiplicative -> . multiplicative Div unary
    (91) multiplicative -> . multiplicative Mod unary
    (64) unary -> . postfix
    (66) unary -> . Minus unary
    (67) unary -> . BitNot unary
    (68) unary -> . Not unary
    (65) postfix -> . primary
    (70) postfix -> . Identifier LParen expression_list RParen
    (71) postfix -> . Identifier index_list
    (93) primary -> . Integer
    (94) primary -> . Identifier
    (95) primary -> . LParen expression RParen

    Minus           shift and go to state 30
    BitNot          shift and go to state 33
    Not             shift and go to state 34
    Identifier      shift and go to state 65
    Integer         shift and go to state 37
    LParen          shift and go to state 36

    additive                       shift and go to state 89
    multiplicative                 shift and go to state 29
    unary                          shift and go to state 31
    postfix                        shift and go to state 32
    primary                        shift and go to state 35

state 56

    (84) relational -> relational Greater . additive
    (62) additive -> . multiplicative
    (87) additive -> . additive Plus multiplicative
    (88) additive -> . additive Minus multiplicative
    (63) multiplicative -> . unary
    (89) multiplicative -> . multiplicative Mul unary
    (90) multiplicative -> . multiplicative Div unary
    (91) multiplicative -> . multiplicative Mod unary
    (64) unary -> . postfix
    (66) unary -> . Minus unary
    (67) unary -> . BitNot unary
    (68) unary -> . Not unary
    (65) postfix -> . primary
    (70) postfix -> . Identifier LParen expression_list RParen
    (71) postfix -> . Identifier index_list
    (93) primary -> . Integer
    (94) primary -> . Identifier
    (95) primary -> . LParen expression RParen

    Minus           shift and go to state 30
    BitNot          shift and go to state 33
    Not             shift and go to state 34
    Identifier      shift and go to state 65
    Integer         shift and go to state 37
    LParen          shift and go to state 36

    additive                       shift and go to state 90
    multiplicative                 shift and go to state 29
    unary                          shift and go to state 31
    postfix                        shift and go to state 32
    primary                        shift and go to state 35

state 57

    (85) relational -> relational LessEqual . additive
    (62) additive -> . multiplicative
    (87) additive -> . additive Plus multiplicative
    (88) additive -> . additive Minus multiplicative
    (63) multiplicative -> . unary
    (89) multiplicative -> . multiplicative Mul unary
    (90) multiplicative -> . multiplicative Div unary
    (91) multiplicative -> . multiplicative Mod unary
    (64) unary -> . postfix
    (66) unary -> . Minus unary
    (67) unary -> . BitNot unary
    (68) unary -> . Not unary
    (65) postfix -> . primary
    (70) postfix -> . Identifier LParen expression_list RParen
    (71) postfix -> . Identifier index_list
    (93) primary -> . Integer
    (94) primary -> . Identifier
    (95) primary -> . LParen expression RParen

    Minus           shift and go to state 30
    BitNot          shift and go to state 33
    Not             shift and go to state 34
    Identifier      shift and go to state 65
    Integer         shift and go to state 37
    LParen          shift and go to state 36

    additive                       shift and go to state 91
    multiplicative                 shift and go to state 29
    unary                          shift and go to state 31
    postfix                        shift and go to state 32
    primary                        shift and go to state 35

state 58

    (86) relational -> relational GreaterEqual . additive
    (62) additive -> . multiplicative
    (87) additive -> . additive Plus multiplicative
    (88) additive -> . additive Minus multiplicative
    (63) multiplicative -> . unary
    (89) multiplicative -> . multiplicative Mul unary
    (90) multiplicative -> . multiplicative Div unary
    (91) multiplicative -> . multiplicative Mod unary
    (64) unary -> . postfix
    (66) unary -> . Minus unary
    (67) unary -> . BitNot unary
    (68) unary -> . Not unary
    (65) postfix -> . primary
    (70) postfix -> . Identifier LParen expression_list RParen
    (71) postfix -> . Identifier index_list
    (93) primary -> . Integer
    (94) primary -> . Identifier
    (95) primary -> . LParen expression RParen

    Minus           shift and go to state 30
    BitNot          shift and go to state 33
    Not             shift and go to state 34
    Identifier      shift and go to state 65
    Integer         shift and go to state 37
    LParen          shift and go to state 36

    additive                       shift and go to state 92
    multiplicative                 shift and go to state 29
    unary                          shift and go to state 31
    postfix                        shift and go to state 32
    primary                        shift and go to state 35

state 59

    (87) additive -> additive Plus . multiplicative
    (63) multiplicative -> . unary
    (89) multiplicative -> . multiplicative Mul unary
    (90) multiplicative -> . multiplicative Div unary
    (91) multiplicative -> . multiplicative Mod unary
    (64) unary -> . postfix
    (66) unary -> . Minus unary
    (67) unary -> . BitNot unary
    (68) unary -> . Not unary
    (65) postfix -> . primary
    (70) postfix -> . Identifier LParen expression_list RParen
    (71) postfix -> . Identifier index_list
    (93) primary -> . Integer
    (94) primary -> . Identifier
    (95) primary -> . LParen expression RParen

    Minus           shift and go to state 30
    BitNot          shift and go to state 33
    Not             shift and go to state 34
    Identifier      shift and go to state 65
    Integer         shift and go to state 37
    LParen          shift and go to state 36

    multiplicative                 shift and go to state 93
    unary                          shift and go to state 31
    postfix                        shift and go to state 32
    primary                        shift and go to state 35

state 60

    (88) additive -> additive Minus . multiplicative
    (63) multiplicative -> . unary
    (89) multiplicative -> . multiplicative Mul unary
    (90) multiplicative -> . multiplicative Div unary
    (91) multiplicative -> . multiplicative Mod unary
    (64) unary -> . postfix
    (66) unary -> . Minus unary
    (67) unary -> . BitNot unary
    (68) unary -> . Not unary
    (65) postfix -> . primary
    (70) postfix -> . Identifier LParen expression_list RParen
    (71) postfix -> . Identifier index_list
    (93) primary -> . Integer
    (94) primary -> . Identifier
    (95) primary -> . LParen expression RParen

    Minus           shift and go to state 30
    BitNot          shift and go to state 33
    Not             shift and go to state 34
    Identifier      shift and go to state 65
    Integer         shift and go to state 37
    LParen          shift and go to state 36

    multiplicative                 shift and go to state 94
    unary                          shift and go to state 31
    postfix                        shift and go to state 32
    primary                        shift and go to state 35

state 61

    (89) multiplicative -> multiplicative Mul . unary
    (64) unary -> . postfix
    (66) unary -> . Minus unary
    (67) unary -> . BitNot unary
    (68) unary -> . Not unary
    (65) postfix -> . primary
    (70) postfix -> . Identifier LParen expression_list RParen
    (71) postfix -> . Identifier index_list
    (93) primary -> . Integer
    (94) primary -> . Identifier
    (95) primary -> . LParen expression RParen

    Minus           shift and go to state 30
    BitNot          shift and go to state 33
    Not             shift and go to state 34
    Identifier      shift and go to state 65
    Integer         shift and go to state 37
    LParen          shift and go to state 36

    unary                          shift and go to state 95
    postfix                        shift and go to state 32
    primary                        shift and go to state 35

state 62

    (90) multiplicative -> multiplicative Div . unary
    (64) unary -> . postfix
    (66) unary -> . Minus unary
    (67) unary -> . BitNot unary
    (68) unary -> . Not unary
    (65) postfix -> . primary
    (70) postfix -> . Identifier LParen expression_list RParen
    (71) postfix -> . Identifier index_list
    (93) primary -> . Integer
    (94) primary -> . Identifier
    (95) primary -> . LParen expression RParen

    Minus           shift and go to state 30
    BitNot          shift and go to state 33
    Not             shift and go to state 34
    Identifier      shift and go to state 65
    Integer         shift and go to state 37
    LParen          shift and go to state 36

    unary                          shift and go to state 96
    postfix                        shift and go to state 32
    primary                        shift and go to state 35

state 63

    (91) multiplicative -> multiplicative Mod . unary
    (64) unary -> . postfix
    (66) unary -> . Minus unary
    (67) unary -> . BitNot unary
    (68) unary -> . Not unary
    (65) postfix -> . primary
    (70) postfix -> . Identifier LParen expression_list RParen
    (71) postfix -> . Identifier index_list
    (93) primary -> . Integer
    (94) primary -> . Identifier
    (95) primary -> . LParen expression RParen

    Minus           shift and go to state 30
    BitNot          shift and go to state 33
    Not             shift and go to state 34
    Identifier      shift and go to state 65
    Integer         shift and go to state 37
    LParen          shift and go to state 36

    unary                          shift and go to state 97
    postfix                        shift and go to state 32
    primary                        shift and go to state 35

state 64

    (66) unary -> Minus unary .

    Mul             reduce using rule 66 (unary -> Minus unary .)
    Div             reduce using rule 66 (unary -> Minus unary .)
    Mod             reduce using rule 66 (unary -> Minus unary .)
    Plus            reduce using rule 66 (unary -> Minus unary .)
    Minus           reduce using rule 66 (unary -> Minus unary .)
    Less            reduce using rule 66 (unary -> Minus unary .)
    Greater         reduce using rule 66 (unary -> Minus unary .)
    LessEqual       reduce using rule 66 (unary -> Minus unary .)
    GreaterEqual    reduce using rule 66 (unary -> Minus unary .)
    NotEqual        reduce using rule 66 (unary -> Minus unary .)
    Equal           reduce using rule 66 (unary -> Minus unary .)
    BitAnd          reduce using rule 66 (unary -> Minus unary .)
    Xor             reduce using rule 66 (unary -> Minus unary .)
    BitOr           reduce using rule 66 (unary -> Minus unary .)
    And             reduce using rule 66 (unary -> Minus unary .)
    Question        reduce using rule 66 (unary -> Minus unary .)
    Or              reduce using rule 66 (unary -> Minus unary .)
    Semi            reduce using rule 66 (unary -> Minus unary .)
    RParen          reduce using rule 66 (unary -> Minus unary .)
    RBrack          reduce using rule 66 (unary -> Minus unary .)
    Comma           reduce using rule 66 (unary -> Minus unary .)
    Colon           reduce using rule 66 (unary -> Minus unary .)


state 65

    (70) postfix -> Identifier . LParen expression_list RParen
    (71) postfix -> Identifier . index_list
    (94) primary -> Identifier .
    (49) index_list -> . index_list_r LBrack expression RBrack
    (50) index_list_r -> . index_list_r LBrack expression RBrack
    (51) index_list_r -> . empty
    (1) empty -> .

    LParen          shift and go to state 46
    Mul             reduce using rule 94 (primary -> Identifier .)
    Div             reduce using rule 94 (primary -> Identifier .)
    Mod             reduce using rule 94 (primary -> Identifier .)
    Plus            reduce using rule 94 (primary -> Identifier .)
    Minus           reduce using rule 94 (primary -> Identifier .)
    Less            reduce using rule 94 (primary -> Identifier .)
    Greater         reduce using rule 94 (primary -> Identifier .)
    LessEqual       reduce using rule 94 (primary -> Identifier .)
    GreaterEqual    reduce using rule 94 (primary -> Identifier .)
    NotEqual        reduce using rule 94 (primary -> Identifier .)
    Equal           reduce using rule 94 (primary -> Identifier .)
    BitAnd          reduce using rule 94 (primary -> Identifier .)
    Xor             reduce using rule 94 (primary -> Identifier .)
    BitOr           reduce using rule 94 (primary -> Identifier .)
    And             reduce using rule 94 (primary -> Identifier .)
    Question        reduce using rule 94 (primary -> Identifier .)
    Or              reduce using rule 94 (primary -> Identifier .)
    Semi            reduce using rule 94 (primary -> Identifier .)
    RParen          reduce using rule 94 (primary -> Identifier .)
    RBrack          reduce using rule 94 (primary -> Identifier .)
    Comma           reduce using rule 94 (primary -> Identifier .)
    Colon           reduce using rule 94 (primary -> Identifier .)
    LBrack          reduce using rule 1 (empty -> .)

    index_list                     shift and go to state 98
    index_list_r                   shift and go to state 14
    empty                          shift and go to state 15

state 66

    (67) unary -> BitNot unary .

    Mul             reduce using rule 67 (unary -> BitNot unary .)
    Div             reduce using rule 67 (unary -> BitNot unary .)
    Mod             reduce using rule 67 (unary -> BitNot unary .)
    Plus            reduce using rule 67 (unary -> BitNot unary .)
    Minus           reduce using rule 67 (unary -> BitNot unary .)
    Less            reduce using rule 67 (unary -> BitNot unary .)
    Greater         reduce using rule 67 (unary -> BitNot unary .)
    LessEqual       reduce using rule 67 (unary -> BitNot unary .)
    GreaterEqual    reduce using rule 67 (unary -> BitNot unary .)
    NotEqual        reduce using rule 67 (unary -> BitNot unary .)
    Equal           reduce using rule 67 (unary -> BitNot unary .)
    BitAnd          reduce using rule 67 (unary -> BitNot unary .)
    Xor             reduce using rule 67 (unary -> BitNot unary .)
    BitOr           reduce using rule 67 (unary -> BitNot unary .)
    And             reduce using rule 67 (unary -> BitNot unary .)
    Question        reduce using rule 67 (unary -> BitNot unary .)
    Or              reduce using rule 67 (unary -> BitNot unary .)
    Semi            reduce using rule 67 (unary -> BitNot unary .)
    RParen          reduce using rule 67 (unary -> BitNot unary .)
    RBrack          reduce using rule 67 (unary -> BitNot unary .)
    Comma           reduce using rule 67 (unary -> BitNot unary .)
    Colon           reduce using rule 67 (unary -> BitNot unary .)


state 67

    (68) unary -> Not unary .

    Mul             reduce using rule 68 (unary -> Not unary .)
    Div             reduce using rule 68 (unary -> Not unary .)
    Mod             reduce using rule 68 (unary -> Not unary .)
    Plus            reduce using rule 68 (unary -> Not unary .)
    Minus           reduce using rule 68 (unary -> Not unary .)
    Less            reduce using rule 68 (unary -> Not unary .)
    Greater         reduce using rule 68 (unary -> Not unary .)
    LessEqual       reduce using rule 68 (unary -> Not unary .)
    GreaterEqual    reduce using rule 68 (unary -> Not unary .)
    NotEqual        reduce using rule 68 (unary -> Not unary .)
    Equal           reduce using rule 68 (unary -> Not unary .)
    BitAnd          reduce using rule 68 (unary -> Not unary .)
    Xor             reduce using rule 68 (unary -> Not unary .)
    BitOr           reduce using rule 68 (unary -> Not unary .)
    And             reduce using rule 68 (unary -> Not unary .)
    Question        reduce using rule 68 (unary -> Not unary .)
    Or              reduce using rule 68 (unary -> Not unary .)
    Semi            reduce using rule 68 (unary -> Not unary .)
    RParen          reduce using rule 68 (unary -> Not unary .)
    RBrack          reduce using rule 68 (unary -> Not unary .)
    Comma           reduce using rule 68 (unary -> Not unary .)
    Colon           reduce using rule 68 (unary -> Not unary .)


state 68

    (95) primary -> LParen expression . RParen

    RParen          shift and go to state 99


state 69

    (15) type_identifier_union -> type Identifier . int_index_list
    (16) type_identifier_union -> type Identifier . LBrack RBrack int_index_list
    (12) int_index_list -> . LBrack Integer RBrack int_index_list
    (13) int_index_list -> . empty
    (1) empty -> .

    LBrack          shift and go to state 101
    RParen          reduce using rule 1 (empty -> .)
    Comma           reduce using rule 1 (empty -> .)

    int_index_list                 shift and go to state 100
    empty                          shift and go to state 102

state 70

    (8) function_def -> type Identifier LParen parameter_list RParen . LBrace block RBrace
    (9) function_decl -> type Identifier LParen parameter_list RParen . Semi

    LBrace          shift and go to state 103
    Semi            shift and go to state 104


state 71

    (10) parameter_list -> parameter_list Comma . type_identifier_union
    (14) type_identifier_union -> . type
    (15) type_identifier_union -> . type Identifier int_index_list
    (16) type_identifier_union -> . type Identifier LBrack RBrack int_index_list
    (5) type -> . Int

    Int             shift and go to state 8

    type_identifier_union          shift and go to state 105
    type                           shift and go to state 38

state 72

    (49) index_list -> index_list_r LBrack expression . RBrack
    (50) index_list_r -> index_list_r LBrack expression . RBrack

    RBrack          shift and go to state 106


state 73

    (45) declaration -> type Identifier index_list Assign LBrace array_init_list . RBrace
    (46) array_init_list -> array_init_list . Comma Integer

    RBrace          shift and go to state 107
    Comma           shift and go to state 108


state 74

    (47) array_init_list -> Integer .

    RBrace          reduce using rule 47 (array_init_list -> Integer .)
    Comma           reduce using rule 47 (array_init_list -> Integer .)


state 75

    (48) array_init_list -> empty .

    RBrace          reduce using rule 48 (array_init_list -> empty .)
    Comma           reduce using rule 48 (array_init_list -> empty .)


state 76

    (69) assignment -> Identifier index_list Assign . expression
    (52) expression -> . assignment
    (53) assignment -> . conditional
    (69) assignment -> . Identifier index_list Assign expression
    (75) assignment -> . Identifier Assign expression
    (54) conditional -> . logical_or
    (92) conditional -> . logical_or Question expression Colon conditional
    (55) logical_or -> . logical_and
    (76) logical_or -> . logical_or Or logical_and
    (56) logical_and -> . bit_or
    (77) logical_and -> . logical_and And bit_or
    (57) bit_or -> . xor
    (78) bit_or -> . bit_or BitOr xor
    (58) xor -> . bit_and
    (79) xor -> . xor Xor bit_and
    (59) bit_and -> . equality
    (80) bit_and -> . bit_and BitAnd equality
    (60) equality -> . relational
    (81) equality -> . equality NotEqual relational
    (82) equality -> . equality Equal relational
    (61) relational -> . additive
    (83) relational -> . relational Less additive
    (84) relational -> . relational Greater additive
    (85) relational -> . relational LessEqual additive
    (86) relational -> . relational GreaterEqual additive
    (62) additive -> . multiplicative
    (87) additive -> . additive Plus multiplicative
    (88) additive -> . additive Minus multiplicative
    (63) multiplicative -> . unary
    (89) multiplicative -> . multiplicative Mul unary
    (90) multiplicative -> . multiplicative Div unary
    (91) multiplicative -> . multiplicative Mod unary
    (64) unary -> . postfix
    (66) unary -> . Minus unary
    (67) unary -> . BitNot unary
    (68) unary -> . Not unary
    (65) postfix -> . primary
    (70) postfix -> . Identifier LParen expression_list RParen
    (71) postfix -> . Identifier index_list
    (93) primary -> . Integer
    (94) primary -> . Identifier
    (95) primary -> . LParen expression RParen

    Identifier      shift and go to state 17
    Minus           shift and go to state 30
    BitNot          shift and go to state 33
    Not             shift and go to state 34
    Integer         shift and go to state 37
    LParen          shift and go to state 36

    expression                     shift and go to state 109
    assignment                     shift and go to state 19
    conditional                    shift and go to state 20
    logical_or                     shift and go to state 21
    logical_and                    shift and go to state 22
    bit_or                         shift and go to state 23
    xor                            shift and go to state 24
    bit_and                        shift and go to state 25
    equality                       shift and go to state 26
    relational                     shift and go to state 27
    additive                       shift and go to state 28
    multiplicative                 shift and go to state 29
    unary                          shift and go to state 31
    postfix                        shift and go to state 32
    primary                        shift and go to state 35

state 77

    (75) assignment -> Identifier Assign expression .

    Semi            reduce using rule 75 (assignment -> Identifier Assign expression .)
    RParen          reduce using rule 75 (assignment -> Identifier Assign expression .)
    RBrack          reduce using rule 75 (assignment -> Identifier Assign expression .)
    Comma           reduce using rule 75 (assignment -> Identifier Assign expression .)
    Colon           reduce using rule 75 (assignment -> Identifier Assign expression .)


state 78

    (70) postfix -> Identifier LParen expression_list . RParen
    (72) expression_list -> expression_list . Comma expression

    RParen          shift and go to state 110
    Comma           shift and go to state 111


state 79

    (73) expression_list -> expression .

    RParen          reduce using rule 73 (expression_list -> expression .)
    Comma           reduce using rule 73 (expression_list -> expression .)


state 80

    (74) expression_list -> empty .

    RParen          reduce using rule 74 (expression_list -> empty .)
    Comma           reduce using rule 74 (expression_list -> empty .)


state 81

    (92) conditional -> logical_or Question expression . Colon conditional

    Colon           shift and go to state 112


state 82

    (76) logical_or -> logical_or Or logical_and .
    (77) logical_and -> logical_and . And bit_or

    Question        reduce using rule 76 (logical_or -> logical_or Or logical_and .)
    Or              reduce using rule 76 (logical_or -> logical_or Or logical_and .)
    Semi            reduce using rule 76 (logical_or -> logical_or Or logical_and .)
    RParen          reduce using rule 76 (logical_or -> logical_or Or logical_and .)
    RBrack          reduce using rule 76 (logical_or -> logical_or Or logical_and .)
    Comma           reduce using rule 76 (logical_or -> logical_or Or logical_and .)
    Colon           reduce using rule 76 (logical_or -> logical_or Or logical_and .)
    And             shift and go to state 49


state 83

    (77) logical_and -> logical_and And bit_or .
    (78) bit_or -> bit_or . BitOr xor

    And             reduce using rule 77 (logical_and -> logical_and And bit_or .)
    Question        reduce using rule 77 (logical_and -> logical_and And bit_or .)
    Or              reduce using rule 77 (logical_and -> logical_and And bit_or .)
    Semi            reduce using rule 77 (logical_and -> logical_and And bit_or .)
    RParen          reduce using rule 77 (logical_and -> logical_and And bit_or .)
    RBrack          reduce using rule 77 (logical_and -> logical_and And bit_or .)
    Comma           reduce using rule 77 (logical_and -> logical_and And bit_or .)
    Colon           reduce using rule 77 (logical_and -> logical_and And bit_or .)
    BitOr           shift and go to state 50


state 84

    (78) bit_or -> bit_or BitOr xor .
    (79) xor -> xor . Xor bit_and

    BitOr           reduce using rule 78 (bit_or -> bit_or BitOr xor .)
    And             reduce using rule 78 (bit_or -> bit_or BitOr xor .)
    Question        reduce using rule 78 (bit_or -> bit_or BitOr xor .)
    Or              reduce using rule 78 (bit_or -> bit_or BitOr xor .)
    Semi            reduce using rule 78 (bit_or -> bit_or BitOr xor .)
    RParen          reduce using rule 78 (bit_or -> bit_or BitOr xor .)
    RBrack          reduce using rule 78 (bit_or -> bit_or BitOr xor .)
    Comma           reduce using rule 78 (bit_or -> bit_or BitOr xor .)
    Colon           reduce using rule 78 (bit_or -> bit_or BitOr xor .)
    Xor             shift and go to state 51


state 85

    (79) xor -> xor Xor bit_and .
    (80) bit_and -> bit_and . BitAnd equality

    Xor             reduce using rule 79 (xor -> xor Xor bit_and .)
    BitOr           reduce using rule 79 (xor -> xor Xor bit_and .)
    And             reduce using rule 79 (xor -> xor Xor bit_and .)
    Question        reduce using rule 79 (xor -> xor Xor bit_and .)
    Or              reduce using rule 79 (xor -> xor Xor bit_and .)
    Semi            reduce using rule 79 (xor -> xor Xor bit_and .)
    RParen          reduce using rule 79 (xor -> xor Xor bit_and .)
    RBrack          reduce using rule 79 (xor -> xor Xor bit_and .)
    Comma           reduce using rule 79 (xor -> xor Xor bit_and .)
    Colon           reduce using rule 79 (xor -> xor Xor bit_and .)
    BitAnd          shift and go to state 52


state 86

    (80) bit_and -> bit_and BitAnd equality .
    (81) equality -> equality . NotEqual relational
    (82) equality -> equality . Equal relational

    BitAnd          reduce using rule 80 (bit_and -> bit_and BitAnd equality .)
    Xor             reduce using rule 80 (bit_and -> bit_and BitAnd equality .)
    BitOr           reduce using rule 80 (bit_and -> bit_and BitAnd equality .)
    And             reduce using rule 80 (bit_and -> bit_and BitAnd equality .)
    Question        reduce using rule 80 (bit_and -> bit_and BitAnd equality .)
    Or              reduce using rule 80 (bit_and -> bit_and BitAnd equality .)
    Semi            reduce using rule 80 (bit_and -> bit_and BitAnd equality .)
    RParen          reduce using rule 80 (bit_and -> bit_and BitAnd equality .)
    RBrack          reduce using rule 80 (bit_and -> bit_and BitAnd equality .)
    Comma           reduce using rule 80 (bit_and -> bit_and BitAnd equality .)
    Colon           reduce using rule 80 (bit_and -> bit_and BitAnd equality .)
    NotEqual        shift and go to state 53
    Equal           shift and go to state 54


state 87

    (81) equality -> equality NotEqual relational .
    (83) relational -> relational . Less additive
    (84) relational -> relational . Greater additive
    (85) relational -> relational . LessEqual additive
    (86) relational -> relational . GreaterEqual additive

    NotEqual        reduce using rule 81 (equality -> equality NotEqual relational .)
    Equal           reduce using rule 81 (equality -> equality NotEqual relational .)
    BitAnd          reduce using rule 81 (equality -> equality NotEqual relational .)
    Xor             reduce using rule 81 (equality -> equality NotEqual relational .)
    BitOr           reduce using rule 81 (equality -> equality NotEqual relational .)
    And             reduce using rule 81 (equality -> equality NotEqual relational .)
    Question        reduce using rule 81 (equality -> equality NotEqual relational .)
    Or              reduce using rule 81 (equality -> equality NotEqual relational .)
    Semi            reduce using rule 81 (equality -> equality NotEqual relational .)
    RParen          reduce using rule 81 (equality -> equality NotEqual relational .)
    RBrack          reduce using rule 81 (equality -> equality NotEqual relational .)
    Comma           reduce using rule 81 (equality -> equality NotEqual relational .)
    Colon           reduce using rule 81 (equality -> equality NotEqual relational .)
    Less            shift and go to state 55
    Greater         shift and go to state 56
    LessEqual       shift and go to state 57
    GreaterEqual    shift and go to state 58


state 88

    (82) equality -> equality Equal relational .
    (83) relational -> relational . Less additive
    (84) relational -> relational . Greater additive
    (85) relational -> relational . LessEqual additive
    (86) relational -> relational . GreaterEqual additive

    NotEqual        reduce using rule 82 (equality -> equality Equal relational .)
    Equal           reduce using rule 82 (equality -> equality Equal relational .)
    BitAnd          reduce using rule 82 (equality -> equality Equal relational .)
    Xor             reduce using rule 82 (equality -> equality Equal relational .)
    BitOr           reduce using rule 82 (equality -> equality Equal relational .)
    And             reduce using rule 82 (equality -> equality Equal relational .)
    Question        reduce using rule 82 (equality -> equality Equal relational .)
    Or              reduce using rule 82 (equality -> equality Equal relational .)
    Semi            reduce using rule 82 (equality -> equality Equal relational .)
    RParen          reduce using rule 82 (equality -> equality Equal relational .)
    RBrack          reduce using rule 82 (equality -> equality Equal relational .)
    Comma           reduce using rule 82 (equality -> equality Equal relational .)
    Colon           reduce using rule 82 (equality -> equality Equal relational .)
    Less            shift and go to state 55
    Greater         shift and go to state 56
    LessEqual       shift and go to state 57
    GreaterEqual    shift and go to state 58


state 89

    (83) relational -> relational Less additive .
    (87) additive -> additive . Plus multiplicative
    (88) additive -> additive . Minus multiplicative

    Less            reduce using rule 83 (relational -> relational Less additive .)
    Greater         reduce using rule 83 (relational -> relational Less additive .)
    LessEqual       reduce using rule 83 (relational -> relational Less additive .)
    GreaterEqual    reduce using rule 83 (relational -> relational Less additive .)
    NotEqual        reduce using rule 83 (relational -> relational Less additive .)
    Equal           reduce using rule 83 (relational -> relational Less additive .)
    BitAnd          reduce using rule 83 (relational -> relational Less additive .)
    Xor             reduce using rule 83 (relational -> relational Less additive .)
    BitOr           reduce using rule 83 (relational -> relational Less additive .)
    And             reduce using rule 83 (relational -> relational Less additive .)
    Question        reduce using rule 83 (relational -> relational Less additive .)
    Or              reduce using rule 83 (relational -> relational Less additive .)
    Semi            reduce using rule 83 (relational -> relational Less additive .)
    RParen          reduce using rule 83 (relational -> relational Less additive .)
    RBrack          reduce using rule 83 (relational -> relational Less additive .)
    Comma           reduce using rule 83 (relational -> relational Less additive .)
    Colon           reduce using rule 83 (relational -> relational Less additive .)
    Plus            shift and go to state 59
    Minus           shift and go to state 60


state 90

    (84) relational -> relational Greater additive .
    (87) additive -> additive . Plus multiplicative
    (88) additive -> additive . Minus multiplicative

    Less            reduce using rule 84 (relational -> relational Greater additive .)
    Greater         reduce using rule 84 (relational -> relational Greater additive .)
    LessEqual       reduce using rule 84 (relational -> relational Greater additive .)
    GreaterEqual    reduce using rule 84 (relational -> relational Greater additive .)
    NotEqual        reduce using rule 84 (relational -> relational Greater additive .)
    Equal           reduce using rule 84 (relational -> relational Greater additive .)
    BitAnd          reduce using rule 84 (relational -> relational Greater additive .)
    Xor             reduce using rule 84 (relational -> relational Greater additive .)
    BitOr           reduce using rule 84 (relational -> relational Greater additive .)
    And             reduce using rule 84 (relational -> relational Greater additive .)
    Question        reduce using rule 84 (relational -> relational Greater additive .)
    Or              reduce using rule 84 (relational -> relational Greater additive .)
    Semi            reduce using rule 84 (relational -> relational Greater additive .)
    RParen          reduce using rule 84 (relational -> relational Greater additive .)
    RBrack          reduce using rule 84 (relational -> relational Greater additive .)
    Comma           reduce using rule 84 (relational -> relational Greater additive .)
    Colon           reduce using rule 84 (relational -> relational Greater additive .)
    Plus            shift and go to state 59
    Minus           shift and go to state 60


state 91

    (85) relational -> relational LessEqual additive .
    (87) additive -> additive . Plus multiplicative
    (88) additive -> additive . Minus multiplicative

    Less            reduce using rule 85 (relational -> relational LessEqual additive .)
    Greater         reduce using rule 85 (relational -> relational LessEqual additive .)
    LessEqual       reduce using rule 85 (relational -> relational LessEqual additive .)
    GreaterEqual    reduce using rule 85 (relational -> relational LessEqual additive .)
    NotEqual        reduce using rule 85 (relational -> relational LessEqual additive .)
    Equal           reduce using rule 85 (relational -> relational LessEqual additive .)
    BitAnd          reduce using rule 85 (relational -> relational LessEqual additive .)
    Xor             reduce using rule 85 (relational -> relational LessEqual additive .)
    BitOr           reduce using rule 85 (relational -> relational LessEqual additive .)
    And             reduce using rule 85 (relational -> relational LessEqual additive .)
    Question        reduce using rule 85 (relational -> relational LessEqual additive .)
    Or              reduce using rule 85 (relational -> relational LessEqual additive .)
    Semi            reduce using rule 85 (relational -> relational LessEqual additive .)
    RParen          reduce using rule 85 (relational -> relational LessEqual additive .)
    RBrack          reduce using rule 85 (relational -> relational LessEqual additive .)
    Comma           reduce using rule 85 (relational -> relational LessEqual additive .)
    Colon           reduce using rule 85 (relational -> relational LessEqual additive .)
    Plus            shift and go to state 59
    Minus           shift and go to state 60


state 92

    (86) relational -> relational GreaterEqual additive .
    (87) additive -> additive . Plus multiplicative
    (88) additive -> additive . Minus multiplicative

    Less            reduce using rule 86 (relational -> relational GreaterEqual additive .)
    Greater         reduce using rule 86 (relational -> relational GreaterEqual additive .)
    LessEqual       reduce using rule 86 (relational -> relational GreaterEqual additive .)
    GreaterEqual    reduce using rule 86 (relational -> relational GreaterEqual additive .)
    NotEqual        reduce using rule 86 (relational -> relational GreaterEqual additive .)
    Equal           reduce using rule 86 (relational -> relational GreaterEqual additive .)
    BitAnd          reduce using rule 86 (relational -> relational GreaterEqual additive .)
    Xor             reduce using rule 86 (relational -> relational GreaterEqual additive .)
    BitOr           reduce using rule 86 (relational -> relational GreaterEqual additive .)
    And             reduce using rule 86 (relational -> relational GreaterEqual additive .)
    Question        reduce using rule 86 (relational -> relational GreaterEqual additive .)
    Or              reduce using rule 86 (relational -> relational GreaterEqual additive .)
    Semi            reduce using rule 86 (relational -> relational GreaterEqual additive .)
    RParen          reduce using rule 86 (relational -> relational GreaterEqual additive .)
    RBrack          reduce using rule 86 (relational -> relational GreaterEqual additive .)
    Comma           reduce using rule 86 (relational -> relational GreaterEqual additive .)
    Colon           reduce using rule 86 (relational -> relational GreaterEqual additive .)
    Plus            shift and go to state 59
    Minus           shift and go to state 60


state 93

    (87) additive -> additive Plus multiplicative .
    (89) multiplicative -> multiplicative . Mul unary
    (90) multiplicative -> multiplicative . Div unary
    (91) multiplicative -> multiplicative . Mod unary

    Plus            reduce using rule 87 (additive -> additive Plus multiplicative .)
    Minus           reduce using rule 87 (additive -> additive Plus multiplicative .)
    Less            reduce using rule 87 (additive -> additive Plus multiplicative .)
    Greater         reduce using rule 87 (additive -> additive Plus multiplicative .)
    LessEqual       reduce using rule 87 (additive -> additive Plus multiplicative .)
    GreaterEqual    reduce using rule 87 (additive -> additive Plus multiplicative .)
    NotEqual        reduce using rule 87 (additive -> additive Plus multiplicative .)
    Equal           reduce using rule 87 (additive -> additive Plus multiplicative .)
    BitAnd          reduce using rule 87 (additive -> additive Plus multiplicative .)
    Xor             reduce using rule 87 (additive -> additive Plus multiplicative .)
    BitOr           reduce using rule 87 (additive -> additive Plus multiplicative .)
    And             reduce using rule 87 (additive -> additive Plus multiplicative .)
    Question        reduce using rule 87 (additive -> additive Plus multiplicative .)
    Or              reduce using rule 87 (additive -> additive Plus multiplicative .)
    Semi            reduce using rule 87 (additive -> additive Plus multiplicative .)
    RParen          reduce using rule 87 (additive -> additive Plus multiplicative .)
    RBrack          reduce using rule 87 (additive -> additive Plus multiplicative .)
    Comma           reduce using rule 87 (additive -> additive Plus multiplicative .)
    Colon           reduce using rule 87 (additive -> additive Plus multiplicative .)
    Mul             shift and go to state 61
    Div             shift and go to state 62
    Mod             shift and go to state 63


state 94

    (88) additive -> additive Minus multiplicative .
    (89) multiplicative -> multiplicative . Mul unary
    (90) multiplicative -> multiplicative . Div unary
    (91) multiplicative -> multiplicative . Mod unary

    Plus            reduce using rule 88 (additive -> additive Minus multiplicative .)
    Minus           reduce using rule 88 (additive -> additive Minus multiplicative .)
    Less            reduce using rule 88 (additive -> additive Minus multiplicative .)
    Greater         reduce using rule 88 (additive -> additive Minus multiplicative .)
    LessEqual       reduce using rule 88 (additive -> additive Minus multiplicative .)
    GreaterEqual    reduce using rule 88 (additive -> additive Minus multiplicative .)
    NotEqual        reduce using rule 88 (additive -> additive Minus multiplicative .)
    Equal           reduce using rule 88 (additive -> additive Minus multiplicative .)
    BitAnd          reduce using rule 88 (additive -> additive Minus multiplicative .)
    Xor             reduce using rule 88 (additive -> additive Minus multiplicative .)
    BitOr           reduce using rule 88 (additive -> additive Minus multiplicative .)
    And             reduce using rule 88 (additive -> additive Minus multiplicative .)
    Question        reduce using rule 88 (additive -> additive Minus multiplicative .)
    Or              reduce using rule 88 (additive -> additive Minus multiplicative .)
    Semi            reduce using rule 88 (additive -> additive Minus multiplicative .)
    RParen          reduce using rule 88 (additive -> additive Minus multiplicative .)
    RBrack          reduce using rule 88 (additive -> additive Minus multiplicative .)
    Comma           reduce using rule 88 (additive -> additive Minus multiplicative .)
    Colon           reduce using rule 88 (additive -> additive Minus multiplicative .)
    Mul             shift and go to state 61
    Div             shift and go to state 62
    Mod             shift and go to state 63


state 95

    (89) multiplicative -> multiplicative Mul unary .

    Mul             reduce using rule 89 (multiplicative -> multiplicative Mul unary .)
    Div             reduce using rule 89 (multiplicative -> multiplicative Mul unary .)
    Mod             reduce using rule 89 (multiplicative -> multiplicative Mul unary .)
    Plus            reduce using rule 89 (multiplicative -> multiplicative Mul unary .)
    Minus           reduce using rule 89 (multiplicative -> multiplicative Mul unary .)
    Less            reduce using rule 89 (multiplicative -> multiplicative Mul unary .)
    Greater         reduce using rule 89 (multiplicative -> multiplicative Mul unary .)
    LessEqual       reduce using rule 89 (multiplicative -> multiplicative Mul unary .)
    GreaterEqual    reduce using rule 89 (multiplicative -> multiplicative Mul unary .)
    NotEqual        reduce using rule 89 (multiplicative -> multiplicative Mul unary .)
    Equal           reduce using rule 89 (multiplicative -> multiplicative Mul unary .)
    BitAnd          reduce using rule 89 (multiplicative -> multiplicative Mul unary .)
    Xor             reduce using rule 89 (multiplicative -> multiplicative Mul unary .)
    BitOr           reduce using rule 89 (multiplicative -> multiplicative Mul unary .)
    And             reduce using rule 89 (multiplicative -> multiplicative Mul unary .)
    Question        reduce using rule 89 (multiplicative -> multiplicative Mul unary .)
    Or              reduce using rule 89 (multiplicative -> multiplicative Mul unary .)
    Semi            reduce using rule 89 (multiplicative -> multiplicative Mul unary .)
    RParen          reduce using rule 89 (multiplicative -> multiplicative Mul unary .)
    RBrack          reduce using rule 89 (multiplicative -> multiplicative Mul unary .)
    Comma           reduce using rule 89 (multiplicative -> multiplicative Mul unary .)
    Colon           reduce using rule 89 (multiplicative -> multiplicative Mul unary .)


state 96

    (90) multiplicative -> multiplicative Div unary .

    Mul             reduce using rule 90 (multiplicative -> multiplicative Div unary .)
    Div             reduce using rule 90 (multiplicative -> multiplicative Div unary .)
    Mod             reduce using rule 90 (multiplicative -> multiplicative Div unary .)
    Plus            reduce using rule 90 (multiplicative -> multiplicative Div unary .)
    Minus           reduce using rule 90 (multiplicative -> multiplicative Div unary .)
    Less            reduce using rule 90 (multiplicative -> multiplicative Div unary .)
    Greater         reduce using rule 90 (multiplicative -> multiplicative Div unary .)
    LessEqual       reduce using rule 90 (multiplicative -> multiplicative Div unary .)
    GreaterEqual    reduce using rule 90 (multiplicative -> multiplicative Div unary .)
    NotEqual        reduce using rule 90 (multiplicative -> multiplicative Div unary .)
    Equal           reduce using rule 90 (multiplicative -> multiplicative Div unary .)
    BitAnd          reduce using rule 90 (multiplicative -> multiplicative Div unary .)
    Xor             reduce using rule 90 (multiplicative -> multiplicative Div unary .)
    BitOr           reduce using rule 90 (multiplicative -> multiplicative Div unary .)
    And             reduce using rule 90 (multiplicative -> multiplicative Div unary .)
    Question        reduce using rule 90 (multiplicative -> multiplicative Div unary .)
    Or              reduce using rule 90 (multiplicative -> multiplicative Div unary .)
    Semi            reduce using rule 90 (multiplicative -> multiplicative Div unary .)
    RParen          reduce using rule 90 (multiplicative -> multiplicative Div unary .)
    RBrack          reduce using rule 90 (multiplicative -> multiplicative Div unary .)
    Comma           reduce using rule 90 (multiplicative -> multiplicative Div unary .)
    Colon           reduce using rule 90 (multiplicative -> multiplicative Div unary .)


state 97

    (91) multiplicative -> multiplicative Mod unary .

    Mul             reduce using rule 91 (multiplicative -> multiplicative Mod unary .)
    Div             reduce using rule 91 (multiplicative -> multiplicative Mod unary .)
    Mod             reduce using rule 91 (multiplicative -> multiplicative Mod unary .)
    Plus            reduce using rule 91 (multiplicative -> multiplicative Mod unary .)
    Minus           reduce using rule 91 (multiplicative -> multiplicative Mod unary .)
    Less            reduce using rule 91 (multiplicative -> multiplicative Mod unary .)
    Greater         reduce using rule 91 (multiplicative -> multiplicative Mod unary .)
    LessEqual       reduce using rule 91 (multiplicative -> multiplicative Mod unary .)
    GreaterEqual    reduce using rule 91 (multiplicative -> multiplicative Mod unary .)
    NotEqual        reduce using rule 91 (multiplicative -> multiplicative Mod unary .)
    Equal           reduce using rule 91 (multiplicative -> multiplicative Mod unary .)
    BitAnd          reduce using rule 91 (multiplicative -> multiplicative Mod unary .)
    Xor             reduce using rule 91 (multiplicative -> multiplicative Mod unary .)
    BitOr           reduce using rule 91 (multiplicative -> multiplicative Mod unary .)
    And             reduce using rule 91 (multiplicative -> multiplicative Mod unary .)
    Question        reduce using rule 91 (multiplicative -> multiplicative Mod unary .)
    Or              reduce using rule 91 (multiplicative -> multiplicative Mod unary .)
    Semi            reduce using rule 91 (multiplicative -> multiplicative Mod unary .)
    RParen          reduce using rule 91 (multiplicative -> multiplicative Mod unary .)
    RBrack          reduce using rule 91 (multiplicative -> multiplicative Mod unary .)
    Comma           reduce using rule 91 (multiplicative -> multiplicative Mod unary .)
    Colon           reduce using rule 91 (multiplicative -> multiplicative Mod unary .)


state 98

    (71) postfix -> Identifier index_list .

    Mul             reduce using rule 71 (postfix -> Identifier index_list .)
    Div             reduce using rule 71 (postfix -> Identifier index_list .)
    Mod             reduce using rule 71 (postfix -> Identifier index_list .)
    Plus            reduce using rule 71 (postfix -> Identifier index_list .)
    Minus           reduce using rule 71 (postfix -> Identifier index_list .)
    Less            reduce using rule 71 (postfix -> Identifier index_list .)
    Greater         reduce using rule 71 (postfix -> Identifier index_list .)
    LessEqual       reduce using rule 71 (postfix -> Identifier index_list .)
    GreaterEqual    reduce using rule 71 (postfix -> Identifier index_list .)
    NotEqual        reduce using rule 71 (postfix -> Identifier index_list .)
    Equal           reduce using rule 71 (postfix -> Identifier index_list .)
    BitAnd          reduce using rule 71 (postfix -> Identifier index_list .)
    Xor             reduce using rule 71 (postfix -> Identifier index_list .)
    BitOr           reduce using rule 71 (postfix -> Identifier index_list .)
    And             reduce using rule 71 (postfix -> Identifier index_list .)
    Question        reduce using rule 71 (postfix -> Identifier index_list .)
    Or              reduce using rule 71 (postfix -> Identifier index_list .)
    Semi            reduce using rule 71 (postfix -> Identifier index_list .)
    RParen          reduce using rule 71 (postfix -> Identifier index_list .)
    RBrack          reduce using rule 71 (postfix -> Identifier index_list .)
    Comma           reduce using rule 71 (postfix -> Identifier index_list .)
    Colon           reduce using rule 71 (postfix -> Identifier index_list .)


state 99

    (95) primary -> LParen expression RParen .

    Mul             reduce using rule 95 (primary -> LParen expression RParen .)
    Div             reduce using rule 95 (primary -> LParen expression RParen .)
    Mod             reduce using rule 95 (primary -> LParen expression RParen .)
    Plus            reduce using rule 95 (primary -> LParen expression RParen .)
    Minus           reduce using rule 95 (primary -> LParen expression RParen .)
    Less            reduce using rule 95 (primary -> LParen expression RParen .)
    Greater         reduce using rule 95 (primary -> LParen expression RParen .)
    LessEqual       reduce using rule 95 (primary -> LParen expression RParen .)
    GreaterEqual    reduce using rule 95 (primary -> LParen expression RParen .)
    NotEqual        reduce using rule 95 (primary -> LParen expression RParen .)
    Equal           reduce using rule 95 (primary -> LParen expression RParen .)
    BitAnd          reduce using rule 95 (primary -> LParen expression RParen .)
    Xor             reduce using rule 95 (primary -> LParen expression RParen .)
    BitOr           reduce using rule 95 (primary -> LParen expression RParen .)
    And             reduce using rule 95 (primary -> LParen expression RParen .)
    Question        reduce using rule 95 (primary -> LParen expression RParen .)
    Or              reduce using rule 95 (primary -> LParen expression RParen .)
    Semi            reduce using rule 95 (primary -> LParen expression RParen .)
    RParen          reduce using rule 95 (primary -> LParen expression RParen .)
    RBrack          reduce using rule 95 (primary -> LParen expression RParen .)
    Comma           reduce using rule 95 (primary -> LParen expression RParen .)
    Colon           reduce using rule 95 (primary -> LParen expression RParen .)


state 100

    (15) type_identifier_union -> type Identifier int_index_list .

    RParen          reduce using rule 15 (type_identifier_union -> type Identifier int_index_list .)
    Comma           reduce using rule 15 (type_identifier_union -> type Identifier int_index_list .)


state 101

    (16) type_identifier_union -> type Identifier LBrack . RBrack int_index_list
    (12) int_index_list -> LBrack . Integer RBrack int_index_list

    RBrack          shift and go to state 113
    Integer         shift and go to state 114


state 102

    (13) int_index_list -> empty .

    RParen          reduce using rule 13 (int_index_list -> empty .)
    Comma           reduce using rule 13 (int_index_list -> empty .)


state 103

    (8) function_def -> type Identifier LParen parameter_list RParen LBrace . block RBrace
    (18) block -> . block block_item
    (19) block -> . empty
    (1) empty -> .

    RBrace          reduce using rule 1 (empty -> .)
    If              reduce using rule 1 (empty -> .)
    While           reduce using rule 1 (empty -> .)
    Do              reduce using rule 1 (empty -> .)
    For             reduce using rule 1 (empty -> .)
    Return          reduce using rule 1 (empty -> .)
    LBrace          reduce using rule 1 (empty -> .)
    Break           reduce using rule 1 (empty -> .)
    Continue        reduce using rule 1 (empty -> .)
    Int             reduce using rule 1 (empty -> .)
    Identifier      reduce using rule 1 (empty -> .)
    Minus           reduce using rule 1 (empty -> .)
    BitNot          reduce using rule 1 (empty -> .)
    Not             reduce using rule 1 (empty -> .)
    Integer         reduce using rule 1 (empty -> .)
    LParen          reduce using rule 1 (empty -> .)
    Semi            reduce using rule 1 (empty -> .)

    block                          shift and go to state 115
    empty                          shift and go to state 116

state 104

    (9) function_decl -> type Identifier LParen parameter_list RParen Semi .

    Int             reduce using rule 9 (function_decl -> type Identifier LParen parameter_list RParen Semi .)
    $end            reduce using rule 9 (function_decl -> type Identifier LParen parameter_list RParen Semi .)


state 105

    (10) parameter_list -> parameter_list Comma type_identifier_union .

    RParen          reduce using rule 10 (parameter_list -> parameter_list Comma type_identifier_union .)
    Comma           reduce using rule 10 (parameter_list -> parameter_list Comma type_identifier_union .)


state 106

    (49) index_list -> index_list_r LBrack expression RBrack .
    (50) index_list_r -> index_list_r LBrack expression RBrack .

    Assign          reduce using rule 49 (index_list -> index_list_r LBrack expression RBrack .)
    Semi            reduce using rule 49 (index_list -> index_list_r LBrack expression RBrack .)
    Mul             reduce using rule 49 (index_list -> index_list_r LBrack expression RBrack .)
    Div             reduce using rule 49 (index_list -> index_list_r LBrack expression RBrack .)
    Mod             reduce using rule 49 (index_list -> index_list_r LBrack expression RBrack .)
    Plus            reduce using rule 49 (index_list -> index_list_r LBrack expression RBrack .)
    Minus           reduce using rule 49 (index_list -> index_list_r LBrack expression RBrack .)
    Less            reduce using rule 49 (index_list -> index_list_r LBrack expression RBrack .)
    Greater         reduce using rule 49 (index_list -> index_list_r LBrack expression RBrack .)
    LessEqual       reduce using rule 49 (index_list -> index_list_r LBrack expression RBrack .)
    GreaterEqual    reduce using rule 49 (index_list -> index_list_r LBrack expression RBrack .)
    NotEqual        reduce using rule 49 (index_list -> index_list_r LBrack expression RBrack .)
    Equal           reduce using rule 49 (index_list -> index_list_r LBrack expression RBrack .)
    BitAnd          reduce using rule 49 (index_list -> index_list_r LBrack expression RBrack .)
    Xor             reduce using rule 49 (index_list -> index_list_r LBrack expression RBrack .)
    BitOr           reduce using rule 49 (index_list -> index_list_r LBrack expression RBrack .)
    And             reduce using rule 49 (index_list -> index_list_r LBrack expression RBrack .)
    Question        reduce using rule 49 (index_list -> index_list_r LBrack expression RBrack .)
    Or              reduce using rule 49 (index_list -> index_list_r LBrack expression RBrack .)
    RParen          reduce using rule 49 (index_list -> index_list_r LBrack expression RBrack .)
    RBrack          reduce using rule 49 (index_list -> index_list_r LBrack expression RBrack .)
    Comma           reduce using rule 49 (index_list -> index_list_r LBrack expression RBrack .)
    Colon           reduce using rule 49 (index_list -> index_list_r LBrack expression RBrack .)
    LBrack          reduce using rule 50 (index_list_r -> index_list_r LBrack expression RBrack .)


state 107

    (45) declaration -> type Identifier index_list Assign LBrace array_init_list RBrace .

    Semi            reduce using rule 45 (declaration -> type Identifier index_list Assign LBrace array_init_list RBrace .)


state 108

    (46) array_init_list -> array_init_list Comma . Integer

    Integer         shift and go to state 117


state 109

    (69) assignment -> Identifier index_list Assign expression .

    Semi            reduce using rule 69 (assignment -> Identifier index_list Assign expression .)
    RParen          reduce using rule 69 (assignment -> Identifier index_list Assign expression .)
    RBrack          reduce using rule 69 (assignment -> Identifier index_list Assign expression .)
    Comma           reduce using rule 69 (assignment -> Identifier index_list Assign expression .)
    Colon           reduce using rule 69 (assignment -> Identifier index_list Assign expression .)


state 110

    (70) postfix -> Identifier LParen expression_list RParen .

    Mul             reduce using rule 70 (postfix -> Identifier LParen expression_list RParen .)
    Div             reduce using rule 70 (postfix -> Identifier LParen expression_list RParen .)
    Mod             reduce using rule 70 (postfix -> Identifier LParen expression_list RParen .)
    Plus            reduce using rule 70 (postfix -> Identifier LParen expression_list RParen .)
    Minus           reduce using rule 70 (postfix -> Identifier LParen expression_list RParen .)
    Less            reduce using rule 70 (postfix -> Identifier LParen expression_list RParen .)
    Greater         reduce using rule 70 (postfix -> Identifier LParen expression_list RParen .)
    LessEqual       reduce using rule 70 (postfix -> Identifier LParen expression_list RParen .)
    GreaterEqual    reduce using rule 70 (postfix -> Identifier LParen expression_list RParen .)
    NotEqual        reduce using rule 70 (postfix -> Identifier LParen expression_list RParen .)
    Equal           reduce using rule 70 (postfix -> Identifier LParen expression_list RParen .)
    BitAnd          reduce using rule 70 (postfix -> Identifier LParen expression_list RParen .)
    Xor             reduce using rule 70 (postfix -> Identifier LParen expression_list RParen .)
    BitOr           reduce using rule 70 (postfix -> Identifier LParen expression_list RParen .)
    And             reduce using rule 70 (postfix -> Identifier LParen expression_list RParen .)
    Question        reduce using rule 70 (postfix -> Identifier LParen expression_list RParen .)
    Or              reduce using rule 70 (postfix -> Identifier LParen expression_list RParen .)
    Semi            reduce using rule 70 (postfix -> Identifier LParen expression_list RParen .)
    RParen          reduce using rule 70 (postfix -> Identifier LParen expression_list RParen .)
    RBrack          reduce using rule 70 (postfix -> Identifier LParen expression_list RParen .)
    Comma           reduce using rule 70 (postfix -> Identifier LParen expression_list RParen .)
    Colon           reduce using rule 70 (postfix -> Identifier LParen expression_list RParen .)


state 111

    (72) expression_list -> expression_list Comma . expression
    (52) expression -> . assignment
    (53) assignment -> . conditional
    (69) assignment -> . Identifier index_list Assign expression
    (75) assignment -> . Identifier Assign expression
    (54) conditional -> . logical_or
    (92) conditional -> . logical_or Question expression Colon conditional
    (55) logical_or -> . logical_and
    (76) logical_or -> . logical_or Or logical_and
    (56) logical_and -> . bit_or
    (77) logical_and -> . logical_and And bit_or
    (57) bit_or -> . xor
    (78) bit_or -> . bit_or BitOr xor
    (58) xor -> . bit_and
    (79) xor -> . xor Xor bit_and
    (59) bit_and -> . equality
    (80) bit_and -> . bit_and BitAnd equality
    (60) equality -> . relational
    (81) equality -> . equality NotEqual relational
    (82) equality -> . equality Equal relational
    (61) relational -> . additive
    (83) relational -> . relational Less additive
    (84) relational -> . relational Greater additive
    (85) relational -> . relational LessEqual additive
    (86) relational -> . relational GreaterEqual additive
    (62) additive -> . multiplicative
    (87) additive -> . additive Plus multiplicative
    (88) additive -> . additive Minus multiplicative
    (63) multiplicative -> . unary
    (89) multiplicative -> . multiplicative Mul unary
    (90) multiplicative -> . multiplicative Div unary
    (91) multiplicative -> . multiplicative Mod unary
    (64) unary -> . postfix
    (66) unary -> . Minus unary
    (67) unary -> . BitNot unary
    (68) unary -> . Not unary
    (65) postfix -> . primary
    (70) postfix -> . Identifier LParen expression_list RParen
    (71) postfix -> . Identifier index_list
    (93) primary -> . Integer
    (94) primary -> . Identifier
    (95) primary -> . LParen expression RParen

    Identifier      shift and go to state 17
    Minus           shift and go to state 30
    BitNot          shift and go to state 33
    Not             shift and go to state 34
    Integer         shift and go to state 37
    LParen          shift and go to state 36

    expression                     shift and go to state 118
    assignment                     shift and go to state 19
    conditional                    shift and go to state 20
    logical_or                     shift and go to state 21
    logical_and                    shift and go to state 22
    bit_or                         shift and go to state 23
    xor                            shift and go to state 24
    bit_and                        shift and go to state 25
    equality                       shift and go to state 26
    relational                     shift and go to state 27
    additive                       shift and go to state 28
    multiplicative                 shift and go to state 29
    unary                          shift and go to state 31
    postfix                        shift and go to state 32
    primary                        shift and go to state 35

state 112

    (92) conditional -> logical_or Question expression Colon . conditional
    (54) conditional -> . logical_or
    (92) conditional -> . logical_or Question expression Colon conditional
    (55) logical_or -> . logical_and
    (76) logical_or -> . logical_or Or logical_and
    (56) logical_and -> . bit_or
    (77) logical_and -> . logical_and And bit_or
    (57) bit_or -> . xor
    (78) bit_or -> . bit_or BitOr xor
    (58) xor -> . bit_and
    (79) xor -> . xor Xor bit_and
    (59) bit_and -> . equality
    (80) bit_and -> . bit_and BitAnd equality
    (60) equality -> . relational
    (81) equality -> . equality NotEqual relational
    (82) equality -> . equality Equal relational
    (61) relational -> . additive
    (83) relational -> . relational Less additive
    (84) relational -> . relational Greater additive
    (85) relational -> . relational LessEqual additive
    (86) relational -> . relational GreaterEqual additive
    (62) additive -> . multiplicative
    (87) additive -> . additive Plus multiplicative
    (88) additive -> . additive Minus multiplicative
    (63) multiplicative -> . unary
    (89) multiplicative -> . multiplicative Mul unary
    (90) multiplicative -> . multiplicative Div unary
    (91) multiplicative -> . multiplicative Mod unary
    (64) unary -> . postfix
    (66) unary -> . Minus unary
    (67) unary -> . BitNot unary
    (68) unary -> . Not unary
    (65) postfix -> . primary
    (70) postfix -> . Identifier LParen expression_list RParen
    (71) postfix -> . Identifier index_list
    (93) primary -> . Integer
    (94) primary -> . Identifier
    (95) primary -> . LParen expression RParen

    Minus           shift and go to state 30
    BitNot          shift and go to state 33
    Not             shift and go to state 34
    Identifier      shift and go to state 65
    Integer         shift and go to state 37
    LParen          shift and go to state 36

    logical_or                     shift and go to state 21
    conditional                    shift and go to state 119
    logical_and                    shift and go to state 22
    bit_or                         shift and go to state 23
    xor                            shift and go to state 24
    bit_and                        shift and go to state 25
    equality                       shift and go to state 26
    relational                     shift and go to state 27
    additive                       shift and go to state 28
    multiplicative                 shift and go to state 29
    unary                          shift and go to state 31
    postfix                        shift and go to state 32
    primary                        shift and go to state 35

state 113

    (16) type_identifier_union -> type Identifier LBrack RBrack . int_index_list
    (12) int_index_list -> . LBrack Integer RBrack int_index_list
    (13) int_index_list -> . empty
    (1) empty -> .

    LBrack          shift and go to state 120
    RParen          reduce using rule 1 (empty -> .)
    Comma           reduce using rule 1 (empty -> .)

    int_index_list                 shift and go to state 121
    empty                          shift and go to state 102

state 114

    (12) int_index_list -> LBrack Integer . RBrack int_index_list

    RBrack          shift and go to state 122


state 115

    (8) function_def -> type Identifier LParen parameter_list RParen LBrace block . RBrace
    (18) block -> block . block_item
    (20) block_item -> . statement
    (21) block_item -> . declaration Semi
    (25) statement -> . statement_matched
    (26) statement -> . statement_unmatched
    (42) declaration -> . type Identifier
    (43) declaration -> . type Identifier index_list
    (44) declaration -> . type Identifier Assign expression
    (45) declaration -> . type Identifier index_list Assign LBrace array_init_list RBrace
    (22) statement_matched -> . If LParen expression RParen statement_matched Else statement_matched
    (27) statement_matched -> . While LParen expression RParen statement_matched
    (29) statement_matched -> . Do statement_matched While LParen expression RParen Semi
    (31) statement_matched -> . For LParen p_decl_opt_expr_union Semi opt_expression Semi opt_expression RParen statement_matched
    (35) statement_matched -> . Return expression Semi
    (36) statement_matched -> . opt_expression Semi
    (37) statement_matched -> . LBrace block RBrace
    (38) statement_matched -> . Break Semi
    (39) statement_matched -> . Continue Semi
    (23) statement_unmatched -> . If LParen expression RParen statement_matched Else statement_unmatched
    (24) statement_unmatched -> . If LParen expression RParen statement
    (28) statement_unmatched -> . While LParen expression RParen statement_unmatched
    (30) statement_unmatched -> . Do statement_unmatched While LParen expression RParen Semi
    (32) statement_unmatched -> . For LParen p_decl_opt_expr_union Semi opt_expression Semi opt_expression RParen statement_unmatched
    (5) type -> . Int
    (40) opt_expression -> . expression
    (41) opt_expression -> . empty
    (52) expression -> . assignment
    (1) empty -> .
    (53) assignment -> . conditional
    (69) assignment -> . Identifier index_list Assign expression
    (75) assignment -> . Identifier Assign expression
    (54) conditional -> . logical_or
    (92) conditional -> . logical_or Question expression Colon conditional
    (55) logical_or -> . logical_and
    (76) logical_or -> . logical_or Or logical_and
    (56) logical_and -> . bit_or
    (77) logical_and -> . logical_and And bit_or
    (57) bit_or -> . xor
    (78) bit_or -> . bit_or BitOr xor
    (58) xor -> . bit_and
    (79) xor -> . xor Xor bit_and
    (59) bit_and -> . equality
    (80) bit_and -> . bit_and BitAnd equality
    (60) equality -> . relational
    (81) equality -> . equality NotEqual relational
    (82) equality -> . equality Equal relational
    (61) relational -> . additive
    (83) relational -> . relational Less additive
    (84) relational -> . relational Greater additive
    (85) relational -> . relational LessEqual additive
    (86) relational -> . relational GreaterEqual additive
    (62) additive -> . multiplicative
    (87) additive -> . additive Plus multiplicative
    (88) additive -> . additive Minus multiplicative
    (63) multiplicative -> . unary
    (89) multiplicative -> . multiplicative Mul unary
    (90) multiplicative -> . multiplicative Div unary
    (91) multiplicative -> . multiplicative Mod unary
    (64) unary -> . postfix
    (66) unary -> . Minus unary
    (67) unary -> . BitNot unary
    (68) unary -> . Not unary
    (65) postfix -> . primary
    (70) postfix -> . Identifier LParen expression_list RParen
    (71) postfix -> . Identifier index_list
    (93) primary -> . Integer
    (94) primary -> . Identifier
    (95) primary -> . LParen expression RParen

    RBrace          shift and go to state 125
    If              shift and go to state 132
    While           shift and go to state 133
    Do              shift and go to state 134
    For             shift and go to state 135
    Return          shift and go to state 137
    LBrace          shift and go to state 124
    Break           shift and go to state 138
    Continue        shift and go to state 139
    Int             shift and go to state 8
    Semi            reduce using rule 1 (empty -> .)
    Identifier      shift and go to state 17
    Minus           shift and go to state 30
    BitNot          shift and go to state 33
    Not             shift and go to state 34
    Integer         shift and go to state 37
    LParen          shift and go to state 36

    type                           shift and go to state 123
    block_item                     shift and go to state 126
    statement                      shift and go to state 127
    declaration                    shift and go to state 128
    statement_matched              shift and go to state 129
    statement_unmatched            shift and go to state 130
    expression                     shift and go to state 131
    opt_expression                 shift and go to state 136
    empty                          shift and go to state 140
    assignment                     shift and go to state 19
    conditional                    shift and go to state 20
    logical_or                     shift and go to state 21
    logical_and                    shift and go to state 22
    bit_or                         shift and go to state 23
    xor                            shift and go to state 24
    bit_and                        shift and go to state 25
    equality                       shift and go to state 26
    relational                     shift and go to state 27
    additive                       shift and go to state 28
    multiplicative                 shift and go to state 29
    unary                          shift and go to state 31
    postfix                        shift and go to state 32
    primary                        shift and go to state 35

state 116

    (19) block -> empty .

    RBrace          reduce using rule 19 (block -> empty .)
    If              reduce using rule 19 (block -> empty .)
    While           reduce using rule 19 (block -> empty .)
    Do              reduce using rule 19 (block -> empty .)
    For             reduce using rule 19 (block -> empty .)
    Return          reduce using rule 19 (block -> empty .)
    LBrace          reduce using rule 19 (block -> empty .)
    Break           reduce using rule 19 (block -> empty .)
    Continue        reduce using rule 19 (block -> empty .)
    Int             reduce using rule 19 (block -> empty .)
    Identifier      reduce using rule 19 (block -> empty .)
    Minus           reduce using rule 19 (block -> empty .)
    BitNot          reduce using rule 19 (block -> empty .)
    Not             reduce using rule 19 (block -> empty .)
    Integer         reduce using rule 19 (block -> empty .)
    LParen          reduce using rule 19 (block -> empty .)
    Semi            reduce using rule 19 (block -> empty .)


state 117

    (46) array_init_list -> array_init_list Comma Integer .

    RBrace          reduce using rule 46 (array_init_list -> array_init_list Comma Integer .)
    Comma           reduce using rule 46 (array_init_list -> array_init_list Comma Integer .)


state 118

    (72) expression_list -> expression_list Comma expression .

    RParen          reduce using rule 72 (expression_list -> expression_list Comma expression .)
    Comma           reduce using rule 72 (expression_list -> expression_list Comma expression .)


state 119

    (92) conditional -> logical_or Question expression Colon conditional .

    Semi            reduce using rule 92 (conditional -> logical_or Question expression Colon conditional .)
    RParen          reduce using rule 92 (conditional -> logical_or Question expression Colon conditional .)
    RBrack          reduce using rule 92 (conditional -> logical_or Question expression Colon conditional .)
    Comma           reduce using rule 92 (conditional -> logical_or Question expression Colon conditional .)
    Colon           reduce using rule 92 (conditional -> logical_or Question expression Colon conditional .)


state 120

    (12) int_index_list -> LBrack . Integer RBrack int_index_list

    Integer         shift and go to state 114


state 121

    (16) type_identifier_union -> type Identifier LBrack RBrack int_index_list .

    RParen          reduce using rule 16 (type_identifier_union -> type Identifier LBrack RBrack int_index_list .)
    Comma           reduce using rule 16 (type_identifier_union -> type Identifier LBrack RBrack int_index_list .)


state 122

    (12) int_index_list -> LBrack Integer RBrack . int_index_list
    (12) int_index_list -> . LBrack Integer RBrack int_index_list
    (13) int_index_list -> . empty
    (1) empty -> .

    LBrack          shift and go to state 120
    RParen          reduce using rule 1 (empty -> .)
    Comma           reduce using rule 1 (empty -> .)

    int_index_list                 shift and go to state 141
    empty                          shift and go to state 102

state 123

    (42) declaration -> type . Identifier
    (43) declaration -> type . Identifier index_list
    (44) declaration -> type . Identifier Assign expression
    (45) declaration -> type . Identifier index_list Assign LBrace array_init_list RBrace

    Identifier      shift and go to state 142


state 124

    (37) statement_matched -> LBrace . block RBrace
    (18) block -> . block block_item
    (19) block -> . empty
    (1) empty -> .

    RBrace          reduce using rule 1 (empty -> .)
    If              reduce using rule 1 (empty -> .)
    While           reduce using rule 1 (empty -> .)
    Do              reduce using rule 1 (empty -> .)
    For             reduce using rule 1 (empty -> .)
    Return          reduce using rule 1 (empty -> .)
    LBrace          reduce using rule 1 (empty -> .)
    Break           reduce using rule 1 (empty -> .)
    Continue        reduce using rule 1 (empty -> .)
    Int             reduce using rule 1 (empty -> .)
    Identifier      reduce using rule 1 (empty -> .)
    Minus           reduce using rule 1 (empty -> .)
    BitNot          reduce using rule 1 (empty -> .)
    Not             reduce using rule 1 (empty -> .)
    Integer         reduce using rule 1 (empty -> .)
    LParen          reduce using rule 1 (empty -> .)
    Semi            reduce using rule 1 (empty -> .)

    block                          shift and go to state 143
    empty                          shift and go to state 116

state 125

    (8) function_def -> type Identifier LParen parameter_list RParen LBrace block RBrace .

    Int             reduce using rule 8 (function_def -> type Identifier LParen parameter_list RParen LBrace block RBrace .)
    $end            reduce using rule 8 (function_def -> type Identifier LParen parameter_list RParen LBrace block RBrace .)


state 126

    (18) block -> block block_item .

    RBrace          reduce using rule 18 (block -> block block_item .)
    If              reduce using rule 18 (block -> block block_item .)
    While           reduce using rule 18 (block -> block block_item .)
    Do              reduce using rule 18 (block -> block block_item .)
    For             reduce using rule 18 (block -> block block_item .)
    Return          reduce using rule 18 (block -> block block_item .)
    LBrace          reduce using rule 18 (block -> block block_item .)
    Break           reduce using rule 18 (block -> block block_item .)
    Continue        reduce using rule 18 (block -> block block_item .)
    Int             reduce using rule 18 (block -> block block_item .)
    Identifier      reduce using rule 18 (block -> block block_item .)
    Minus           reduce using rule 18 (block -> block block_item .)
    BitNot          reduce using rule 18 (block -> block block_item .)
    Not             reduce using rule 18 (block -> block block_item .)
    Integer         reduce using rule 18 (block -> block block_item .)
    LParen          reduce using rule 18 (block -> block block_item .)
    Semi            reduce using rule 18 (block -> block block_item .)


state 127

    (20) block_item -> statement .

    RBrace          reduce using rule 20 (block_item -> statement .)
    If              reduce using rule 20 (block_item -> statement .)
    While           reduce using rule 20 (block_item -> statement .)
    Do              reduce using rule 20 (block_item -> statement .)
    For             reduce using rule 20 (block_item -> statement .)
    Return          reduce using rule 20 (block_item -> statement .)
    LBrace          reduce using rule 20 (block_item -> statement .)
    Break           reduce using rule 20 (block_item -> statement .)
    Continue        reduce using rule 20 (block_item -> statement .)
    Int             reduce using rule 20 (block_item -> statement .)
    Identifier      reduce using rule 20 (block_item -> statement .)
    Minus           reduce using rule 20 (block_item -> statement .)
    BitNot          reduce using rule 20 (block_item -> statement .)
    Not             reduce using rule 20 (block_item -> statement .)
    Integer         reduce using rule 20 (block_item -> statement .)
    LParen          reduce using rule 20 (block_item -> statement .)
    Semi            reduce using rule 20 (block_item -> statement .)


state 128

    (21) block_item -> declaration . Semi

    Semi            shift and go to state 144


state 129

    (25) statement -> statement_matched .

    RBrace          reduce using rule 25 (statement -> statement_matched .)
    If              reduce using rule 25 (statement -> statement_matched .)
    While           reduce using rule 25 (statement -> statement_matched .)
    Do              reduce using rule 25 (statement -> statement_matched .)
    For             reduce using rule 25 (statement -> statement_matched .)
    Return          reduce using rule 25 (statement -> statement_matched .)
    LBrace          reduce using rule 25 (statement -> statement_matched .)
    Break           reduce using rule 25 (statement -> statement_matched .)
    Continue        reduce using rule 25 (statement -> statement_matched .)
    Int             reduce using rule 25 (statement -> statement_matched .)
    Identifier      reduce using rule 25 (statement -> statement_matched .)
    Minus           reduce using rule 25 (statement -> statement_matched .)
    BitNot          reduce using rule 25 (statement -> statement_matched .)
    Not             reduce using rule 25 (statement -> statement_matched .)
    Integer         reduce using rule 25 (statement -> statement_matched .)
    LParen          reduce using rule 25 (statement -> statement_matched .)
    Semi            reduce using rule 25 (statement -> statement_matched .)


state 130

    (26) statement -> statement_unmatched .

    RBrace          reduce using rule 26 (statement -> statement_unmatched .)
    If              reduce using rule 26 (statement -> statement_unmatched .)
    While           reduce using rule 26 (statement -> statement_unmatched .)
    Do              reduce using rule 26 (statement -> statement_unmatched .)
    For             reduce using rule 26 (statement -> statement_unmatched .)
    Return          reduce using rule 26 (statement -> statement_unmatched .)
    LBrace          reduce using rule 26 (statement -> statement_unmatched .)
    Break           reduce using rule 26 (statement -> statement_unmatched .)
    Continue        reduce using rule 26 (statement -> statement_unmatched .)
    Int             reduce using rule 26 (statement -> statement_unmatched .)
    Identifier      reduce using rule 26 (statement -> statement_unmatched .)
    Minus           reduce using rule 26 (statement -> statement_unmatched .)
    BitNot          reduce using rule 26 (statement -> statement_unmatched .)
    Not             reduce using rule 26 (statement -> statement_unmatched .)
    Integer         reduce using rule 26 (statement -> statement_unmatched .)
    LParen          reduce using rule 26 (statement -> statement_unmatched .)
    Semi            reduce using rule 26 (statement -> statement_unmatched .)


state 131

    (40) opt_expression -> expression .

    Semi            reduce using rule 40 (opt_expression -> expression .)
    RParen          reduce using rule 40 (opt_expression -> expression .)


state 132

    (22) statement_matched -> If . LParen expression RParen statement_matched Else statement_matched
    (23) statement_unmatched -> If . LParen expression RParen statement_matched Else statement_unmatched
    (24) statement_unmatched -> If . LParen expression RParen statement

    LParen          shift and go to state 145


state 133

    (27) statement_matched -> While . LParen expression RParen statement_matched
    (28) statement_unmatched -> While . LParen expression RParen statement_unmatched

    LParen          shift and go to state 146


state 134

    (29) statement_matched -> Do . statement_matched While LParen expression RParen Semi
    (30) statement_unmatched -> Do . statement_unmatched While LParen expression RParen Semi
    (22) statement_matched -> . If LParen expression RParen statement_matched Else statement_matched
    (27) statement_matched -> . While LParen expression RParen statement_matched
    (29) statement_matched -> . Do statement_matched While LParen expression RParen Semi
    (31) statement_matched -> . For LParen p_decl_opt_expr_union Semi opt_expression Semi opt_expression RParen statement_matched
    (35) statement_matched -> . Return expression Semi
    (36) statement_matched -> . opt_expression Semi
    (37) statement_matched -> . LBrace block RBrace
    (38) statement_matched -> . Break Semi
    (39) statement_matched -> . Continue Semi
    (23) statement_unmatched -> . If LParen expression RParen statement_matched Else statement_unmatched
    (24) statement_unmatched -> . If LParen expression RParen statement
    (28) statement_unmatched -> . While LParen expression RParen statement_unmatched
    (30) statement_unmatched -> . Do statement_unmatched While LParen expression RParen Semi
    (32) statement_unmatched -> . For LParen p_decl_opt_expr_union Semi opt_expression Semi opt_expression RParen statement_unmatched
    (40) opt_expression -> . expression
    (41) opt_expression -> . empty
    (52) expression -> . assignment
    (1) empty -> .
    (53) assignment -> . conditional
    (69) assignment -> . Identifier index_list Assign expression
    (75) assignment -> . Identifier Assign expression
    (54) conditional -> . logical_or
    (92) conditional -> . logical_or Question expression Colon conditional
    (55) logical_or -> . logical_and
    (76) logical_or -> . logical_or Or logical_and
    (56) logical_and -> . bit_or
    (77) logical_and -> . logical_and And bit_or
    (57) bit_or -> . xor
    (78) bit_or -> . bit_or BitOr xor
    (58) xor -> . bit_and
    (79) xor -> . xor Xor bit_and
    (59) bit_and -> . equality
    (80) bit_and -> . bit_and BitAnd equality
    (60) equality -> . relational
    (81) equality -> . equality NotEqual relational
    (82) equality -> . equality Equal relational
    (61) relational -> . additive
    (83) relational -> . relational Less additive
    (84) relational -> . relational Greater additive
    (85) relational -> . relational LessEqual additive
    (86) relational -> . relational GreaterEqual additive
    (62) additive -> . multiplicative
    (87) additive -> . additive Plus multiplicative
    (88) additive -> . additive Minus multiplicative
    (63) multiplicative -> . unary
    (89) multiplicative -> . multiplicative Mul unary
    (90) multiplicative -> . multiplicative Div unary
    (91) multiplicative -> . multiplicative Mod unary
    (64) unary -> . postfix
    (66) unary -> . Minus unary
    (67) unary -> . BitNot unary
    (68) unary -> . Not unary
    (65) postfix -> . primary
    (70) postfix -> . Identifier LParen expression_list RParen
    (71) postfix -> . Identifier index_list
    (93) primary -> . Integer
    (94) primary -> . Identifier
    (95) primary -> . LParen expression RParen

    If              shift and go to state 132
    While           shift and go to state 133
    Do              shift and go to state 134
    For             shift and go to state 135
    Return          shift and go to state 137
    LBrace          shift and go to state 124
    Break           shift and go to state 138
    Continue        shift and go to state 139
    Semi            reduce using rule 1 (empty -> .)
    Identifier      shift and go to state 17
    Minus           shift and go to state 30
    BitNot          shift and go to state 33
    Not             shift and go to state 34
    Integer         shift and go to state 37
    LParen          shift and go to state 36

    statement_matched              shift and go to state 147
    expression                     shift and go to state 131
    statement_unmatched            shift and go to state 148
    opt_expression                 shift and go to state 136
    empty                          shift and go to state 140
    assignment                     shift and go to state 19
    conditional                    shift and go to state 20
    logical_or                     shift and go to state 21
    logical_and                    shift and go to state 22
    bit_or                         shift and go to state 23
    xor                            shift and go to state 24
    bit_and                        shift and go to state 25
    equality                       shift and go to state 26
    relational                     shift and go to state 27
    additive                       shift and go to state 28
    multiplicative                 shift and go to state 29
    unary                          shift and go to state 31
    postfix                        shift and go to state 32
    primary                        shift and go to state 35

state 135

    (31) statement_matched -> For . LParen p_decl_opt_expr_union Semi opt_expression Semi opt_expression RParen statement_matched
    (32) statement_unmatched -> For . LParen p_decl_opt_expr_union Semi opt_expression Semi opt_expression RParen statement_unmatched

    LParen          shift and go to state 149


state 136

    (36) statement_matched -> opt_expression . Semi

    Semi            shift and go to state 150


state 137

    (35) statement_matched -> Return . expression Semi
    (52) expression -> . assignment
    (53) assignment -> . conditional
    (69) assignment -> . Identifier index_list Assign expression
    (75) assignment -> . Identifier Assign expression
    (54) conditional -> . logical_or
    (92) conditional -> . logical_or Question expression Colon conditional
    (55) logical_or -> . logical_and
    (76) logical_or -> . logical_or Or logical_and
    (56) logical_and -> . bit_or
    (77) logical_and -> . logical_and And bit_or
    (57) bit_or -> . xor
    (78) bit_or -> . bit_or BitOr xor
    (58) xor -> . bit_and
    (79) xor -> . xor Xor bit_and
    (59) bit_and -> . equality
    (80) bit_and -> . bit_and BitAnd equality
    (60) equality -> . relational
    (81) equality -> . equality NotEqual relational
    (82) equality -> . equality Equal relational
    (61) relational -> . additive
    (83) relational -> . relational Less additive
    (84) relational -> . relational Greater additive
    (85) relational -> . relational LessEqual additive
    (86) relational -> . relational GreaterEqual additive
    (62) additive -> . multiplicative
    (87) additive -> . additive Plus multiplicative
    (88) additive -> . additive Minus multiplicative
    (63) multiplicative -> . unary
    (89) multiplicative -> . multiplicative Mul unary
    (90) multiplicative -> . multiplicative Div unary
    (91) multiplicative -> . multiplicative Mod unary
    (64) unary -> . postfix
    (66) unary -> . Minus unary
    (67) unary -> . BitNot unary
    (68) unary -> . Not unary
    (65) postfix -> . primary
    (70) postfix -> . Identifier LParen expression_list RParen
    (71) postfix -> . Identifier index_list
    (93) primary -> . Integer
    (94) primary -> . Identifier
    (95) primary -> . LParen expression RParen

    Identifier      shift and go to state 17
    Minus           shift and go to state 30
    BitNot          shift and go to state 33
    Not             shift and go to state 34
    Integer         shift and go to state 37
    LParen          shift and go to state 36

    expression                     shift and go to state 151
    assignment                     shift and go to state 19
    conditional                    shift and go to state 20
    logical_or                     shift and go to state 21
    logical_and                    shift and go to state 22
    bit_or                         shift and go to state 23
    xor                            shift and go to state 24
    bit_and                        shift and go to state 25
    equality                       shift and go to state 26
    relational                     shift and go to state 27
    additive                       shift and go to state 28
    multiplicative                 shift and go to state 29
    unary                          shift and go to state 31
    postfix                        shift and go to state 32
    primary                        shift and go to state 35

state 138

    (38) statement_matched -> Break . Semi

    Semi            shift and go to state 152


state 139

    (39) statement_matched -> Continue . Semi

    Semi            shift and go to state 153


state 140

    (41) opt_expression -> empty .

    Semi            reduce using rule 41 (opt_expression -> empty .)
    RParen          reduce using rule 41 (opt_expression -> empty .)


state 141

    (12) int_index_list -> LBrack Integer RBrack int_index_list .

    RParen          reduce using rule 12 (int_index_list -> LBrack Integer RBrack int_index_list .)
    Comma           reduce using rule 12 (int_index_list -> LBrack Integer RBrack int_index_list .)


state 142

    (42) declaration -> type Identifier .
    (43) declaration -> type Identifier . index_list
    (44) declaration -> type Identifier . Assign expression
    (45) declaration -> type Identifier . index_list Assign LBrace array_init_list RBrace
    (49) index_list -> . index_list_r LBrack expression RBrack
    (50) index_list_r -> . index_list_r LBrack expression RBrack
    (51) index_list_r -> . empty
    (1) empty -> .

    Semi            reduce using rule 42 (declaration -> type Identifier .)
    Assign          shift and go to state 12
    LBrack          reduce using rule 1 (empty -> .)

    index_list                     shift and go to state 11
    index_list_r                   shift and go to state 14
    empty                          shift and go to state 15

state 143

    (37) statement_matched -> LBrace block . RBrace
    (18) block -> block . block_item
    (20) block_item -> . statement
    (21) block_item -> . declaration Semi
    (25) statement -> . statement_matched
    (26) statement -> . statement_unmatched
    (42) declaration -> . type Identifier
    (43) declaration -> . type Identifier index_list
    (44) declaration -> . type Identifier Assign expression
    (45) declaration -> . type Identifier index_list Assign LBrace array_init_list RBrace
    (22) statement_matched -> . If LParen expression RParen statement_matched Else statement_matched
    (27) statement_matched -> . While LParen expression RParen statement_matched
    (29) statement_matched -> . Do statement_matched While LParen expression RParen Semi
    (31) statement_matched -> . For LParen p_decl_opt_expr_union Semi opt_expression Semi opt_expression RParen statement_matched
    (35) statement_matched -> . Return expression Semi
    (36) statement_matched -> . opt_expression Semi
    (37) statement_matched -> . LBrace block RBrace
    (38) statement_matched -> . Break Semi
    (39) statement_matched -> . Continue Semi
    (23) statement_unmatched -> . If LParen expression RParen statement_matched Else statement_unmatched
    (24) statement_unmatched -> . If LParen expression RParen statement
    (28) statement_unmatched -> . While LParen expression RParen statement_unmatched
    (30) statement_unmatched -> . Do statement_unmatched While LParen expression RParen Semi
    (32) statement_unmatched -> . For LParen p_decl_opt_expr_union Semi opt_expression Semi opt_expression RParen statement_unmatched
    (5) type -> . Int
    (40) opt_expression -> . expression
    (41) opt_expression -> . empty
    (52) expression -> . assignment
    (1) empty -> .
    (53) assignment -> . conditional
    (69) assignment -> . Identifier index_list Assign expression
    (75) assignment -> . Identifier Assign expression
    (54) conditional -> . logical_or
    (92) conditional -> . logical_or Question expression Colon conditional
    (55) logical_or -> . logical_and
    (76) logical_or -> . logical_or Or logical_and
    (56) logical_and -> . bit_or
    (77) logical_and -> . logical_and And bit_or
    (57) bit_or -> . xor
    (78) bit_or -> . bit_or BitOr xor
    (58) xor -> . bit_and
    (79) xor -> . xor Xor bit_and
    (59) bit_and -> . equality
    (80) bit_and -> . bit_and BitAnd equality
    (60) equality -> . relational
    (81) equality -> . equality NotEqual relational
    (82) equality -> . equality Equal relational
    (61) relational -> . additive
    (83) relational -> . relational Less additive
    (84) relational -> . relational Greater additive
    (85) relational -> . relational LessEqual additive
    (86) relational -> . relational GreaterEqual additive
    (62) additive -> . multiplicative
    (87) additive -> . additive Plus multiplicative
    (88) additive -> . additive Minus multiplicative
    (63) multiplicative -> . unary
    (89) multiplicative -> . multiplicative Mul unary
    (90) multiplicative -> . multiplicative Div unary
    (91) multiplicative -> . multiplicative Mod unary
    (64) unary -> . postfix
    (66) unary -> . Minus unary
    (67) unary -> . BitNot unary
    (68) unary -> . Not unary
    (65) postfix -> . primary
    (70) postfix -> . Identifier LParen expression_list RParen
    (71) postfix -> . Identifier index_list
    (93) primary -> . Integer
    (94) primary -> . Identifier
    (95) primary -> . LParen expression RParen

    RBrace          shift and go to state 154
    If              shift and go to state 132
    While           shift and go to state 133
    Do              shift and go to state 134
    For             shift and go to state 135
    Return          shift and go to state 137
    LBrace          shift and go to state 124
    Break           shift and go to state 138
    Continue        shift and go to state 139
    Int             shift and go to state 8
    Semi            reduce using rule 1 (empty -> .)
    Identifier      shift and go to state 17
    Minus           shift and go to state 30
    BitNot          shift and go to state 33
    Not             shift and go to state 34
    Integer         shift and go to state 37
    LParen          shift and go to state 36

    block_item                     shift and go to state 126
    statement                      shift and go to state 127
    declaration                    shift and go to state 128
    statement_matched              shift and go to state 129
    statement_unmatched            shift and go to state 130
    type                           shift and go to state 123
    expression                     shift and go to state 131
    opt_expression                 shift and go to state 136
    empty                          shift and go to state 140
    assignment                     shift and go to state 19
    conditional                    shift and go to state 20
    logical_or                     shift and go to state 21
    logical_and                    shift and go to state 22
    bit_or                         shift and go to state 23
    xor                            shift and go to state 24
    bit_and                        shift and go to state 25
    equality                       shift and go to state 26
    relational                     shift and go to state 27
    additive                       shift and go to state 28
    multiplicative                 shift and go to state 29
    unary                          shift and go to state 31
    postfix                        shift and go to state 32
    primary                        shift and go to state 35

state 144

    (21) block_item -> declaration Semi .

    RBrace          reduce using rule 21 (block_item -> declaration Semi .)
    If              reduce using rule 21 (block_item -> declaration Semi .)
    While           reduce using rule 21 (block_item -> declaration Semi .)
    Do              reduce using rule 21 (block_item -> declaration Semi .)
    For             reduce using rule 21 (block_item -> declaration Semi .)
    Return          reduce using rule 21 (block_item -> declaration Semi .)
    LBrace          reduce using rule 21 (block_item -> declaration Semi .)
    Break           reduce using rule 21 (block_item -> declaration Semi .)
    Continue        reduce using rule 21 (block_item -> declaration Semi .)
    Int             reduce using rule 21 (block_item -> declaration Semi .)
    Identifier      reduce using rule 21 (block_item -> declaration Semi .)
    Minus           reduce using rule 21 (block_item -> declaration Semi .)
    BitNot          reduce using rule 21 (block_item -> declaration Semi .)
    Not             reduce using rule 21 (block_item -> declaration Semi .)
    Integer         reduce using rule 21 (block_item -> declaration Semi .)
    LParen          reduce using rule 21 (block_item -> declaration Semi .)
    Semi            reduce using rule 21 (block_item -> declaration Semi .)


state 145

    (22) statement_matched -> If LParen . expression RParen statement_matched Else statement_matched
    (23) statement_unmatched -> If LParen . expression RParen statement_matched Else statement_unmatched
    (24) statement_unmatched -> If LParen . expression RParen statement
    (52) expression -> . assignment
    (53) assignment -> . conditional
    (69) assignment -> . Identifier index_list Assign expression
    (75) assignment -> . Identifier Assign expression
    (54) conditional -> . logical_or
    (92) conditional -> . logical_or Question expression Colon conditional
    (55) logical_or -> . logical_and
    (76) logical_or -> . logical_or Or logical_and
    (56) logical_and -> . bit_or
    (77) logical_and -> . logical_and And bit_or
    (57) bit_or -> . xor
    (78) bit_or -> . bit_or BitOr xor
    (58) xor -> . bit_and
    (79) xor -> . xor Xor bit_and
    (59) bit_and -> . equality
    (80) bit_and -> . bit_and BitAnd equality
    (60) equality -> . relational
    (81) equality -> . equality NotEqual relational
    (82) equality -> . equality Equal relational
    (61) relational -> . additive
    (83) relational -> . relational Less additive
    (84) relational -> . relational Greater additive
    (85) relational -> . relational LessEqual additive
    (86) relational -> . relational GreaterEqual additive
    (62) additive -> . multiplicative
    (87) additive -> . additive Plus multiplicative
    (88) additive -> . additive Minus multiplicative
    (63) multiplicative -> . unary
    (89) multiplicative -> . multiplicative Mul unary
    (90) multiplicative -> . multiplicative Div unary
    (91) multiplicative -> . multiplicative Mod unary
    (64) unary -> . postfix
    (66) unary -> . Minus unary
    (67) unary -> . BitNot unary
    (68) unary -> . Not unary
    (65) postfix -> . primary
    (70) postfix -> . Identifier LParen expression_list RParen
    (71) postfix -> . Identifier index_list
    (93) primary -> . Integer
    (94) primary -> . Identifier
    (95) primary -> . LParen expression RParen

    Identifier      shift and go to state 17
    Minus           shift and go to state 30
    BitNot          shift and go to state 33
    Not             shift and go to state 34
    Integer         shift and go to state 37
    LParen          shift and go to state 36

    expression                     shift and go to state 155
    assignment                     shift and go to state 19
    conditional                    shift and go to state 20
    logical_or                     shift and go to state 21
    logical_and                    shift and go to state 22
    bit_or                         shift and go to state 23
    xor                            shift and go to state 24
    bit_and                        shift and go to state 25
    equality                       shift and go to state 26
    relational                     shift and go to state 27
    additive                       shift and go to state 28
    multiplicative                 shift and go to state 29
    unary                          shift and go to state 31
    postfix                        shift and go to state 32
    primary                        shift and go to state 35

state 146

    (27) statement_matched -> While LParen . expression RParen statement_matched
    (28) statement_unmatched -> While LParen . expression RParen statement_unmatched
    (52) expression -> . assignment
    (53) assignment -> . conditional
    (69) assignment -> . Identifier index_list Assign expression
    (75) assignment -> . Identifier Assign expression
    (54) conditional -> . logical_or
    (92) conditional -> . logical_or Question expression Colon conditional
    (55) logical_or -> . logical_and
    (76) logical_or -> . logical_or Or logical_and
    (56) logical_and -> . bit_or
    (77) logical_and -> . logical_and And bit_or
    (57) bit_or -> . xor
    (78) bit_or -> . bit_or BitOr xor
    (58) xor -> . bit_and
    (79) xor -> . xor Xor bit_and
    (59) bit_and -> . equality
    (80) bit_and -> . bit_and BitAnd equality
    (60) equality -> . relational
    (81) equality -> . equality NotEqual relational
    (82) equality -> . equality Equal relational
    (61) relational -> . additive
    (83) relational -> . relational Less additive
    (84) relational -> . relational Greater additive
    (85) relational -> . relational LessEqual additive
    (86) relational -> . relational GreaterEqual additive
    (62) additive -> . multiplicative
    (87) additive -> . additive Plus multiplicative
    (88) additive -> . additive Minus multiplicative
    (63) multiplicative -> . unary
    (89) multiplicative -> . multiplicative Mul unary
    (90) multiplicative -> . multiplicative Div unary
    (91) multiplicative -> . multiplicative Mod unary
    (64) unary -> . postfix
    (66) unary -> . Minus unary
    (67) unary -> . BitNot unary
    (68) unary -> . Not unary
    (65) postfix -> . primary
    (70) postfix -> . Identifier LParen expression_list RParen
    (71) postfix -> . Identifier index_list
    (93) primary -> . Integer
    (94) primary -> . Identifier
    (95) primary -> . LParen expression RParen

    Identifier      shift and go to state 17
    Minus           shift and go to state 30
    BitNot          shift and go to state 33
    Not             shift and go to state 34
    Integer         shift and go to state 37
    LParen          shift and go to state 36

    expression                     shift and go to state 156
    assignment                     shift and go to state 19
    conditional                    shift and go to state 20
    logical_or                     shift and go to state 21
    logical_and                    shift and go to state 22
    bit_or                         shift and go to state 23
    xor                            shift and go to state 24
    bit_and                        shift and go to state 25
    equality                       shift and go to state 26
    relational                     shift and go to state 27
    additive                       shift and go to state 28
    multiplicative                 shift and go to state 29
    unary                          shift and go to state 31
    postfix                        shift and go to state 32
    primary                        shift and go to state 35

state 147

    (29) statement_matched -> Do statement_matched . While LParen expression RParen Semi

    While           shift and go to state 157


state 148

    (30) statement_unmatched -> Do statement_unmatched . While LParen expression RParen Semi

    While           shift and go to state 158


state 149

    (31) statement_matched -> For LParen . p_decl_opt_expr_union Semi opt_expression Semi opt_expression RParen statement_matched
    (32) statement_unmatched -> For LParen . p_decl_opt_expr_union Semi opt_expression Semi opt_expression RParen statement_unmatched
    (33) p_decl_opt_expr_union -> . declaration
    (34) p_decl_opt_expr_union -> . opt_expression
    (42) declaration -> . type Identifier
    (43) declaration -> . type Identifier index_list
    (44) declaration -> . type Identifier Assign expression
    (45) declaration -> . type Identifier index_list Assign LBrace array_init_list RBrace
    (40) opt_expression -> . expression
    (41) opt_expression -> . empty
    (5) type -> . Int
    (52) expression -> . assignment
    (1) empty -> .
    (53) assignment -> . conditional
    (69) assignment -> . Identifier index_list Assign expression
    (75) assignment -> . Identifier Assign expression
    (54) conditional -> . logical_or
    (92) conditional -> . logical_or Question expression Colon conditional
    (55) logical_or -> . logical_and
    (76) logical_or -> . logical_or Or logical_and
    (56) logical_and -> . bit_or
    (77) logical_and -> . logical_and And bit_or
    (57) bit_or -> . xor
    (78) bit_or -> . bit_or BitOr xor
    (58) xor -> . bit_and
    (79) xor -> . xor Xor bit_and
    (59) bit_and -> . equality
    (80) bit_and -> . bit_and BitAnd equality
    (60) equality -> . relational
    (81) equality -> . equality NotEqual relational
    (82) equality -> . equality Equal relational
    (61) relational -> . additive
    (83) relational -> . relational Less additive
    (84) relational -> . relational Greater additive
    (85) relational -> . relational LessEqual additive
    (86) relational -> . relational GreaterEqual additive
    (62) additive -> . multiplicative
    (87) additive -> . additive Plus multiplicative
    (88) additive -> . additive Minus multiplicative
    (63) multiplicative -> . unary
    (89) multiplicative -> . multiplicative Mul unary
    (90) multiplicative -> . multiplicative Div unary
    (91) multiplicative -> . multiplicative Mod unary
    (64) unary -> . postfix
    (66) unary -> . Minus unary
    (67) unary -> . BitNot unary
    (68) unary -> . Not unary
    (65) postfix -> . primary
    (70) postfix -> . Identifier LParen expression_list RParen
    (71) postfix -> . Identifier index_list
    (93) primary -> . Integer
    (94) primary -> . Identifier
    (95) primary -> . LParen expression RParen

    Int             shift and go to state 8
    Semi            reduce using rule 1 (empty -> .)
    Identifier      shift and go to state 17
    Minus           shift and go to state 30
    BitNot          shift and go to state 33
    Not             shift and go to state 34
    Integer         shift and go to state 37
    LParen          shift and go to state 36

    p_decl_opt_expr_union          shift and go to state 159
    opt_expression                 shift and go to state 160
    declaration                    shift and go to state 161
    type                           shift and go to state 123
    expression                     shift and go to state 131
    empty                          shift and go to state 140
    assignment                     shift and go to state 19
    conditional                    shift and go to state 20
    logical_or                     shift and go to state 21
    logical_and                    shift and go to state 22
    bit_or                         shift and go to state 23
    xor                            shift and go to state 24
    bit_and                        shift and go to state 25
    equality                       shift and go to state 26
    relational                     shift and go to state 27
    additive                       shift and go to state 28
    multiplicative                 shift and go to state 29
    unary                          shift and go to state 31
    postfix                        shift and go to state 32
    primary                        shift and go to state 35

state 150

    (36) statement_matched -> opt_expression Semi .

    RBrace          reduce using rule 36 (statement_matched -> opt_expression Semi .)
    If              reduce using rule 36 (statement_matched -> opt_expression Semi .)
    While           reduce using rule 36 (statement_matched -> opt_expression Semi .)
    Do              reduce using rule 36 (statement_matched -> opt_expression Semi .)
    For             reduce using rule 36 (statement_matched -> opt_expression Semi .)
    Return          reduce using rule 36 (statement_matched -> opt_expression Semi .)
    LBrace          reduce using rule 36 (statement_matched -> opt_expression Semi .)
    Break           reduce using rule 36 (statement_matched -> opt_expression Semi .)
    Continue        reduce using rule 36 (statement_matched -> opt_expression Semi .)
    Int             reduce using rule 36 (statement_matched -> opt_expression Semi .)
    Identifier      reduce using rule 36 (statement_matched -> opt_expression Semi .)
    Minus           reduce using rule 36 (statement_matched -> opt_expression Semi .)
    BitNot          reduce using rule 36 (statement_matched -> opt_expression Semi .)
    Not             reduce using rule 36 (statement_matched -> opt_expression Semi .)
    Integer         reduce using rule 36 (statement_matched -> opt_expression Semi .)
    LParen          reduce using rule 36 (statement_matched -> opt_expression Semi .)
    Semi            reduce using rule 36 (statement_matched -> opt_expression Semi .)
    Else            reduce using rule 36 (statement_matched -> opt_expression Semi .)


state 151

    (35) statement_matched -> Return expression . Semi

    Semi            shift and go to state 162


state 152

    (38) statement_matched -> Break Semi .

    RBrace          reduce using rule 38 (statement_matched -> Break Semi .)
    If              reduce using rule 38 (statement_matched -> Break Semi .)
    While           reduce using rule 38 (statement_matched -> Break Semi .)
    Do              reduce using rule 38 (statement_matched -> Break Semi .)
    For             reduce using rule 38 (statement_matched -> Break Semi .)
    Return          reduce using rule 38 (statement_matched -> Break Semi .)
    LBrace          reduce using rule 38 (statement_matched -> Break Semi .)
    Break           reduce using rule 38 (statement_matched -> Break Semi .)
    Continue        reduce using rule 38 (statement_matched -> Break Semi .)
    Int             reduce using rule 38 (statement_matched -> Break Semi .)
    Identifier      reduce using rule 38 (statement_matched -> Break Semi .)
    Minus           reduce using rule 38 (statement_matched -> Break Semi .)
    BitNot          reduce using rule 38 (statement_matched -> Break Semi .)
    Not             reduce using rule 38 (statement_matched -> Break Semi .)
    Integer         reduce using rule 38 (statement_matched -> Break Semi .)
    LParen          reduce using rule 38 (statement_matched -> Break Semi .)
    Semi            reduce using rule 38 (statement_matched -> Break Semi .)
    Else            reduce using rule 38 (statement_matched -> Break Semi .)


state 153

    (39) statement_matched -> Continue Semi .

    RBrace          reduce using rule 39 (statement_matched -> Continue Semi .)
    If              reduce using rule 39 (statement_matched -> Continue Semi .)
    While           reduce using rule 39 (statement_matched -> Continue Semi .)
    Do              reduce using rule 39 (statement_matched -> Continue Semi .)
    For             reduce using rule 39 (statement_matched -> Continue Semi .)
    Return          reduce using rule 39 (statement_matched -> Continue Semi .)
    LBrace          reduce using rule 39 (statement_matched -> Continue Semi .)
    Break           reduce using rule 39 (statement_matched -> Continue Semi .)
    Continue        reduce using rule 39 (statement_matched -> Continue Semi .)
    Int             reduce using rule 39 (statement_matched -> Continue Semi .)
    Identifier      reduce using rule 39 (statement_matched -> Continue Semi .)
    Minus           reduce using rule 39 (statement_matched -> Continue Semi .)
    BitNot          reduce using rule 39 (statement_matched -> Continue Semi .)
    Not             reduce using rule 39 (statement_matched -> Continue Semi .)
    Integer         reduce using rule 39 (statement_matched -> Continue Semi .)
    LParen          reduce using rule 39 (statement_matched -> Continue Semi .)
    Semi            reduce using rule 39 (statement_matched -> Continue Semi .)
    Else            reduce using rule 39 (statement_matched -> Continue Semi .)


state 154

    (37) statement_matched -> LBrace block RBrace .

    RBrace          reduce using rule 37 (statement_matched -> LBrace block RBrace .)
    If              reduce using rule 37 (statement_matched -> LBrace block RBrace .)
    While           reduce using rule 37 (statement_matched -> LBrace block RBrace .)
    Do              reduce using rule 37 (statement_matched -> LBrace block RBrace .)
    For             reduce using rule 37 (statement_matched -> LBrace block RBrace .)
    Return          reduce using rule 37 (statement_matched -> LBrace block RBrace .)
    LBrace          reduce using rule 37 (statement_matched -> LBrace block RBrace .)
    Break           reduce using rule 37 (statement_matched -> LBrace block RBrace .)
    Continue        reduce using rule 37 (statement_matched -> LBrace block RBrace .)
    Int             reduce using rule 37 (statement_matched -> LBrace block RBrace .)
    Identifier      reduce using rule 37 (statement_matched -> LBrace block RBrace .)
    Minus           reduce using rule 37 (statement_matched -> LBrace block RBrace .)
    BitNot          reduce using rule 37 (statement_matched -> LBrace block RBrace .)
    Not             reduce using rule 37 (statement_matched -> LBrace block RBrace .)
    Integer         reduce using rule 37 (statement_matched -> LBrace block RBrace .)
    LParen          reduce using rule 37 (statement_matched -> LBrace block RBrace .)
    Semi            reduce using rule 37 (statement_matched -> LBrace block RBrace .)
    Else            reduce using rule 37 (statement_matched -> LBrace block RBrace .)


state 155

    (22) statement_matched -> If LParen expression . RParen statement_matched Else statement_matched
    (23) statement_unmatched -> If LParen expression . RParen statement_matched Else statement_unmatched
    (24) statement_unmatched -> If LParen expression . RParen statement

    RParen          shift and go to state 163


state 156

    (27) statement_matched -> While LParen expression . RParen statement_matched
    (28) statement_unmatched -> While LParen expression . RParen statement_unmatched

    RParen          shift and go to state 164


state 157

    (29) statement_matched -> Do statement_matched While . LParen expression RParen Semi

    LParen          shift and go to state 165


state 158

    (30) statement_unmatched -> Do statement_unmatched While . LParen expression RParen Semi

    LParen          shift and go to state 166


state 159

    (31) statement_matched -> For LParen p_decl_opt_expr_union . Semi opt_expression Semi opt_expression RParen statement_matched
    (32) statement_unmatched -> For LParen p_decl_opt_expr_union . Semi opt_expression Semi opt_expression RParen statement_unmatched

    Semi            shift and go to state 167


state 160

    (34) p_decl_opt_expr_union -> opt_expression .

    Semi            reduce using rule 34 (p_decl_opt_expr_union -> opt_expression .)


state 161

    (33) p_decl_opt_expr_union -> declaration .

    Semi            reduce using rule 33 (p_decl_opt_expr_union -> declaration .)


state 162

    (35) statement_matched -> Return expression Semi .

    RBrace          reduce using rule 35 (statement_matched -> Return expression Semi .)
    If              reduce using rule 35 (statement_matched -> Return expression Semi .)
    While           reduce using rule 35 (statement_matched -> Return expression Semi .)
    Do              reduce using rule 35 (statement_matched -> Return expression Semi .)
    For             reduce using rule 35 (statement_matched -> Return expression Semi .)
    Return          reduce using rule 35 (statement_matched -> Return expression Semi .)
    LBrace          reduce using rule 35 (statement_matched -> Return expression Semi .)
    Break           reduce using rule 35 (statement_matched -> Return expression Semi .)
    Continue        reduce using rule 35 (statement_matched -> Return expression Semi .)
    Int             reduce using rule 35 (statement_matched -> Return expression Semi .)
    Identifier      reduce using rule 35 (statement_matched -> Return expression Semi .)
    Minus           reduce using rule 35 (statement_matched -> Return expression Semi .)
    BitNot          reduce using rule 35 (statement_matched -> Return expression Semi .)
    Not             reduce using rule 35 (statement_matched -> Return expression Semi .)
    Integer         reduce using rule 35 (statement_matched -> Return expression Semi .)
    LParen          reduce using rule 35 (statement_matched -> Return expression Semi .)
    Semi            reduce using rule 35 (statement_matched -> Return expression Semi .)
    Else            reduce using rule 35 (statement_matched -> Return expression Semi .)


state 163

    (22) statement_matched -> If LParen expression RParen . statement_matched Else statement_matched
    (23) statement_unmatched -> If LParen expression RParen . statement_matched Else statement_unmatched
    (24) statement_unmatched -> If LParen expression RParen . statement
    (22) statement_matched -> . If LParen expression RParen statement_matched Else statement_matched
    (27) statement_matched -> . While LParen expression RParen statement_matched
    (29) statement_matched -> . Do statement_matched While LParen expression RParen Semi
    (31) statement_matched -> . For LParen p_decl_opt_expr_union Semi opt_expression Semi opt_expression RParen statement_matched
    (35) statement_matched -> . Return expression Semi
    (36) statement_matched -> . opt_expression Semi
    (37) statement_matched -> . LBrace block RBrace
    (38) statement_matched -> . Break Semi
    (39) statement_matched -> . Continue Semi
    (25) statement -> . statement_matched
    (26) statement -> . statement_unmatched
    (40) opt_expression -> . expression
    (41) opt_expression -> . empty
    (23) statement_unmatched -> . If LParen expression RParen statement_matched Else statement_unmatched
    (24) statement_unmatched -> . If LParen expression RParen statement
    (28) statement_unmatched -> . While LParen expression RParen statement_unmatched
    (30) statement_unmatched -> . Do statement_unmatched While LParen expression RParen Semi
    (32) statement_unmatched -> . For LParen p_decl_opt_expr_union Semi opt_expression Semi opt_expression RParen statement_unmatched
    (52) expression -> . assignment
    (1) empty -> .
    (53) assignment -> . conditional
    (69) assignment -> . Identifier index_list Assign expression
    (75) assignment -> . Identifier Assign expression
    (54) conditional -> . logical_or
    (92) conditional -> . logical_or Question expression Colon conditional
    (55) logical_or -> . logical_and
    (76) logical_or -> . logical_or Or logical_and
    (56) logical_and -> . bit_or
    (77) logical_and -> . logical_and And bit_or
    (57) bit_or -> . xor
    (78) bit_or -> . bit_or BitOr xor
    (58) xor -> . bit_and
    (79) xor -> . xor Xor bit_and
    (59) bit_and -> . equality
    (80) bit_and -> . bit_and BitAnd equality
    (60) equality -> . relational
    (81) equality -> . equality NotEqual relational
    (82) equality -> . equality Equal relational
    (61) relational -> . additive
    (83) relational -> . relational Less additive
    (84) relational -> . relational Greater additive
    (85) relational -> . relational LessEqual additive
    (86) relational -> . relational GreaterEqual additive
    (62) additive -> . multiplicative
    (87) additive -> . additive Plus multiplicative
    (88) additive -> . additive Minus multiplicative
    (63) multiplicative -> . unary
    (89) multiplicative -> . multiplicative Mul unary
    (90) multiplicative -> . multiplicative Div unary
    (91) multiplicative -> . multiplicative Mod unary
    (64) unary -> . postfix
    (66) unary -> . Minus unary
    (67) unary -> . BitNot unary
    (68) unary -> . Not unary
    (65) postfix -> . primary
    (70) postfix -> . Identifier LParen expression_list RParen
    (71) postfix -> . Identifier index_list
    (93) primary -> . Integer
    (94) primary -> . Identifier
    (95) primary -> . LParen expression RParen

    If              shift and go to state 132
    While           shift and go to state 133
    Do              shift and go to state 134
    For             shift and go to state 135
    Return          shift and go to state 137
    LBrace          shift and go to state 124
    Break           shift and go to state 138
    Continue        shift and go to state 139
    Semi            reduce using rule 1 (empty -> .)
    Identifier      shift and go to state 17
    Minus           shift and go to state 30
    BitNot          shift and go to state 33
    Not             shift and go to state 34
    Integer         shift and go to state 37
    LParen          shift and go to state 36

    expression                     shift and go to state 131
    statement_matched              shift and go to state 168
    statement_unmatched            shift and go to state 130
    statement                      shift and go to state 169
    opt_expression                 shift and go to state 136
    empty                          shift and go to state 140
    assignment                     shift and go to state 19
    conditional                    shift and go to state 20
    logical_or                     shift and go to state 21
    logical_and                    shift and go to state 22
    bit_or                         shift and go to state 23
    xor                            shift and go to state 24
    bit_and                        shift and go to state 25
    equality                       shift and go to state 26
    relational                     shift and go to state 27
    additive                       shift and go to state 28
    multiplicative                 shift and go to state 29
    unary                          shift and go to state 31
    postfix                        shift and go to state 32
    primary                        shift and go to state 35

state 164

    (27) statement_matched -> While LParen expression RParen . statement_matched
    (28) statement_unmatched -> While LParen expression RParen . statement_unmatched
    (22) statement_matched -> . If LParen expression RParen statement_matched Else statement_matched
    (27) statement_matched -> . While LParen expression RParen statement_matched
    (29) statement_matched -> . Do statement_matched While LParen expression RParen Semi
    (31) statement_matched -> . For LParen p_decl_opt_expr_union Semi opt_expression Semi opt_expression RParen statement_matched
    (35) statement_matched -> . Return expression Semi
    (36) statement_matched -> . opt_expression Semi
    (37) statement_matched -> . LBrace block RBrace
    (38) statement_matched -> . Break Semi
    (39) statement_matched -> . Continue Semi
    (23) statement_unmatched -> . If LParen expression RParen statement_matched Else statement_unmatched
    (24) statement_unmatched -> . If LParen expression RParen statement
    (28) statement_unmatched -> . While LParen expression RParen statement_unmatched
    (30) statement_unmatched -> . Do statement_unmatched While LParen expression RParen Semi
    (32) statement_unmatched -> . For LParen p_decl_opt_expr_union Semi opt_expression Semi opt_expression RParen statement_unmatched
    (40) opt_expression -> . expression
    (41) opt_expression -> . empty
    (52) expression -> . assignment
    (1) empty -> .
    (53) assignment -> . conditional
    (69) assignment -> . Identifier index_list Assign expression
    (75) assignment -> . Identifier Assign expression
    (54) conditional -> . logical_or
    (92) conditional -> . logical_or Question expression Colon conditional
    (55) logical_or -> . logical_and
    (76) logical_or -> . logical_or Or logical_and
    (56) logical_and -> . bit_or
    (77) logical_and -> . logical_and And bit_or
    (57) bit_or -> . xor
    (78) bit_or -> . bit_or BitOr xor
    (58) xor -> . bit_and
    (79) xor -> . xor Xor bit_and
    (59) bit_and -> . equality
    (80) bit_and -> . bit_and BitAnd equality
    (60) equality -> . relational
    (81) equality -> . equality NotEqual relational
    (82) equality -> . equality Equal relational
    (61) relational -> . additive
    (83) relational -> . relational Less additive
    (84) relational -> . relational Greater additive
    (85) relational -> . relational LessEqual additive
    (86) relational -> . relational GreaterEqual additive
    (62) additive -> . multiplicative
    (87) additive -> . additive Plus multiplicative
    (88) additive -> . additive Minus multiplicative
    (63) multiplicative -> . unary
    (89) multiplicative -> . multiplicative Mul unary
    (90) multiplicative -> . multiplicative Div unary
    (91) multiplicative -> . multiplicative Mod unary
    (64) unary -> . postfix
    (66) unary -> . Minus unary
    (67) unary -> . BitNot unary
    (68) unary -> . Not unary
    (65) postfix -> . primary
    (70) postfix -> . Identifier LParen expression_list RParen
    (71) postfix -> . Identifier index_list
    (93) primary -> . Integer
    (94) primary -> . Identifier
    (95) primary -> . LParen expression RParen

    If              shift and go to state 132
    While           shift and go to state 133
    Do              shift and go to state 134
    For             shift and go to state 135
    Return          shift and go to state 137
    LBrace          shift and go to state 124
    Break           shift and go to state 138
    Continue        shift and go to state 139
    Semi            reduce using rule 1 (empty -> .)
    Identifier      shift and go to state 17
    Minus           shift and go to state 30
    BitNot          shift and go to state 33
    Not             shift and go to state 34
    Integer         shift and go to state 37
    LParen          shift and go to state 36

    expression                     shift and go to state 131
    statement_matched              shift and go to state 170
    statement_unmatched            shift and go to state 171
    opt_expression                 shift and go to state 136
    empty                          shift and go to state 140
    assignment                     shift and go to state 19
    conditional                    shift and go to state 20
    logical_or                     shift and go to state 21
    logical_and                    shift and go to state 22
    bit_or                         shift and go to state 23
    xor                            shift and go to state 24
    bit_and                        shift and go to state 25
    equality                       shift and go to state 26
    relational                     shift and go to state 27
    additive                       shift and go to state 28
    multiplicative                 shift and go to state 29
    unary                          shift and go to state 31
    postfix                        shift and go to state 32
    primary                        shift and go to state 35

state 165

    (29) statement_matched -> Do statement_matched While LParen . expression RParen Semi
    (52) expression -> . assignment
    (53) assignment -> . conditional
    (69) assignment -> . Identifier index_list Assign expression
    (75) assignment -> . Identifier Assign expression
    (54) conditional -> . logical_or
    (92) conditional -> . logical_or Question expression Colon conditional
    (55) logical_or -> . logical_and
    (76) logical_or -> . logical_or Or logical_and
    (56) logical_and -> . bit_or
    (77) logical_and -> . logical_and And bit_or
    (57) bit_or -> . xor
    (78) bit_or -> . bit_or BitOr xor
    (58) xor -> . bit_and
    (79) xor -> . xor Xor bit_and
    (59) bit_and -> . equality
    (80) bit_and -> . bit_and BitAnd equality
    (60) equality -> . relational
    (81) equality -> . equality NotEqual relational
    (82) equality -> . equality Equal relational
    (61) relational -> . additive
    (83) relational -> . relational Less additive
    (84) relational -> . relational Greater additive
    (85) relational -> . relational LessEqual additive
    (86) relational -> . relational GreaterEqual additive
    (62) additive -> . multiplicative
    (87) additive -> . additive Plus multiplicative
    (88) additive -> . additive Minus multiplicative
    (63) multiplicative -> . unary
    (89) multiplicative -> . multiplicative Mul unary
    (90) multiplicative -> . multiplicative Div unary
    (91) multiplicative -> . multiplicative Mod unary
    (64) unary -> . postfix
    (66) unary -> . Minus unary
    (67) unary -> . BitNot unary
    (68) unary -> . Not unary
    (65) postfix -> . primary
    (70) postfix -> . Identifier LParen expression_list RParen
    (71) postfix -> . Identifier index_list
    (93) primary -> . Integer
    (94) primary -> . Identifier
    (95) primary -> . LParen expression RParen

    Identifier      shift and go to state 17
    Minus           shift and go to state 30
    BitNot          shift and go to state 33
    Not             shift and go to state 34
    Integer         shift and go to state 37
    LParen          shift and go to state 36

    expression                     shift and go to state 172
    assignment                     shift and go to state 19
    conditional                    shift and go to state 20
    logical_or                     shift and go to state 21
    logical_and                    shift and go to state 22
    bit_or                         shift and go to state 23
    xor                            shift and go to state 24
    bit_and                        shift and go to state 25
    equality                       shift and go to state 26
    relational                     shift and go to state 27
    additive                       shift and go to state 28
    multiplicative                 shift and go to state 29
    unary                          shift and go to state 31
    postfix                        shift and go to state 32
    primary                        shift and go to state 35

state 166

    (30) statement_unmatched -> Do statement_unmatched While LParen . expression RParen Semi
    (52) expression -> . assignment
    (53) assignment -> . conditional
    (69) assignment -> . Identifier index_list Assign expression
    (75) assignment -> . Identifier Assign expression
    (54) conditional -> . logical_or
    (92) conditional -> . logical_or Question expression Colon conditional
    (55) logical_or -> . logical_and
    (76) logical_or -> . logical_or Or logical_and
    (56) logical_and -> . bit_or
    (77) logical_and -> . logical_and And bit_or
    (57) bit_or -> . xor
    (78) bit_or -> . bit_or BitOr xor
    (58) xor -> . bit_and
    (79) xor -> . xor Xor bit_and
    (59) bit_and -> . equality
    (80) bit_and -> . bit_and BitAnd equality
    (60) equality -> . relational
    (81) equality -> . equality NotEqual relational
    (82) equality -> . equality Equal relational
    (61) relational -> . additive
    (83) relational -> . relational Less additive
    (84) relational -> . relational Greater additive
    (85) relational -> . relational LessEqual additive
    (86) relational -> . relational GreaterEqual additive
    (62) additive -> . multiplicative
    (87) additive -> . additive Plus multiplicative
    (88) additive -> . additive Minus multiplicative
    (63) multiplicative -> . unary
    (89) multiplicative -> . multiplicative Mul unary
    (90) multiplicative -> . multiplicative Div unary
    (91) multiplicative -> . multiplicative Mod unary
    (64) unary -> . postfix
    (66) unary -> . Minus unary
    (67) unary -> . BitNot unary
    (68) unary -> . Not unary
    (65) postfix -> . primary
    (70) postfix -> . Identifier LParen expression_list RParen
    (71) postfix -> . Identifier index_list
    (93) primary -> . Integer
    (94) primary -> . Identifier
    (95) primary -> . LParen expression RParen

    Identifier      shift and go to state 17
    Minus           shift and go to state 30
    BitNot          shift and go to state 33
    Not             shift and go to state 34
    Integer         shift and go to state 37
    LParen          shift and go to state 36

    expression                     shift and go to state 173
    assignment                     shift and go to state 19
    conditional                    shift and go to state 20
    logical_or                     shift and go to state 21
    logical_and                    shift and go to state 22
    bit_or                         shift and go to state 23
    xor                            shift and go to state 24
    bit_and                        shift and go to state 25
    equality                       shift and go to state 26
    relational                     shift and go to state 27
    additive                       shift and go to state 28
    multiplicative                 shift and go to state 29
    unary                          shift and go to state 31
    postfix                        shift and go to state 32
    primary                        shift and go to state 35

state 167

    (31) statement_matched -> For LParen p_decl_opt_expr_union Semi . opt_expression Semi opt_expression RParen statement_matched
    (32) statement_unmatched -> For LParen p_decl_opt_expr_union Semi . opt_expression Semi opt_expression RParen statement_unmatched
    (40) opt_expression -> . expression
    (41) opt_expression -> . empty
    (52) expression -> . assignment
    (1) empty -> .
    (53) assignment -> . conditional
    (69) assignment -> . Identifier index_list Assign expression
    (75) assignment -> . Identifier Assign expression
    (54) conditional -> . logical_or
    (92) conditional -> . logical_or Question expression Colon conditional
    (55) logical_or -> . logical_and
    (76) logical_or -> . logical_or Or logical_and
    (56) logical_and -> . bit_or
    (77) logical_and -> . logical_and And bit_or
    (57) bit_or -> . xor
    (78) bit_or -> . bit_or BitOr xor
    (58) xor -> . bit_and
    (79) xor -> . xor Xor bit_and
    (59) bit_and -> . equality
    (80) bit_and -> . bit_and BitAnd equality
    (60) equality -> . relational
    (81) equality -> . equality NotEqual relational
    (82) equality -> . equality Equal relational
    (61) relational -> . additive
    (83) relational -> . relational Less additive
    (84) relational -> . relational Greater additive
    (85) relational -> . relational LessEqual additive
    (86) relational -> . relational GreaterEqual additive
    (62) additive -> . multiplicative
    (87) additive -> . additive Plus multiplicative
    (88) additive -> . additive Minus multiplicative
    (63) multiplicative -> . unary
    (89) multiplicative -> . multiplicative Mul unary
    (90) multiplicative -> . multiplicative Div unary
    (91) multiplicative -> . multiplicative Mod unary
    (64) unary -> . postfix
    (66) unary -> . Minus unary
    (67) unary -> . BitNot unary
    (68) unary -> . Not unary
    (65) postfix -> . primary
    (70) postfix -> . Identifier LParen expression_list RParen
    (71) postfix -> . Identifier index_list
    (93) primary -> . Integer
    (94) primary -> . Identifier
    (95) primary -> . LParen expression RParen

    Semi            reduce using rule 1 (empty -> .)
    Identifier      shift and go to state 17
    Minus           shift and go to state 30
    BitNot          shift and go to state 33
    Not             shift and go to state 34
    Integer         shift and go to state 37
    LParen          shift and go to state 36

    opt_expression                 shift and go to state 174
    expression                     shift and go to state 131
    empty                          shift and go to state 140
    assignment                     shift and go to state 19
    conditional                    shift and go to state 20
    logical_or                     shift and go to state 21
    logical_and                    shift and go to state 22
    bit_or                         shift and go to state 23
    xor                            shift and go to state 24
    bit_and                        shift and go to state 25
    equality                       shift and go to state 26
    relational                     shift and go to state 27
    additive                       shift and go to state 28
    multiplicative                 shift and go to state 29
    unary                          shift and go to state 31
    postfix                        shift and go to state 32
    primary                        shift and go to state 35

state 168

    (22) statement_matched -> If LParen expression RParen statement_matched . Else statement_matched
    (23) statement_unmatched -> If LParen expression RParen statement_matched . Else statement_unmatched
    (25) statement -> statement_matched .

    Else            shift and go to state 175
    RBrace          reduce using rule 25 (statement -> statement_matched .)
    If              reduce using rule 25 (statement -> statement_matched .)
    While           reduce using rule 25 (statement -> statement_matched .)
    Do              reduce using rule 25 (statement -> statement_matched .)
    For             reduce using rule 25 (statement -> statement_matched .)
    Return          reduce using rule 25 (statement -> statement_matched .)
    LBrace          reduce using rule 25 (statement -> statement_matched .)
    Break           reduce using rule 25 (statement -> statement_matched .)
    Continue        reduce using rule 25 (statement -> statement_matched .)
    Int             reduce using rule 25 (statement -> statement_matched .)
    Identifier      reduce using rule 25 (statement -> statement_matched .)
    Minus           reduce using rule 25 (statement -> statement_matched .)
    BitNot          reduce using rule 25 (statement -> statement_matched .)
    Not             reduce using rule 25 (statement -> statement_matched .)
    Integer         reduce using rule 25 (statement -> statement_matched .)
    LParen          reduce using rule 25 (statement -> statement_matched .)
    Semi            reduce using rule 25 (statement -> statement_matched .)


state 169

    (24) statement_unmatched -> If LParen expression RParen statement .

    RBrace          reduce using rule 24 (statement_unmatched -> If LParen expression RParen statement .)
    If              reduce using rule 24 (statement_unmatched -> If LParen expression RParen statement .)
    While           reduce using rule 24 (statement_unmatched -> If LParen expression RParen statement .)
    Do              reduce using rule 24 (statement_unmatched -> If LParen expression RParen statement .)
    For             reduce using rule 24 (statement_unmatched -> If LParen expression RParen statement .)
    Return          reduce using rule 24 (statement_unmatched -> If LParen expression RParen statement .)
    LBrace          reduce using rule 24 (statement_unmatched -> If LParen expression RParen statement .)
    Break           reduce using rule 24 (statement_unmatched -> If LParen expression RParen statement .)
    Continue        reduce using rule 24 (statement_unmatched -> If LParen expression RParen statement .)
    Int             reduce using rule 24 (statement_unmatched -> If LParen expression RParen statement .)
    Identifier      reduce using rule 24 (statement_unmatched -> If LParen expression RParen statement .)
    Minus           reduce using rule 24 (statement_unmatched -> If LParen expression RParen statement .)
    BitNot          reduce using rule 24 (statement_unmatched -> If LParen expression RParen statement .)
    Not             reduce using rule 24 (statement_unmatched -> If LParen expression RParen statement .)
    Integer         reduce using rule 24 (statement_unmatched -> If LParen expression RParen statement .)
    LParen          reduce using rule 24 (statement_unmatched -> If LParen expression RParen statement .)
    Semi            reduce using rule 24 (statement_unmatched -> If LParen expression RParen statement .)


state 170

    (27) statement_matched -> While LParen expression RParen statement_matched .

    RBrace          reduce using rule 27 (statement_matched -> While LParen expression RParen statement_matched .)
    If              reduce using rule 27 (statement_matched -> While LParen expression RParen statement_matched .)
    While           reduce using rule 27 (statement_matched -> While LParen expression RParen statement_matched .)
    Do              reduce using rule 27 (statement_matched -> While LParen expression RParen statement_matched .)
    For             reduce using rule 27 (statement_matched -> While LParen expression RParen statement_matched .)
    Return          reduce using rule 27 (statement_matched -> While LParen expression RParen statement_matched .)
    LBrace          reduce using rule 27 (statement_matched -> While LParen expression RParen statement_matched .)
    Break           reduce using rule 27 (statement_matched -> While LParen expression RParen statement_matched .)
    Continue        reduce using rule 27 (statement_matched -> While LParen expression RParen statement_matched .)
    Int             reduce using rule 27 (statement_matched -> While LParen expression RParen statement_matched .)
    Identifier      reduce using rule 27 (statement_matched -> While LParen expression RParen statement_matched .)
    Minus           reduce using rule 27 (statement_matched -> While LParen expression RParen statement_matched .)
    BitNot          reduce using rule 27 (statement_matched -> While LParen expression RParen statement_matched .)
    Not             reduce using rule 27 (statement_matched -> While LParen expression RParen statement_matched .)
    Integer         reduce using rule 27 (statement_matched -> While LParen expression RParen statement_matched .)
    LParen          reduce using rule 27 (statement_matched -> While LParen expression RParen statement_matched .)
    Semi            reduce using rule 27 (statement_matched -> While LParen expression RParen statement_matched .)
    Else            reduce using rule 27 (statement_matched -> While LParen expression RParen statement_matched .)


state 171

    (28) statement_unmatched -> While LParen expression RParen statement_unmatched .

    RBrace          reduce using rule 28 (statement_unmatched -> While LParen expression RParen statement_unmatched .)
    If              reduce using rule 28 (statement_unmatched -> While LParen expression RParen statement_unmatched .)
    While           reduce using rule 28 (statement_unmatched -> While LParen expression RParen statement_unmatched .)
    Do              reduce using rule 28 (statement_unmatched -> While LParen expression RParen statement_unmatched .)
    For             reduce using rule 28 (statement_unmatched -> While LParen expression RParen statement_unmatched .)
    Return          reduce using rule 28 (statement_unmatched -> While LParen expression RParen statement_unmatched .)
    LBrace          reduce using rule 28 (statement_unmatched -> While LParen expression RParen statement_unmatched .)
    Break           reduce using rule 28 (statement_unmatched -> While LParen expression RParen statement_unmatched .)
    Continue        reduce using rule 28 (statement_unmatched -> While LParen expression RParen statement_unmatched .)
    Int             reduce using rule 28 (statement_unmatched -> While LParen expression RParen statement_unmatched .)
    Identifier      reduce using rule 28 (statement_unmatched -> While LParen expression RParen statement_unmatched .)
    Minus           reduce using rule 28 (statement_unmatched -> While LParen expression RParen statement_unmatched .)
    BitNot          reduce using rule 28 (statement_unmatched -> While LParen expression RParen statement_unmatched .)
    Not             reduce using rule 28 (statement_unmatched -> While LParen expression RParen statement_unmatched .)
    Integer         reduce using rule 28 (statement_unmatched -> While LParen expression RParen statement_unmatched .)
    LParen          reduce using rule 28 (statement_unmatched -> While LParen expression RParen statement_unmatched .)
    Semi            reduce using rule 28 (statement_unmatched -> While LParen expression RParen statement_unmatched .)


state 172

    (29) statement_matched -> Do statement_matched While LParen expression . RParen Semi

    RParen          shift and go to state 176


state 173

    (30) statement_unmatched -> Do statement_unmatched While LParen expression . RParen Semi

    RParen          shift and go to state 177


state 174

    (31) statement_matched -> For LParen p_decl_opt_expr_union Semi opt_expression . Semi opt_expression RParen statement_matched
    (32) statement_unmatched -> For LParen p_decl_opt_expr_union Semi opt_expression . Semi opt_expression RParen statement_unmatched

    Semi            shift and go to state 178


state 175

    (22) statement_matched -> If LParen expression RParen statement_matched Else . statement_matched
    (23) statement_unmatched -> If LParen expression RParen statement_matched Else . statement_unmatched
    (22) statement_matched -> . If LParen expression RParen statement_matched Else statement_matched
    (27) statement_matched -> . While LParen expression RParen statement_matched
    (29) statement_matched -> . Do statement_matched While LParen expression RParen Semi
    (31) statement_matched -> . For LParen p_decl_opt_expr_union Semi opt_expression Semi opt_expression RParen statement_matched
    (35) statement_matched -> . Return expression Semi
    (36) statement_matched -> . opt_expression Semi
    (37) statement_matched -> . LBrace block RBrace
    (38) statement_matched -> . Break Semi
    (39) statement_matched -> . Continue Semi
    (23) statement_unmatched -> . If LParen expression RParen statement_matched Else statement_unmatched
    (24) statement_unmatched -> . If LParen expression RParen statement
    (28) statement_unmatched -> . While LParen expression RParen statement_unmatched
    (30) statement_unmatched -> . Do statement_unmatched While LParen expression RParen Semi
    (32) statement_unmatched -> . For LParen p_decl_opt_expr_union Semi opt_expression Semi opt_expression RParen statement_unmatched
    (40) opt_expression -> . expression
    (41) opt_expression -> . empty
    (52) expression -> . assignment
    (1) empty -> .
    (53) assignment -> . conditional
    (69) assignment -> . Identifier index_list Assign expression
    (75) assignment -> . Identifier Assign expression
    (54) conditional -> . logical_or
    (92) conditional -> . logical_or Question expression Colon conditional
    (55) logical_or -> . logical_and
    (76) logical_or -> . logical_or Or logical_and
    (56) logical_and -> . bit_or
    (77) logical_and -> . logical_and And bit_or
    (57) bit_or -> . xor
    (78) bit_or -> . bit_or BitOr xor
    (58) xor -> . bit_and
    (79) xor -> . xor Xor bit_and
    (59) bit_and -> . equality
    (80) bit_and -> . bit_and BitAnd equality
    (60) equality -> . relational
    (81) equality -> . equality NotEqual relational
    (82) equality -> . equality Equal relational
    (61) relational -> . additive
    (83) relational -> . relational Less additive
    (84) relational -> . relational Greater additive
    (85) relational -> . relational LessEqual additive
    (86) relational -> . relational GreaterEqual additive
    (62) additive -> . multiplicative
    (87) additive -> . additive Plus multiplicative
    (88) additive -> . additive Minus multiplicative
    (63) multiplicative -> . unary
    (89) multiplicative -> . multiplicative Mul unary
    (90) multiplicative -> . multiplicative Div unary
    (91) multiplicative -> . multiplicative Mod unary
    (64) unary -> . postfix
    (66) unary -> . Minus unary
    (67) unary -> . BitNot unary
    (68) unary -> . Not unary
    (65) postfix -> . primary
    (70) postfix -> . Identifier LParen expression_list RParen
    (71) postfix -> . Identifier index_list
    (93) primary -> . Integer
    (94) primary -> . Identifier
    (95) primary -> . LParen expression RParen

    If              shift and go to state 132
    While           shift and go to state 133
    Do              shift and go to state 134
    For             shift and go to state 135
    Return          shift and go to state 137
    LBrace          shift and go to state 124
    Break           shift and go to state 138
    Continue        shift and go to state 139
    Semi            reduce using rule 1 (empty -> .)
    Identifier      shift and go to state 17
    Minus           shift and go to state 30
    BitNot          shift and go to state 33
    Not             shift and go to state 34
    Integer         shift and go to state 37
    LParen          shift and go to state 36

    expression                     shift and go to state 131
    statement_matched              shift and go to state 179
    statement_unmatched            shift and go to state 180
    opt_expression                 shift and go to state 136
    empty                          shift and go to state 140
    assignment                     shift and go to state 19
    conditional                    shift and go to state 20
    logical_or                     shift and go to state 21
    logical_and                    shift and go to state 22
    bit_or                         shift and go to state 23
    xor                            shift and go to state 24
    bit_and                        shift and go to state 25
    equality                       shift and go to state 26
    relational                     shift and go to state 27
    additive                       shift and go to state 28
    multiplicative                 shift and go to state 29
    unary                          shift and go to state 31
    postfix                        shift and go to state 32
    primary                        shift and go to state 35

state 176

    (29) statement_matched -> Do statement_matched While LParen expression RParen . Semi

    Semi            shift and go to state 181


state 177

    (30) statement_unmatched -> Do statement_unmatched While LParen expression RParen . Semi

    Semi            shift and go to state 182


state 178

    (31) statement_matched -> For LParen p_decl_opt_expr_union Semi opt_expression Semi . opt_expression RParen statement_matched
    (32) statement_unmatched -> For LParen p_decl_opt_expr_union Semi opt_expression Semi . opt_expression RParen statement_unmatched
    (40) opt_expression -> . expression
    (41) opt_expression -> . empty
    (52) expression -> . assignment
    (1) empty -> .
    (53) assignment -> . conditional
    (69) assignment -> . Identifier index_list Assign expression
    (75) assignment -> . Identifier Assign expression
    (54) conditional -> . logical_or
    (92) conditional -> . logical_or Question expression Colon conditional
    (55) logical_or -> . logical_and
    (76) logical_or -> . logical_or Or logical_and
    (56) logical_and -> . bit_or
    (77) logical_and -> . logical_and And bit_or
    (57) bit_or -> . xor
    (78) bit_or -> . bit_or BitOr xor
    (58) xor -> . bit_and
    (79) xor -> . xor Xor bit_and
    (59) bit_and -> . equality
    (80) bit_and -> . bit_and BitAnd equality
    (60) equality -> . relational
    (81) equality -> . equality NotEqual relational
    (82) equality -> . equality Equal relational
    (61) relational -> . additive
    (83) relational -> . relational Less additive
    (84) relational -> . relational Greater additive
    (85) relational -> . relational LessEqual additive
    (86) relational -> . relational GreaterEqual additive
    (62) additive -> . multiplicative
    (87) additive -> . additive Plus multiplicative
    (88) additive -> . additive Minus multiplicative
    (63) multiplicative -> . unary
    (89) multiplicative -> . multiplicative Mul unary
    (90) multiplicative -> . multiplicative Div unary
    (91) multiplicative -> . multiplicative Mod unary
    (64) unary -> . postfix
    (66) unary -> . Minus unary
    (67) unary -> . BitNot unary
    (68) unary -> . Not unary
    (65) postfix -> . primary
    (70) postfix -> . Identifier LParen expression_list RParen
    (71) postfix -> . Identifier index_list
    (93) primary -> . Integer
    (94) primary -> . Identifier
    (95) primary -> . LParen expression RParen

    RParen          reduce using rule 1 (empty -> .)
    Identifier      shift and go to state 17
    Minus           shift and go to state 30
    BitNot          shift and go to state 33
    Not             shift and go to state 34
    Integer         shift and go to state 37
    LParen          shift and go to state 36

    opt_expression                 shift and go to state 183
    expression                     shift and go to state 131
    empty                          shift and go to state 140
    assignment                     shift and go to state 19
    conditional                    shift and go to state 20
    logical_or                     shift and go to state 21
    logical_and                    shift and go to state 22
    bit_or                         shift and go to state 23
    xor                            shift and go to state 24
    bit_and                        shift and go to state 25
    equality                       shift and go to state 26
    relational                     shift and go to state 27
    additive                       shift and go to state 28
    multiplicative                 shift and go to state 29
    unary                          shift and go to state 31
    postfix                        shift and go to state 32
    primary                        shift and go to state 35

state 179

    (22) statement_matched -> If LParen expression RParen statement_matched Else statement_matched .

    RBrace          reduce using rule 22 (statement_matched -> If LParen expression RParen statement_matched Else statement_matched .)
    If              reduce using rule 22 (statement_matched -> If LParen expression RParen statement_matched Else statement_matched .)
    While           reduce using rule 22 (statement_matched -> If LParen expression RParen statement_matched Else statement_matched .)
    Do              reduce using rule 22 (statement_matched -> If LParen expression RParen statement_matched Else statement_matched .)
    For             reduce using rule 22 (statement_matched -> If LParen expression RParen statement_matched Else statement_matched .)
    Return          reduce using rule 22 (statement_matched -> If LParen expression RParen statement_matched Else statement_matched .)
    LBrace          reduce using rule 22 (statement_matched -> If LParen expression RParen statement_matched Else statement_matched .)
    Break           reduce using rule 22 (statement_matched -> If LParen expression RParen statement_matched Else statement_matched .)
    Continue        reduce using rule 22 (statement_matched -> If LParen expression RParen statement_matched Else statement_matched .)
    Int             reduce using rule 22 (statement_matched -> If LParen expression RParen statement_matched Else statement_matched .)
    Identifier      reduce using rule 22 (statement_matched -> If LParen expression RParen statement_matched Else statement_matched .)
    Minus           reduce using rule 22 (statement_matched -> If LParen expression RParen statement_matched Else statement_matched .)
    BitNot          reduce using rule 22 (statement_matched -> If LParen expression RParen statement_matched Else statement_matched .)
    Not             reduce using rule 22 (statement_matched -> If LParen expression RParen statement_matched Else statement_matched .)
    Integer         reduce using rule 22 (statement_matched -> If LParen expression RParen statement_matched Else statement_matched .)
    LParen          reduce using rule 22 (statement_matched -> If LParen expression RParen statement_matched Else statement_matched .)
    Semi            reduce using rule 22 (statement_matched -> If LParen expression RParen statement_matched Else statement_matched .)
    Else            reduce using rule 22 (statement_matched -> If LParen expression RParen statement_matched Else statement_matched .)


state 180

    (23) statement_unmatched -> If LParen expression RParen statement_matched Else statement_unmatched .

    RBrace          reduce using rule 23 (statement_unmatched -> If LParen expression RParen statement_matched Else statement_unmatched .)
    If              reduce using rule 23 (statement_unmatched -> If LParen expression RParen statement_matched Else statement_unmatched .)
    While           reduce using rule 23 (statement_unmatched -> If LParen expression RParen statement_matched Else statement_unmatched .)
    Do              reduce using rule 23 (statement_unmatched -> If LParen expression RParen statement_matched Else statement_unmatched .)
    For             reduce using rule 23 (statement_unmatched -> If LParen expression RParen statement_matched Else statement_unmatched .)
    Return          reduce using rule 23 (statement_unmatched -> If LParen expression RParen statement_matched Else statement_unmatched .)
    LBrace          reduce using rule 23 (statement_unmatched -> If LParen expression RParen statement_matched Else statement_unmatched .)
    Break           reduce using rule 23 (statement_unmatched -> If LParen expression RParen statement_matched Else statement_unmatched .)
    Continue        reduce using rule 23 (statement_unmatched -> If LParen expression RParen statement_matched Else statement_unmatched .)
    Int             reduce using rule 23 (statement_unmatched -> If LParen expression RParen statement_matched Else statement_unmatched .)
    Identifier      reduce using rule 23 (statement_unmatched -> If LParen expression RParen statement_matched Else statement_unmatched .)
    Minus           reduce using rule 23 (statement_unmatched -> If LParen expression RParen statement_matched Else statement_unmatched .)
    BitNot          reduce using rule 23 (statement_unmatched -> If LParen expression RParen statement_matched Else statement_unmatched .)
    Not             reduce using rule 23 (statement_unmatched -> If LParen expression RParen statement_matched Else statement_unmatched .)
    Integer         reduce using rule 23 (statement_unmatched -> If LParen expression RParen statement_matched Else statement_unmatched .)
    LParen          reduce using rule 23 (statement_unmatched -> If LParen expression RParen statement_matched Else statement_unmatched .)
    Semi            reduce using rule 23 (statement_unmatched -> If LParen expression RParen statement_matched Else statement_unmatched .)


state 181

    (29) statement_matched -> Do statement_matched While LParen expression RParen Semi .

    RBrace          reduce using rule 29 (statement_matched -> Do statement_matched While LParen expression RParen Semi .)
    If              reduce using rule 29 (statement_matched -> Do statement_matched While LParen expression RParen Semi .)
    While           reduce using rule 29 (statement_matched -> Do statement_matched While LParen expression RParen Semi .)
    Do              reduce using rule 29 (statement_matched -> Do statement_matched While LParen expression RParen Semi .)
    For             reduce using rule 29 (statement_matched -> Do statement_matched While LParen expression RParen Semi .)
    Return          reduce using rule 29 (statement_matched -> Do statement_matched While LParen expression RParen Semi .)
    LBrace          reduce using rule 29 (statement_matched -> Do statement_matched While LParen expression RParen Semi .)
    Break           reduce using rule 29 (statement_matched -> Do statement_matched While LParen expression RParen Semi .)
    Continue        reduce using rule 29 (statement_matched -> Do statement_matched While LParen expression RParen Semi .)
    Int             reduce using rule 29 (statement_matched -> Do statement_matched While LParen expression RParen Semi .)
    Identifier      reduce using rule 29 (statement_matched -> Do statement_matched While LParen expression RParen Semi .)
    Minus           reduce using rule 29 (statement_matched -> Do statement_matched While LParen expression RParen Semi .)
    BitNot          reduce using rule 29 (statement_matched -> Do statement_matched While LParen expression RParen Semi .)
    Not             reduce using rule 29 (statement_matched -> Do statement_matched While LParen expression RParen Semi .)
    Integer         reduce using rule 29 (statement_matched -> Do statement_matched While LParen expression RParen Semi .)
    LParen          reduce using rule 29 (statement_matched -> Do statement_matched While LParen expression RParen Semi .)
    Semi            reduce using rule 29 (statement_matched -> Do statement_matched While LParen expression RParen Semi .)
    Else            reduce using rule 29 (statement_matched -> Do statement_matched While LParen expression RParen Semi .)


state 182

    (30) statement_unmatched -> Do statement_unmatched While LParen expression RParen Semi .

    RBrace          reduce using rule 30 (statement_unmatched -> Do statement_unmatched While LParen expression RParen Semi .)
    If              reduce using rule 30 (statement_unmatched -> Do statement_unmatched While LParen expression RParen Semi .)
    While           reduce using rule 30 (statement_unmatched -> Do statement_unmatched While LParen expression RParen Semi .)
    Do              reduce using rule 30 (statement_unmatched -> Do statement_unmatched While LParen expression RParen Semi .)
    For             reduce using rule 30 (statement_unmatched -> Do statement_unmatched While LParen expression RParen Semi .)
    Return          reduce using rule 30 (statement_unmatched -> Do statement_unmatched While LParen expression RParen Semi .)
    LBrace          reduce using rule 30 (statement_unmatched -> Do statement_unmatched While LParen expression RParen Semi .)
    Break           reduce using rule 30 (statement_unmatched -> Do statement_unmatched While LParen expression RParen Semi .)
    Continue        reduce using rule 30 (statement_unmatched -> Do statement_unmatched While LParen expression RParen Semi .)
    Int             reduce using rule 30 (statement_unmatched -> Do statement_unmatched While LParen expression RParen Semi .)
    Identifier      reduce using rule 30 (statement_unmatched -> Do statement_unmatched While LParen expression RParen Semi .)
    Minus           reduce using rule 30 (statement_unmatched -> Do statement_unmatched While LParen expression RParen Semi .)
    BitNot          reduce using rule 30 (statement_unmatched -> Do statement_unmatched While LParen expression RParen Semi .)
    Not             reduce using rule 30 (statement_unmatched -> Do statement_unmatched While LParen expression RParen Semi .)
    Integer         reduce using rule 30 (statement_unmatched -> Do statement_unmatched While LParen expression RParen Semi .)
    LParen          reduce using rule 30 (statement_unmatched -> Do statement_unmatched While LParen expression RParen Semi .)
    Semi            reduce using rule 30 (statement_unmatched -> Do statement_unmatched While LParen expression RParen Semi .)


state 183

    (31) statement_matched -> For LParen p_decl_opt_expr_union Semi opt_expression Semi opt_expression . RParen statement_matched
    (32) statement_unmatched -> For LParen p_decl_opt_expr_union Semi opt_expression Semi opt_expression . RParen statement_unmatched

    RParen          shift and go to state 184


state 184

    (31) statement_matched -> For LParen p_decl_opt_expr_union Semi opt_expression Semi opt_expression RParen . statement_matched
    (32) statement_unmatched -> For LParen p_decl_opt_expr_union Semi opt_expression Semi opt_expression RParen . statement_unmatched
    (22) statement_matched -> . If LParen expression RParen statement_matched Else statement_matched
    (27) statement_matched -> . While LParen expression RParen statement_matched
    (29) statement_matched -> . Do statement_matched While LParen expression RParen Semi
    (31) statement_matched -> . For LParen p_decl_opt_expr_union Semi opt_expression Semi opt_expression RParen statement_matched
    (35) statement_matched -> . Return expression Semi
    (36) statement_matched -> . opt_expression Semi
    (37) statement_matched -> . LBrace block RBrace
    (38) statement_matched -> . Break Semi
    (39) statement_matched -> . Continue Semi
    (23) statement_unmatched -> . If LParen expression RParen statement_matched Else statement_unmatched
    (24) statement_unmatched -> . If LParen expression RParen statement
    (28) statement_unmatched -> . While LParen expression RParen statement_unmatched
    (30) statement_unmatched -> . Do statement_unmatched While LParen expression RParen Semi
    (32) statement_unmatched -> . For LParen p_decl_opt_expr_union Semi opt_expression Semi opt_expression RParen statement_unmatched
    (40) opt_expression -> . expression
    (41) opt_expression -> . empty
    (52) expression -> . assignment
    (1) empty -> .
    (53) assignment -> . conditional
    (69) assignment -> . Identifier index_list Assign expression
    (75) assignment -> . Identifier Assign expression
    (54) conditional -> . logical_or
    (92) conditional -> . logical_or Question expression Colon conditional
    (55) logical_or -> . logical_and
    (76) logical_or -> . logical_or Or logical_and
    (56) logical_and -> . bit_or
    (77) logical_and -> . logical_and And bit_or
    (57) bit_or -> . xor
    (78) bit_or -> . bit_or BitOr xor
    (58) xor -> . bit_and
    (79) xor -> . xor Xor bit_and
    (59) bit_and -> . equality
    (80) bit_and -> . bit_and BitAnd equality
    (60) equality -> . relational
    (81) equality -> . equality NotEqual relational
    (82) equality -> . equality Equal relational
    (61) relational -> . additive
    (83) relational -> . relational Less additive
    (84) relational -> . relational Greater additive
    (85) relational -> . relational LessEqual additive
    (86) relational -> . relational GreaterEqual additive
    (62) additive -> . multiplicative
    (87) additive -> . additive Plus multiplicative
    (88) additive -> . additive Minus multiplicative
    (63) multiplicative -> . unary
    (89) multiplicative -> . multiplicative Mul unary
    (90) multiplicative -> . multiplicative Div unary
    (91) multiplicative -> . multiplicative Mod unary
    (64) unary -> . postfix
    (66) unary -> . Minus unary
    (67) unary -> . BitNot unary
    (68) unary -> . Not unary
    (65) postfix -> . primary
    (70) postfix -> . Identifier LParen expression_list RParen
    (71) postfix -> . Identifier index_list
    (93) primary -> . Integer
    (94) primary -> . Identifier
    (95) primary -> . LParen expression RParen

    If              shift and go to state 132
    While           shift and go to state 133
    Do              shift and go to state 134
    For             shift and go to state 135
    Return          shift and go to state 137
    LBrace          shift and go to state 124
    Break           shift and go to state 138
    Continue        shift and go to state 139
    Semi            reduce using rule 1 (empty -> .)
    Identifier      shift and go to state 17
    Minus           shift and go to state 30
    BitNot          shift and go to state 33
    Not             shift and go to state 34
    Integer         shift and go to state 37
    LParen          shift and go to state 36

    opt_expression                 shift and go to state 136
    statement_matched              shift and go to state 185
    statement_unmatched            shift and go to state 186
    expression                     shift and go to state 131
    empty                          shift and go to state 140
    assignment                     shift and go to state 19
    conditional                    shift and go to state 20
    logical_or                     shift and go to state 21
    logical_and                    shift and go to state 22
    bit_or                         shift and go to state 23
    xor                            shift and go to state 24
    bit_and                        shift and go to state 25
    equality                       shift and go to state 26
    relational                     shift and go to state 27
    additive                       shift and go to state 28
    multiplicative                 shift and go to state 29
    unary                          shift and go to state 31
    postfix                        shift and go to state 32
    primary                        shift and go to state 35

state 185

    (31) statement_matched -> For LParen p_decl_opt_expr_union Semi opt_expression Semi opt_expression RParen statement_matched .

    RBrace          reduce using rule 31 (statement_matched -> For LParen p_decl_opt_expr_union Semi opt_expression Semi opt_expression RParen statement_matched .)
    If              reduce using rule 31 (statement_matched -> For LParen p_decl_opt_expr_union Semi opt_expression Semi opt_expression RParen statement_matched .)
    While           reduce using rule 31 (statement_matched -> For LParen p_decl_opt_expr_union Semi opt_expression Semi opt_expression RParen statement_matched .)
    Do              reduce using rule 31 (statement_matched -> For LParen p_decl_opt_expr_union Semi opt_expression Semi opt_expression RParen statement_matched .)
    For             reduce using rule 31 (statement_matched -> For LParen p_decl_opt_expr_union Semi opt_expression Semi opt_expression RParen statement_matched .)
    Return          reduce using rule 31 (statement_matched -> For LParen p_decl_opt_expr_union Semi opt_expression Semi opt_expression RParen statement_matched .)
    LBrace          reduce using rule 31 (statement_matched -> For LParen p_decl_opt_expr_union Semi opt_expression Semi opt_expression RParen statement_matched .)
    Break           reduce using rule 31 (statement_matched -> For LParen p_decl_opt_expr_union Semi opt_expression Semi opt_expression RParen statement_matched .)
    Continue        reduce using rule 31 (statement_matched -> For LParen p_decl_opt_expr_union Semi opt_expression Semi opt_expression RParen statement_matched .)
    Int             reduce using rule 31 (statement_matched -> For LParen p_decl_opt_expr_union Semi opt_expression Semi opt_expression RParen statement_matched .)
    Identifier      reduce using rule 31 (statement_matched -> For LParen p_decl_opt_expr_union Semi opt_expression Semi opt_expression RParen statement_matched .)
    Minus           reduce using rule 31 (statement_matched -> For LParen p_decl_opt_expr_union Semi opt_expression Semi opt_expression RParen statement_matched .)
    BitNot          reduce using rule 31 (statement_matched -> For LParen p_decl_opt_expr_union Semi opt_expression Semi opt_expression RParen statement_matched .)
    Not             reduce using rule 31 (statement_matched -> For LParen p_decl_opt_expr_union Semi opt_expression Semi opt_expression RParen statement_matched .)
    Integer         reduce using rule 31 (statement_matched -> For LParen p_decl_opt_expr_union Semi opt_expression Semi opt_expression RParen statement_matched .)
    LParen          reduce using rule 31 (statement_matched -> For LParen p_decl_opt_expr_union Semi opt_expression Semi opt_expression RParen statement_matched .)
    Semi            reduce using rule 31 (statement_matched -> For LParen p_decl_opt_expr_union Semi opt_expression Semi opt_expression RParen statement_matched .)
    Else            reduce using rule 31 (statement_matched -> For LParen p_decl_opt_expr_union Semi opt_expression Semi opt_expression RParen statement_matched .)


state 186

    (32) statement_unmatched -> For LParen p_decl_opt_expr_union Semi opt_expression Semi opt_expression RParen statement_unmatched .

    RBrace          reduce using rule 32 (statement_unmatched -> For LParen p_decl_opt_expr_union Semi opt_expression Semi opt_expression RParen statement_unmatched .)
    If              reduce using rule 32 (statement_unmatched -> For LParen p_decl_opt_expr_union Semi opt_expression Semi opt_expression RParen statement_unmatched .)
    While           reduce using rule 32 (statement_unmatched -> For LParen p_decl_opt_expr_union Semi opt_expression Semi opt_expression RParen statement_unmatched .)
    Do              reduce using rule 32 (statement_unmatched -> For LParen p_decl_opt_expr_union Semi opt_expression Semi opt_expression RParen statement_unmatched .)
    For             reduce using rule 32 (statement_unmatched -> For LParen p_decl_opt_expr_union Semi opt_expression Semi opt_expression RParen statement_unmatched .)
    Return          reduce using rule 32 (statement_unmatched -> For LParen p_decl_opt_expr_union Semi opt_expression Semi opt_expression RParen statement_unmatched .)
    LBrace          reduce using rule 32 (statement_unmatched -> For LParen p_decl_opt_expr_union Semi opt_expression Semi opt_expression RParen statement_unmatched .)
    Break           reduce using rule 32 (statement_unmatched -> For LParen p_decl_opt_expr_union Semi opt_expression Semi opt_expression RParen statement_unmatched .)
    Continue        reduce using rule 32 (statement_unmatched -> For LParen p_decl_opt_expr_union Semi opt_expression Semi opt_expression RParen statement_unmatched .)
    Int             reduce using rule 32 (statement_unmatched -> For LParen p_decl_opt_expr_union Semi opt_expression Semi opt_expression RParen statement_unmatched .)
    Identifier      reduce using rule 32 (statement_unmatched -> For LParen p_decl_opt_expr_union Semi opt_expression Semi opt_expression RParen statement_unmatched .)
    Minus           reduce using rule 32 (statement_unmatched -> For LParen p_decl_opt_expr_union Semi opt_expression Semi opt_expression RParen statement_unmatched .)
    BitNot          reduce using rule 32 (statement_unmatched -> For LParen p_decl_opt_expr_union Semi opt_expression Semi opt_expression RParen statement_unmatched .)
    Not             reduce using rule 32 (statement_unmatched -> For LParen p_decl_opt_expr_union Semi opt_expression Semi opt_expression RParen statement_unmatched .)
    Integer         reduce using rule 32 (statement_unmatched -> For LParen p_decl_opt_expr_union Semi opt_expression Semi opt_expression RParen statement_unmatched .)
    LParen          reduce using rule 32 (statement_unmatched -> For LParen p_decl_opt_expr_union Semi opt_expression Semi opt_expression RParen statement_unmatched .)
    Semi            reduce using rule 32 (statement_unmatched -> For LParen p_decl_opt_expr_union Semi opt_expression Semi opt_expression RParen statement_unmatched .)

